# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"The most low level version of an event, representing both events and event sets"
interface BaseEvent {
    "Street-level address"
    address: String!
    "All Additional Images"
    allImages: [Image!]!
    "Cover Photo"
    coverPhoto: Image!
    "A detailed description of the event"
    description(format: ContentFormat = TEXT): String!
    "Hidden Date"
    hiddenDate: Boolean
    id: ID!
    "Other Images"
    images: ImageConnection!
    latitude: Float!
    longitude: Float!
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String!
    "A brief description"
    title: String!
    "Event or EventSet creator"
    user: Profile!
    "Name of the venue"
    venueName: String
}

"The most common 'person'-level interface in Universe"
interface User {
    admin: Boolean!
    "The avatar URL, 160x160 pixels"
    avatarUrl: String
    "The Business Seller address for businesses in the EU"
    businessAddress: String
    "The Business Seller Email for businesses in the EU"
    businessEmail: String
    "The Business Seller Phone Number for businesses in the EU"
    businessPhoneNumber: String
    "A user-defined description"
    description: String
    "The first name of the type implementing a User interface"
    firstName: String
    id: ID
    "The last name of the type implementing a User interface"
    lastName: String
    "User locale"
    locale: Locale
    "A single field concatenating firstName and lastName"
    name: String
    "The type of the viewer account (Admin, User, Spammer, etc)"
    role: UserRole!
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String
    "The avatar URL, 50x50 pixels"
    smallAvatarUrl: String
    superAdmin: Boolean!
}

"Access Keys allow you to password protect tickets so you can sell tickets to a certain group of patrons. Perfect for offering special rates for members or VIPs."
type AccessKey {
    id: ID!
    key: String!
    "The total number of locked tickets that can be purchased with a given key."
    quantity: Int
    state: AccessKeyState!
}

type AccessKeyConnection {
    nodes(limit: Int = 10, offset: Int = 0): [AccessKey!]!
    pagination: JSON
    totalCount: Int!
}

"A product or service that can be sold at any of your events"
type AddOn {
    "The currency in which the add-on is sold"
    currency: CurrencyCode
    "A detailed description of the add-on"
    description: String
    "Events where this add on is available. Set to [] for all events."
    eventIds: [ID]
    events: [Event]
    "The creator of the add-on"
    host: Host
    "Determines who pays the Universe service fee."
    hostPaysCommission: Boolean
    id: ID
    "The name of add-on item being sold"
    name: String
    "The rates associated with the add-on"
    rates: [AddOnRate]
    "The taxes associated with the add-on"
    taxes: [Tax]
}

type AddOnConnection {
    nodes(limit: Int = 10, offset: Int = 0): [AddOn!]!
    pagination: JSON
    totalCount: Int!
}

"Autogenerated return type of AddOnCreate"
type AddOnCreatePayload {
    addOn: AddOn
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [Error!]
}

"Autogenerated return type of AddOnDelete"
type AddOnDeletePayload {
    addOn: AddOn
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
}

"Rates are product types available for sale - most typically these are tickets, in this case configured for add-on"
type AddOnRate {
    "Associated add-on for this rate"
    addOn: AddOn
    "Amount available after considering claims and sold items"
    availability: Int
    "Capacities for add on rate"
    capacities: [RateCapacity!]
    "Number of add-on items available in stock"
    capacity: Int
    "Description of rate"
    description: String
    "The displayed price of this specific rate with all in pricing"
    displayPrice: Float
    eventId: String
    id: ID!
    "A URL to the event image. Custom height and width can be supplied"
    imageUrl(
        "Height of the image"
        height: Int = 160,
        "Width of the image"
        width: Int = 160
    ): String
    "Images of the add on option"
    images: [Image!]
    "Maximum number of add-ons allowed per order"
    maxQuantity: Int
    "Minimum number of add-ons required per order"
    minQuantity: Int
    "The name of the rate"
    name: String!
    optionName: String
    "The sale price of this specific rate"
    price: Float
    "Product number of this specific add-on rate"
    sku: String
    "The currency the buyer must purchase the rate in"
    srcCurrency: String!
    "The state of a specific add-on rate"
    state: RateState
    "The type of rate"
    type: String!
    "Whether an add on rate has sold add-ons or not"
    used: Boolean!
}

"Autogenerated return type of AddOnUpdate"
type AddOnUpdatePayload {
    addOn: AddOn
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [Error!]
}

"Analytics data for Viewer"
type Analytics {
    "Add-on revenue amount by this currency"
    addOnSalesAmount(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): Float!
    "Add-on sales by day"
    addOnSalesByDay(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): [DailySales!]!
    "Average OrderItem count per Order"
    averageOrderItemCountPerOrder(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): Float
    "Average OrderItem price"
    averageOrderItemPrice(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): Float
    "Average Order price"
    averageOrderPrice(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): Float
    "Aggregate top buyers' locations"
    buyersLocations(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): [BuyersLocation!]!
    "Revenue amount by this currency"
    salesAmount(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): Float!
    "Sales by day"
    salesByDay(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): [DailySales!]!
    "Aggregate sales information by channels"
    salesChannels(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): [SalesChannel!]!
    "Ticket revenue amount by this currency"
    ticketSalesAmount(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): Float!
    "Ticket sales by day"
    ticketSalesByDay(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): [DailySales!]!
    "Total tickets sold per currency"
    ticketsSold(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): Int!
    "The most popular hour of Order purchase"
    topHourOfPurchase(currency: CurrencyCode!, from: Date!, slugs: [String!], to: Date!): Int
}

type Answer {
    id: ID!
    question: Question!
    "Value of the Answer - the actual 'answer' to the question asked to the user. Note that this field returns a string, but the content will contain stringified versions of other types like arrays. This behavior exists because GraphQL does not currently support union scalar field types. Universe recommends parsing these values as JSON in whatever consuming application you are writing."
    value: JSON
}

"A ticket-holder"
type Attendee {
    "Attendee-speicific answers to checkout questions on the OrderItem level (i.e. Ticket)"
    answers: [Answer]!
    email: String!
    "The Event the attendee is attending"
    event: Event!
    firstName: String!
    id: ID!
    lastName: String
    "The Order which generated this attendee"
    order: Order!
    "The individual OrderItem on the Order which is for this attendee"
    orderItem: OrderItem!
    "Typically, the ticket-type belonging to the attendee."
    rate: Rate!
    "The state of the Order this attendee's ticket was purchased via - note, importantly, that this can be an invalid state. If you are using this information to validate a guest list, you should filter your results for only those tickets you consider valid."
    state: OrderItemState!
    "The TimeSlot of the Event the attendee is attending"
    timeSlot: TimeSlot!
    "The token that the individual will present in order to gain access to the event. Typically in the form of a QRCode."
    token: String!
}

type AttendeeConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Attendee!]!
    pagination: JSON
    totalCount: Int!
}

"Autogenerated return type of AttendeesMessage"
type AttendeesMessagePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Available months for an event grouped by year."
type AvailableMonths {
    "Event month"
    months: [Int]!
    "Event year"
    year: Int!
}

"Autogenerated return type of BulkOrderTimeSlotUpdate"
type BulkOrderTimeSlotUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [Error!]
    orders: [Order!]
}

"A user who has created an Order on Universe"
type Buyer implements User {
    admin: Boolean!
    "The avatar URL, 160x160 pixels"
    avatarUrl: String
    "The Business Seller address for businesses in the EU"
    businessAddress: String
    "The Business Seller Email for businesses in the EU"
    businessEmail: String
    "The Business Seller Phone Number for businesses in the EU"
    businessPhoneNumber: String
    "A user-defined description"
    description: String
    "A (potentially unconfirmed) email address - uniquely tied to the Buyer ID"
    email: String!
    "The first name of the type implementing a User interface"
    firstName: String
    id: ID
    "The last name of the type implementing a User interface"
    lastName: String
    "User locale"
    locale: Locale
    "A single field concatenating firstName and lastName"
    name: String
    "Orders created for this Event"
    orders: OrderConnection
    "The type of the viewer account (Admin, User, Spammer, etc)"
    role: UserRole!
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String
    "The avatar URL, 50x50 pixels"
    smallAvatarUrl: String
    superAdmin: Boolean!
}

"Number of Buyers per Location"
type BuyersLocation {
    "Number of Buyers per Location"
    buyerCount: Int!
    "Buyers' Location"
    location: Location!
}

"Calendar namespace for widgets"
type Calendar {
    "List of dates with future / ongoing Events"
    dates: [Date!]!
    "List of ongoing / future TimeSlots, sorted by startAt, unique by startDate and Event."
    timeSlots(
        "Supply an ISO8601-formatted date string to filter time slots by date"
        date: Date
    ): TimeSlotConnection!
}

"Calendar namespace for the new single widgets"
type CalendarWidget {
    "Whether to enable waitlist for the Event"
    allowWaitlist: Boolean!
    "Available months for the event grouped by year"
    availableMonths: [AvailableMonths]!
    "Available Timeslots"
    calendarDates: [CalendarWidgetDate]!
    "Calendar timeslots"
    calendarTimeslots: [CalendarWidgetTimeslot]!
    "A detailed description of the event"
    description(format: ContentFormat = TEXT): String!
    hostId: ID!
    id: ID!
    "Tickets are sold out for this Event"
    soldOut: Boolean!
    "Sold out dates"
    soldOutDates: [String]!
    "Determines if a given event is timed entry based"
    timedEntry: Boolean!
    "Timezone of the event location"
    timezone: String!
    "A brief description"
    title: String!
    "Currency that is displayed and charged in"
    transactionCurrency: CurrencyCode!
}

"CalendarWidgetDate"
type CalendarWidgetDate {
    "calendar timeslots"
    calendarTimeslotIds: [ID]!
    "date"
    date: String
    "totalCount"
    totalCount: Int
}

"CalendarWidgetTimeslot"
type CalendarWidgetTimeslot {
    "Timeslot end date and time in UTC"
    endAt: String!
    "Determines if the end date has passed or not"
    endDatePassed: Boolean!
    "Extended timeslot end date and time in UTC"
    extendedEndAt: String!
    id: ID!
    "max price"
    maxPrice: Float
    "min price"
    minPrice: Float
    "Tickets are sold out for this timeslot"
    soldOut: Boolean!
    "Timeslot start date and time in UTC"
    startAt: String!
}

"Event category"
type Category {
    id: ID!
    key: CategoryKey!
    "The name of the category in English"
    name: String!
}

type CommissionCode {
    brokerFee: Float!
    code: String!
    country: CountryCode
    currency: CurrencyCode!
    flat: Float
    id: ID!
    max: Float
    percent: Float
}

type CostBreakdownItem {
    amount: Float
    description: String
    "The settlement cost breakdown"
    settlement: CostBreakdownItem
    "The transactional cost breakdown"
    transactional: CostBreakdownItem
}

type CostItemBreakdownFee {
    amount: Float
    description: String
    flat: Float
    percent: Float
    "The settlement cost breakdown"
    settlement: CostItemBreakdownFee
    src_flat: Float
    "The transactional cost breakdown"
    transactional: CostItemBreakdownFee
}

type CostItemBreakdownTax {
    amount: Float
    description: String
    percent: Float
    "The settlement cost breakdown"
    settlement: CostItemBreakdownTax
    taxId: String
    "The transactional cost breakdown"
    transactional: CostItemBreakdownTax
}

type Country {
    code: CountryCode!
    continent: Continent!
    currency: CurrencyCode!
    geonameId: String!
    id: ID!
    name: String!
    universeAvailable: Boolean!
}

"Account level custom report"
type CustomReport {
    _id: ID! @deprecated(reason: "Prefer camelCase to snake case. Please use the id field instead")
    columns: [String!]!
    createdAt: String!
    created_at: String! @deprecated(reason: "Prefer camelCase to snake case. Please use the createdAt field instead")
    "Currency parameter for filtering events in event select modal"
    currencyFilter: String
    "The day of the week when the scheduler should send report on."
    days: [Days]
    description: String
    "Whether the scheduler is enabled or not"
    enabled: Boolean
    "Custom date range parameter (from) for filtering events in event select modal"
    eventRangeFrom: String
    "Custom date range parameter (to) for filtering events in event select modal"
    eventRangeTo: String
    events: [String!]
    filters: [JSON!]
    "The starting date of the scheduler"
    from: Date
    "The speicific hour of the day when the report should be sent. Value must be between 0 and 23"
    hour: Int
    id: ID!
    name: String!
    "The ordering column and direction of order prior to exporting to a CSV/XLS file. Value must be in '{COLUMN} {DIRECTION}' format"
    order: String
    reportType: String!
    report_type: String! @deprecated(reason: "Prefer camelCase to snake case. Please use the reportType field instead")
    "Time parameter for filtering events in event select modal"
    timeFilter: String
    "The ending date of the scheduler"
    to: Date
    updatedAt: String!
    updated_at: String! @deprecated(reason: "Prefer camelCase to snake case. Please use the updatedAt field instead")
}

type CustomReportConnection {
    nodes(limit: Int = 10, offset: Int = 0): [CustomReport!]!
    pagination: JSON
    totalCount: Int!
}

"Autogenerated return type of CustomReportCreate"
type CustomReportCreatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    custom_report: CustomReport
    errors: [String!]
}

"Autogenerated return type of CustomReportDelete"
type CustomReportDeletePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    custom_report: CustomReport
    errors: [String!]
}

"Autogenerated return type of CustomReportUpdate"
type CustomReportUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    custom_report: CustomReport
    errors: [String!]
}

"Date objects for the Customize Tickets calendar"
type CustomizeTicketsDate {
    "Calendar timeslots for the tickets customization page"
    calendarTimeslotIds: [ID]!
    "date"
    date: String
}

"Timeslot objects for the Customize Tickets tab"
type CustomizeTicketsTimeslot {
    "Timeslot end date and time"
    endAt: String!
    id: ID!
    rateIds: [ID]!
    "Timeslot start date and time"
    startAt: String!
}

"Sales per specific day"
type DailySales {
    "Day"
    day: Date!
    "Sales"
    salesAmount: Float!
}

"Discounts allow Buyers to redeem a discount on their purchase"
type Discount {
    "The literal value a Buyer needs to provide to redeem the discount"
    code: String!
    "In UTC"
    createdAt: Time!
    "The event to which the discount code is restricted, if applicable"
    event: Event
    "The redemption value of the Discount - as a fixed amount"
    fixed: Float
    id: ID!
    "The redemption value of the Discount - as a percent (represented in the range 0..1)"
    percent: Float
    "The total number of Order Items that a Discount can be applied to"
    quantity: Int
    "The rates to which the discount code is restricted, if applicable"
    rates: [Rate]
    "The type of redemption value, dictates which field the redemption value should be read from (either `percent` or `fixed`)"
    redemptionType: DiscountRedemptionType!
    "Redemption objects for this Discount"
    redemptions: DiscountRedemptionConnection!
    "The total number of possible uses remaining"
    remaining: Int
    state: DiscountState!
    "In UTC"
    updatedAt: Time!
}

type DiscountConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Discount!]!
    pagination: JSON
    totalCount: Int!
}

"Autogenerated return type of DiscountCreate"
type DiscountCreatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    discount: Discount
    errors: [String!]
}

"Autogenerated return type of DiscountDelete"
type DiscountDeletePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    discount: Discount
    errors: [String!]
}

"Discount Redemptions represent unique uses of a Discount on an Order Item"
type DiscountRedemption {
    discount: Discount!
    id: ID!
    orderItem: OrderItem!
}

type DiscountRedemptionConnection {
    nodes(limit: Int = 10, offset: Int = 0): [DiscountRedemption!]!
    pagination: JSON
    totalCount: Int!
}

"Autogenerated return type of DiscountsCreate"
type DiscountsCreatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    discounts: [Discount!]
    errors: [String!]
}

"Autogenerated return type of DiscountsUpdate"
type DiscountsUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    discounts: [Discount]!
    errors: [[Error!]]!
}

"Error message with the corresponding key it belongs to"
type Error {
    key: String!
    message: String!
}

"The root-level inventory object. Events are entitites for which tickets can be sold. Events support multiple dates/times for which tickets can be sold separately as TimeSlots. In previous APIs, Universe has referred to this as a Listing."
type Event implements BaseEvent {
    "Access Keys created for this Event"
    accessKeys: AccessKeyConnection
    "Event has sold tickets for timeslots in the future"
    active: Boolean!
    "Add-on sales by day"
    addOnSalesByDay(from: Date!, to: Date!): [DailySales!]!
    addOns: [AddOn]!
    "Optional additional images for the event (promotional photos, venue photos)"
    additionalImages: [Image!]!
    "Street-level address"
    address: String!
    "All future or ongoing TimeSlots for which tickets can be purchased"
    allAvailableTimeSlots: [TimeSlot]!
    "All Additional Images"
    allImages: [Image!]!
    "All dates/times for which tickets can be purchased sorted chronologically. Each Event can define one or many TimeSlots"
    allTimeSlots: [TimeSlot]!
    "Whether to enable waitlist for the Event"
    allowWaitlist: Boolean!
    "A list of all attendees for the Event, includes tickets from all states, including invalid."
    attendees(after: Time, before: Time, externalMetadata: String, match: String, state: OrderItemState, timeSlotIds: [ID!]): AttendeeConnection!
    "A list of countries in which tickets to this event may be purchased"
    availableCountries: [CountryCode]!
    "Future or ongoing TimeSlots for which tickets can be purchased"
    availableTimeSlots: TimeSlotConnection!
    "Total event capacity of the event"
    capacity: Int
    "Whether to show an alert that the Event is almost sold out"
    capacityAlert: Boolean
    "The category assigned for this Event"
    category: Category
    "Seats chart information regarding if the listing's chart is in a DRAFT state and if its events have yet been linked"
    chartStatus: JSON
    "Name of the city"
    cityName: String
    "Optional field that the host sets for additional contact information"
    contactDetails: String
    "The country code"
    countryCode: String
    "Cover photo for the event (min 100x100px, max 2MB). Auto-generated if no initial entry."
    coverPhoto: Image!
    "In UTC"
    createdAt: Time!
    "The currency specified by Host"
    currency: CurrencyCode!
    "A detailed description of the event"
    description(format: ContentFormat = TEXT): String!
    "Discounts created for this Event"
    discounts: DiscountConnection
    "Event photo for the event (min 1110x444px, max 5MB). Auto-generated if no initial entry."
    eventPhoto: Image!
    "The number of future time slots"
    futureTimeSlotCount: Int!
    "Total sales amount for future timeslots only (returns null if no future timeslots)"
    futureTimeslotsSalesAmount: Money
    "Total tickets sold for upcoming timeslots only (returns null if no future timeslots)"
    futureTimeslotsTicketsSold: Int
    "The ticket purchase button text"
    getTicketsText: String!
    "the 'send_to' field for a GoogleAds conversion to be tracked. Has the form: AW-123456789/AbC-D_efG-h12_34-567"
    googleAdsSendTos: GoogleAdsSendTos
    "Whether the Event is sells Passes"
    hasPasses: Boolean!
    "Whether the Event uses reserved seating"
    hasSeats: Boolean!
    "A user-configurable setting determining whether the TimeSlot of the Event should be disclosed to the Buyer"
    hiddenDate: Boolean!
    "Whether to show or hide this Event from our Calendar / Listings widgets."
    hideFromWidgets: Boolean
    host: Host!
    id: ID!
    "A URL to the event image. Custom height and width can be supplied"
    imageUrl(
        "Height of the image"
        height: Int = 160,
        "Width of the image"
        width: Int = 160
    ): String
    "Other Images"
    images: ImageConnection!
    "Date that the event was last updated"
    lastUpdated: Date!
    latitude: Float!
    longitude: Float!
    "Maximum Price of an event. If provided, indicates a range"
    maxPrice: Float
    "Maximum number of items which are sellable for Event.The value depends on Rates' maxQuantity."
    maxQuantity: Int
    "Minimum Price of an event"
    minPrice: Float
    "The next active time slot of future time slots"
    nextFutureTimeSlot: TimeSlot
    "Orders created for this Event"
    orders(match: String, paymentMethod: PaymentMethod, state: OrderState, states: [OrderState], timeSlotIds: [ID!], updatedSince: Date): OrderConnection
    "Whether payment plans are disabled for this listing"
    paymentPlanDisabled: Boolean!
    paymentSettings: PaymentSettings!
    "The privacy setting for the Event"
    privacy: EventPrivacy!
    "Content that will be provided to buyer's only"
    privateNote(format: ContentFormat = TEXT): String
    "When the draft event is scheduled to be published (not set if not scheduled)"
    publishLaterAt: Time
    "Listing questions on checkout"
    questions: [Question]!
    rateStateExists: RateStateExists!
    "Product types (Tickets or Passes) that can be sold for this Event"
    rates(clientGroups: [RateClientGroup!], states: [RateState!]): RateConnection!
    "Whether the Event uses rebates"
    rebates: Boolean!
    "Time (in seconds) setting how long refunds are available for - pairs with refundOffsetType"
    refundOffset: Int!
    "Refund will be available either within refundOffset units of purchase or until refundOffset units before the event"
    refundOffsetType: String!
    "Describes a policy on ticket refunds"
    refundPolicy: RefundPolicy
    "Region where the event is being hosted"
    region: String
    report(
        "array of {key: value} or 'string' where clauses"
        clauses: [JSON] = [],
        "columns to return"
        columns: [String] = [],
        "type of report"
        name: String = "AttendeesReport"
    ): Report!
    "Total sales amount for this Event"
    salesAmount: Money
    "Sales by day"
    salesByDay(from: Date!, to: Date!): [DailySales!]!
    "Whether the Event Saved by the Viewer"
    saved: Boolean!
    "List of all Savers who saved the Event"
    savers: SaversConnection
    "The schedules assigned to this Event"
    schedules: ScheduleConnection
    "Whether the Seats.io chart has been published for its first time"
    seatingMapPublished: Boolean!
    "The seats chart key from Seats.io"
    seatsChartKey: String
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String!
    "A parameterized version of slug used for URI construction"
    slugParam: String!
    "Whether the Social Buttons will be active on unlisted events"
    socialButtons: Boolean!
    "Tickets are sold out for this Event"
    soldOut: Boolean!
    "The Event state"
    state: EventState!
    "The tags added to this Event"
    tags: [Tag]!
    "Ticket sales by day"
    ticketSalesByDay(from: Date!, to: Date!): [DailySales!]!
    "Total tickets sold for this Event"
    ticketsSold: Int
    timeSlotReport: TimeSlotReport!
    "A date/time for which tickets can be purchased sorted chronologically. Each Event can define one or many TimeSlots"
    timeSlots(
        "End time of event after beginning of day"
        endTimeAfter: Date,
        "End time of event before end of day"
        endTimeBefore: Date,
        ids: [String!] = [],
        "Start time of event after beginning of day"
        startTimeAfter: Date,
        "Start time of event before end of day"
        startTimeBefore: Date
    ): TimeSlotConnection!
    "Determines whether or not an event admits visitors to an event between a set time"
    timedEntry: Boolean!
    "Timezone of the event location"
    timezone: String!
    "A brief description"
    title: String!
    "Currency that is displayed and charged in"
    transactionCurrency: CurrencyCode!
    "The total number of tickets which are sellable for upcoming TimeslotsThe value is the lowest of the upcoming Rates maxQuantity and upcoming Timeslots capacities"
    upcomingTotalCapacity: Int
    "In UTC"
    updatedAt: Time!
    "Event URL"
    url: String!
    "Event or EventSet creator"
    user: Profile!
    "Name of the venue"
    venueName: String
    "Is the event virtual?"
    virtual: Boolean!
    "Virtual connection info"
    virtualInfo: String!
}

type EventConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Event!]!
    pagination: JSON
    totalCount: Int!
}

"Autogenerated return type of EventCreate"
type EventCreatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Autogenerated return type of EventDelete"
type EventDeletePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Autogenerated return type of EventDuplicate"
type EventDuplicatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Autogenerated return type of EventPublish"
type EventPublishPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Autogenerated return type of EventReport"
type EventReportPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    event: Event
}

"Autogenerated return type of EventSave"
type EventSavePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    event: Event
}

"Set of Events"
type EventSet implements BaseEvent {
    "Street-level address"
    address: String!
    "All Events in the EventSet"
    allEvents: [Event]!
    "All Additional Images"
    allImages: [Image!]!
    "EventSet calendar fields"
    calendar: Calendar!
    "Cover Photo"
    coverPhoto: Image!
    "In UTC"
    createdAt: Time!
    "A detailed description of the event"
    description(format: ContentFormat = TEXT): String!
    "Detailed description with html"
    descriptionHtml: String! @deprecated(reason: "Deprecated in favor of description field with argument[:format] equal to 'html'")
    "Events in the EventSet"
    events: EventConnection!
    "Hidden Date"
    hiddenDate: Boolean
    id: ID!
    "Other Images"
    images: ImageConnection!
    latitude: Float!
    longitude: Float!
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String!
    "A brief description"
    title: String!
    "In UTC"
    updatedAt: Time!
    "Event or EventSet creator"
    user: Profile!
    "Name of the venue"
    venueName: String
}

"Autogenerated return type of EventSetReport"
type EventSetReportPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    eventSet: EventSet
}

"Autogenerated return type of EventUnpublish"
type EventUnpublishPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Autogenerated return type of EventUpdate"
type EventUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Autogenerated return type of ExternalMetadataUpdate"
type ExternalMetadataUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String]
    orderItem: OrderItem
}

"The conversion tracking labels a host as set for their Event"
type GoogleAdsSendTos {
    "the send_to field to fire on checkout modal is loaded"
    checkout: [String]!
    "the send_to field to fire on an event pageview"
    pageview: [String]!
    "the send_to field to fire on an event purhcase"
    purchase: [String]!
}

"A user who is selling tickets to Events on Universe"
type Host implements User {
    "Add on order items"
    addOnOrderItems(
        "Only returns add on order items for this state"
        checkInState: CheckInState,
        "Only returns add on order items after this date."
        from: Date,
        page: Int = 1,
        perPage: Int = 10,
        "Search query for add on order items"
        search: String,
        states: [OrderItemState!]
    ): OrderItemConnection
    "Account level rates that belong to this host."
    addOns(
        currency: CurrencyCode,
        listingId: ID,
        "state of add-ons to return"
        state: String
    ): AddOnConnection!
    admin: Boolean!
    "Analytics data for this host (have to be the host or have membership to the host's organization)"
    analytics: Analytics!
    "A list of all attendees for all Events and all TimeSlots for which this host has sold tickets on Universe. Includes tickets from all states, including invalid."
    attendees: AttendeeConnection!
    "The avatar URL, 160x160 pixels"
    avatarUrl: String
    "The user has configured their account as a business - does not have a last name"
    business: Boolean!
    "The Business Seller address for businesses in the EU"
    businessAddress: String
    "The Business Seller Email for businesses in the EU"
    businessEmail: String
    "The Business Seller Phone Number for businesses in the EU"
    businessPhoneNumber: String
    "The Commission Codes (pricing details) the host is set to for any currency/countries they have sold tickets for - does not include any event or rate specific custom overrides"
    commissionCodes: [CommissionCode!]!
    "the settlement currencies of the host (have to be the host or have membership to the host's organization)"
    currencies: [CurrencyCode!]!
    "An account level custom report belonging to this host"
    customReport(id: ID!): CustomReport!
    "All account level custom reports created by this host"
    customReports(
        "Search query for custom reports"
        search: String
    ): CustomReportConnection!
    "A list of dates with future / ongoing events"
    datesCalendar: [Date!]!
    "A user-defined description"
    description: String
    "Account level discounts that belong to this host. Sorted by state (ascending), then code name"
    discounts(search: String): DiscountConnection!
    "Returns calculated all in pricing for a single rate"
    displayPrice(country: String!, price: Float!, rateId: ID, settlementCurrency: String!): Float
    "The settlement currencies used on events by the host"
    eventCurrencies: [CurrencyCode!]!
    "All Events by this host (have to be the host or have membership to the host's organization)"
    events(currency: CurrencyCode, search: String, slugs: [String!], states: [EventState!]): EventConnection!
    "All Events (events that have sales) by this host (sorted by live Events (ascending order), then expired / archived events  (have to be the host or have membership to the host's organization)."
    eventsWithTickets(
        currency: CurrencyCode,
        "Include events that have free ticket sales"
        free: Boolean,
        "Only return Events within the specified time frame"
        from: Date,
        "Include events that have sales (not free tickets)"
        paid: Boolean,
        "Only return Events within the specified time frame"
        to: Date
    ): EventConnection!
    "All non-hidden Events within the given range that were hosted by this user."
    eventsWithTicketsInRange(
        currency: CurrencyCode,
        "Only return Events within the specified time frame"
        from: Date,
        "Only return Events within the specified time frame"
        to: Date
    ): EventConnection!
    "The first name of the type implementing a User interface"
    firstName: String
    "Whether the host can choose to pass on Universe service fees to the buyer."
    forceHostToPayCommission: Boolean
    "Google Analytics Ecommerce"
    googleAnalyticsEcommerce: Boolean
    "Google Analytics Id"
    googleAnalyticsId: String
    hasLiveEvents: Boolean
    "Events hosted by this host with past Time Slots sorted by their most recently ended timeslot endAt, unique by Event (have to be the host or have membership to the host's organization)"
    hosted(state: EventState): EventConnection!
    "Events hosted by this host with future Time Slots (have to be the host or have membership to the host's organization)"
    hosting(addOnId: ID, currency: CurrencyCode, slugs: [String!], states: [EventState!], transactionalCurrency: CurrencyCode): EventConnection!
    id: ID
    "The last name of the type implementing a User interface"
    lastName: String
    "User locale"
    locale: Locale
    "A single field concatenating firstName and lastName"
    name: String
    "Orders created for inventory owned by this host"
    orders: OrderConnection
    organization: Organization!
    "Whether the organization has rebate functionality enabled."
    rebates: Boolean
    "All events for this host ordered by the most recently updated"
    recentlyUpdatedEvents(states: [EventState!]): EventConnection!
    report(
        "array of {key: value} or 'string' where clauses"
        clauses: [JSON] = [],
        "columns to return"
        columns: [String] = [],
        "type of report"
        name: String = "AttendeesReport"
    ): Report!
    "The type of the viewer account (Admin, User, Spammer, etc)"
    role: UserRole!
    "The seats designer key from Seats.io. Used to embed the seats.io floor plan designer."
    seatsDesignerKey: String
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String
    "The avatar URL, 50x50 pixels"
    smallAvatarUrl: String
    "Events hosted by this host with Time Slots sorted by their starting timeslot startAt"
    sortedEvents(states: [EventState!]): EventConnection!
    "Linked stripe connect accounts"
    stripeConnectAccounts: [StripeConnectAccount]!
    superAdmin: Boolean!
    "Taxes created by this host"
    taxes: TaxConnection
    "A list of ongoing / future TimeSlots, sorted by startAt, unique by startDate and Event."
    timeSlotsCalendar(
        "Supply an ISO8601-formatted date string to filter time slots by date"
        date: Date
    ): TimeSlotConnection!
    "The transactional currencies used on events by the host"
    transactionalCurrencies: [CurrencyCode!]!
}

"Autogenerated return type of HostGaIntegrationUpdate"
type HostGaIntegrationUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    host: Host
}

"Image for events, avatars, and add on options"
type Image {
    cropHeight: Int
    cropWidth: Int
    cropX: Int
    cropY: Int
    isGif: Boolean
    uploadId: String!
    "Image URL. Custom height and width can be supplied"
    url(
        "Blur images by the strength factor. Default: '500'"
        blur: Int,
        "Resize or crop the image."
        cropMode: ImageCropMode = SCALE_CROP,
        "Convert an image to one of the supported output formats"
        format: ImageFormat,
        "Height of the image"
        height: Int = 160,
        "Adjust image quality. Default: 'NORMAL'"
        quality: ImageQuality,
        "Width of the image"
        width: Int = 160
    ): String!
}

type ImageConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Image!]!
    pagination: JSON
    totalCount: Int!
}

"The invoice for an order"
type Invoice {
    address1: String
    address2: String
    city: String
    company: String
    country: String
    fullName: String
    id: ID!
    number: Int
    state: String
    zip: String
}

"Autogenerated return type of LocaleChange"
type LocaleChangePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [Error!]!
    viewer: Viewer
}

type Location {
    "City name"
    city: String!
    "Country name"
    country: String!
}

"Serves the Event Information Basics tab on the Manage Panel"
type ManageBasics {
    address: String!
    categoryId: String!
    country: Country
    description: String!
    id: ID!
    latitude: Float!
    longitude: Float!
    privacy: String!
    "The timeSlots assigned to this Event"
    timeSlots: [ManageWhenTimeslot!]!
    timedEntry: Boolean!
    title: String!
    "Timezone of the event location"
    tz: String!
    venueName: String
}

"Serves the Event Information Customize tab on the Manage Panel"
type ManageCustomize {
    "Optional additional images for the event (promotional photos, venue photos)"
    additionalImages: [Image!]!
    "Optional field that the host sets for additional contact information"
    contactDetails: String
    "Cover photo for the event (min 100x100px, max 2MB). Auto-generated if no initial entry."
    coverPhoto: Image!
    "Event photo for the event (min 1110x444px, max 5MB). Auto-generated if no initial entry."
    eventPhoto: Image!
    id: ID!
    "Content that will be provided to buyer's only"
    privateNote: String
}

"Serves the Customize Tickets tab on the Event Manage Panel"
type ManageCustomizeTickets {
    "Date objects for the ticket customization calendar"
    calendarDates: [CustomizeTicketsDate!]!
    "Capacity of the listing"
    capacity: Int
    "First available month"
    firstMonthWithEvents: String!
    "ID of the listing"
    id: ID!
    "Last available month"
    lastMonthWithEvents: String!
    "Customized values for Ticket Type - Timeslot pairs"
    rateCustomizations: [RateCustomization!]!
    "Ticket types in original state for all timeslots"
    rates: [Rate!]!
    "All timeslots for the listing"
    timeslots: [CustomizeTicketsTimeslot!]!
    "Timezone of the event location"
    timezone: String!
}

"Serves the Event Information Tickets tab on the Manage Panel"
type ManageTickets {
    "The currency the host receives funds in"
    baseCurrency: String!
    "Capacity number for the event"
    capacity: Int
    "Flag to show a warning to the fan when capacity is close to reaching capacity"
    capacityAlert: Boolean!
    country: Country
    hostId: ID!
    id: ID!
    rates: [ManageTicketsRate!]!
    refundOffset: RefundOffset!
    refundOffsetType: RefundOffsetType!
    "The currency the buyer must purchase in"
    srcCurrency: String!
    "The timeSlots assigned to this Event"
    timeSlots: [ManageWhenTimeslot!]!
    "Determines whether or not an event admits visitors to an event between a set time"
    timedEntry: Boolean!
    "Timezone of the event location"
    timezone: String!
    "Determines whether or not an event is virtual"
    virtual: Boolean!
}

type ManageTicketsRate {
    "The default access key for a given locked rate"
    accessKey: String
    "Optional number for the ticket capacity on this rate - default is unlimited"
    capacity: Int
    clientGroup: RateClientGroup
    "Description for the rate"
    description: String
    displayPrice: Float
    "UNIX Timestamp"
    endStamp: Int
    "List of rules that exclude a rate from displaying against given timeslot(s)"
    exclusionRules: [JSON!]
    id: ID!
    "Optional number for the maximum amount of tickets to be sold on this rate"
    maxTickets: Int
    "The minimum price of this type of ticket, used only in PWYW/donation tickets"
    minPrice: Float!
    "Optional number for the minimum amount of tickets to be sold on this rate"
    minTickets: Int
    "Name for the rate"
    name: String!
    "The price of this type of ticket - 0.0 if free"
    price: Float!
    "Seconds before event to release the tickets"
    releaseOffset: Int
    "The currency the buyer must purchase the rate in"
    srcCurrency: String!
    "UNIX Timestamp"
    startStamp: Int
    state: RateState!
    type: RateType!
    "If rate has sold order items"
    used: Boolean!
}

"Serves the Event Information When (Regular Entry) tab on the Manage Panel"
type ManageWhenRegularEntry {
    address: String!
    country: Country
    hiddenDate: Boolean!
    id: ID!
    latitude: Float!
    longitude: Float!
    "The timeSlots assigned to this Event"
    timeSlots: [ManageWhenTimeslot!]!
    "Timezone of the event location"
    tz: String!
    venueName: String
    "Determines whether or not an event is virtual"
    virtual: Boolean!
    "Virtual connection info"
    virtualInfo: String
}

"Serves the Event Information When (Timed Entry) tab on the Manage Panel"
type ManageWhenTimedEntry {
    id: ID!
    "The schedules assigned to this Event"
    schedules: [Schedule!]!
    "The timeSlots assigned to this Event"
    timeSlots: [ManageWhenTimeslot!]!
    "Timezone of the event location"
    timezone: String!
    "Determines whether or not an event is virtual"
    virtual: Boolean!
}

type ManageWhenTimeslot {
    "Timeslot end date and time in the timezone of the event"
    endAt: TimeWithoutTz!
    id: ID!
    "Whether the timeslot can be modified or not"
    readOnly: Boolean!
    "Timeslot start date and time in the timezone of the event"
    startAt: TimeWithoutTz!
}

"Autogenerated return type of MarkInvoiceAsPaid"
type MarkInvoiceAsPaidPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    order: Order!
}

"Memberships are the groups that the user is a part of through different accessibility / permission levels"
type Membership {
    "Check if the membership applies to all listings"
    allEvents: Boolean!
    "Listings that the membership applies to"
    eventIds: String
    id: ID!
    "The owner of the group in which the user has membership"
    owner: Host!
    "Check the membership against a specific permission type"
    permission(for: Permission!): Boolean!
    "Check the membership against some or all of a list of permission types"
    permissions(
        "Check whether any of the permission types apply to the membership"
        any: Boolean = false,
        for: [Permission!]!
    ): Boolean!
}

type MembershipConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Membership!]!
    pagination: JSON
    totalCount: Int!
}

"Monetary amounts (includes a currency and sales $)"
type Money {
    "The currency of the money"
    currency: CurrencyCode!
    "The exponent of the currency, the number of digits used after the decimal place"
    exponent: Int!
    "Monetary amount returned as an integer in the lowest denomination (cents) to reduce floating point errors"
    monetaryAmount: Int!
}

type Mutation {
    "Accept Transfer"
    acceptTransfer(input: TransferAcceptInput!): TransferAcceptPayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `transferAccept`")
    "Create AddOn"
    addOnCreate(input: AddOnCreateInput!): AddOnCreatePayload
    "Delete AddOn"
    addOnDelete(input: AddOnDeleteInput!): AddOnDeletePayload
    "Update Addon"
    addOnUpdate(input: AddOnUpdateInput!): AddOnUpdatePayload
    "Message event attendees"
    attendeesMessage(input: AttendeesMessageInput!): AttendeesMessagePayload
    "Update the time slot for orders"
    bulkOrderTimeSlotUpdate(input: BulkOrderTimeSlotUpdateInput!): BulkOrderTimeSlotUpdatePayload
    "Create AddOn"
    createAddOn(input: AddOnCreateInput!): AddOnCreatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `addOnCreate`")
    "Create Custom Report"
    createCustomReport(input: CustomReportCreateInput!): CustomReportCreatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `customReportCreate`")
    "Create Event"
    createEvent(input: EventCreateInput!): EventCreatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventCreate`")
    "Create Tax"
    createTax(input: TaxCreateInput!): TaxCreatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `taxCreate`")
    "Create Custom Report"
    customReportCreate(input: CustomReportCreateInput!): CustomReportCreatePayload
    "Delete Custom Report"
    customReportDelete(input: CustomReportDeleteInput!): CustomReportDeletePayload
    "Update Custom Report"
    customReportUpdate(input: CustomReportUpdateInput!): CustomReportUpdatePayload
    "Decline Transfer"
    declineTransfer(input: TransferDeclineInput!): TransferDeclinePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `transferDecline`")
    "Delete AddOn"
    deleteAddOn(input: AddOnDeleteInput!): AddOnDeletePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `addOnDelete`")
    "Delete Custom Report"
    deleteCustomReport(input: CustomReportDeleteInput!): CustomReportDeletePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `customReportDelete`")
    "Delete Event"
    deleteEvent(input: EventDeleteInput!): EventDeletePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventDelete`")
    "Create Discount belonging to this user"
    discountCreate(input: DiscountCreateInput!): DiscountCreatePayload
    "Delete Discount"
    discountDelete(input: DiscountDeleteInput!): DiscountDeletePayload
    "Bulk create account level discount codes"
    discountsCreate(input: DiscountsCreateInput!): DiscountsCreatePayload
    "Update many Discounts at once"
    discountsUpdate(input: DiscountsUpdateInput!): DiscountsUpdatePayload
    "Duplicate Event"
    duplicateEvent(input: EventDuplicateInput!): EventDuplicatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventDuplicate`")
    "Create Event"
    eventCreate(input: EventCreateInput!): EventCreatePayload
    "Delete Event"
    eventDelete(input: EventDeleteInput!): EventDeletePayload
    "Duplicate Event"
    eventDuplicate(input: EventDuplicateInput!): EventDuplicatePayload
    "Publish Event"
    eventPublish(input: EventPublishInput!): EventPublishPayload
    "Report Event"
    eventReport(input: EventReportInput!): EventReportPayload
    "Save Event"
    eventSave(input: EventSaveInput!): EventSavePayload
    "Report Event Set"
    eventSetReport(input: EventSetReportInput!): EventSetReportPayload
    "Unpublish Event"
    eventUnpublish(input: EventUnpublishInput!): EventUnpublishPayload
    "Update Event"
    eventUpdate(input: EventUpdateInput!): EventUpdatePayload
    "Update host google analytics integration"
    hostGaIntegrationUpdate(input: HostGaIntegrationUpdateInput!): HostGaIntegrationUpdatePayload
    "Change locale for current Viewer"
    localeChange(input: LocaleChangeInput!): LocaleChangePayload
    "Approves a pending order"
    orderApprove(input: OrderApproveInput!): OrderApprovePayload
    "Change the buyer info for an order"
    orderBuyerInfoChange(input: OrderBuyerInfoChangeInput!): OrderBuyerInfoChangePayload
    "Declines a pending order"
    orderDecline(input: OrderDeclineInput!): OrderDeclinePayload
    "Change the attendee info for an order item"
    orderItemAttendeeInfoChange(input: OrderItemAttendeeInfoChangeInput!): OrderItemAttendeeInfoChangePayload
    "Check in an order item"
    orderItemCheckIn(input: OrderItemCheckInInput!): OrderItemCheckInPayload
    "Check out an order item"
    orderItemCheckOut(input: OrderItemCheckOutInput!): OrderItemCheckOutPayload
    "Update external metadata field on OrderItem"
    orderItemExternalMetadataUpdate(input: ExternalMetadataUpdateInput!): ExternalMetadataUpdatePayload
    "Resend email with order item details"
    orderItemResend(input: OrderItemResendInput!): OrderItemResendPayload
    "Marks an order that was purchased using an invoice as 'Paid'"
    orderMarkInvoiceAsPaid(input: MarkInvoiceAsPaidInput!): MarkInvoiceAsPaidPayload
    "Refund order items"
    orderRefund(input: OrderRefundInput!): OrderRefundPayload
    "Resend email with order details"
    orderResend(input: OrderResendInput!): OrderResendPayload
    "Update the time slot for an order"
    orderTimeSlotUpdate(input: OrderTimeSlotUpdateInput!): OrderTimeSlotUpdatePayload
    "Upgrade order items"
    orderUpgrade(input: OrderUpgradeInput!): OrderUpgradePayload
    "Publish Event"
    publishEvent(input: EventPublishInput!): EventPublishPayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventPublish`")
    "Create a ticket"
    rateCreate(input: RateCreateInput!): RateCreatePayload
    "Update a single rate"
    rateUpdate(input: RateUpdateInput!): RateUpdatePayload
    "Update multiple rates"
    ratesUpdate(input: RatesUpdateInput!): RatesUpdatePayload
    "Save Event"
    saveEvent(input: EventSaveInput!): EventSavePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `eventSave`")
    "Makes API call to Seats.io to publish a seating map"
    seatsPublishDraft(input: SeatsPublishDraftInput!): SeatsPublishDraftPayload
    "Synchronize rates with seats chart for reserved seated events"
    seatsSyncRates(input: SeatsSyncRatesInput!): SeatsSyncRatesPayload
    "Create Tax"
    taxCreate(input: TaxCreateInput!): TaxCreatePayload
    "Add or update a timeslot ticket customization"
    timeSlotRateCustomization(input: TimeslotRateCustomizationInput!): TimeslotRateCustomizationPayload
    "Updates a TimeSlot"
    timeSlotUpdate(input: TimeSlotUpdateInput!): TimeSlotUpdatePayload
    "Accept Transfer"
    transferAccept(input: TransferAcceptInput!): TransferAcceptPayload
    "Decline Transfer"
    transferDecline(input: TransferDeclineInput!): TransferDeclinePayload
    "Update Addon"
    updateAddOn(input: AddOnUpdateInput!): AddOnUpdatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `addOnUpdate`")
    "Update Custom Report"
    updateCustomReport(input: CustomReportUpdateInput!): CustomReportUpdatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `customReportUpdate`")
    "Update a single rate"
    updateRate(input: RateUpdateInput!): RateUpdatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `rateUpdate`")
    "Update multiple rates"
    updateRates(input: RatesUpdateInput!): RatesUpdatePayload @deprecated(reason: "Mutations should conform to the `subjectAction` format, please use `ratesUpdate`")
}

"A transaction made by a Buyer for Order Items (frequently, but not exclusively, tickets for an Event)"
type Order {
    "The access keys used for this Order"
    accessKeys: [AccessKey]
    "Add Ons in the order"
    addOnItems: OrderItemConnection!
    "Buyer's answers to checkout question, on the level of the Order itself"
    answers: [Answer]!
    "The Buyer who created the Order"
    buyer: Buyer!
    "Whether this order is in a confirmed state"
    confirmed: Boolean
    "Cost breakdown for the Order"
    costBreakdown: OrderCostBreakdown!
    "In UTC"
    createdAt: Time!
    "Whether there are questions or answers on this order that can be edited"
    editable: Boolean
    "Each Order has one Event - the event the tickets are for"
    event: Event!
    historical: Boolean
    "The Host of the Event the tickets on the Order are for"
    host: Host!
    hostPurchased: Boolean!
    id: ID!
    "The invoice for an order"
    invoice: Invoice
    "Number of accepted transfers for this order"
    numberOfAcceptedTransfers: Int
    "Items in the order"
    orderItems(externalMetadata: String): OrderItemConnection!
    "Where the Buyer purchased the order from"
    origin: String
    paymentDeclineCode: PaymentDeclineCode
    "A private note created by the Host of the Event, made available to Buyers. Often contains information important to the Buyer."
    privateNote: String
    providerSourceClient: String
    providerSourceType: ProviderSourceType
    "Collection of rate ids for the order items in this order"
    rateIds: [ID!]
    "If the Buyer clicked a link containing a `ref` parameter, this string will return the same value. You can use this to track purchases from specific links."
    ref: String
    "Gets a refund estimate on this order"
    refundEstimate(orderItemRefundDatas: [OrderItemRefundData]!): Float
    state: OrderState!
    "The TimeSlot the tickets on the Order are for"
    timeSlot: TimeSlot!
    "In UTC"
    updatedAt: Time!
    "Whether an order item on this order can be upgraded"
    upgradeable: Boolean
    "Whether the order was purchased using Klarna"
    usedKlarna: Boolean
    "Whether the order was purchased using a payment plan"
    usedPaymentPlan: Boolean
    "Whether an order item on this order can be voided"
    voidable: Boolean
}

"Autogenerated return type of OrderApprove"
type OrderApprovePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    order: Order
}

"Autogenerated return type of OrderBuyerInfoChange"
type OrderBuyerInfoChangePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    order: Order
}

type OrderConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Order!]!
    pagination: JSON
    totalCount: Int!
}

"An order cost breakdown by default, the transactional cost breakdown"
type OrderCostBreakdown {
    "The total commission paid for this Order"
    commission: Float
    "The total commission included paid for this Order"
    commissionIncluded: Float
    "The currency used either for transactions or for settlement"
    currency: CurrencyCode!
    "The total discount for this Order"
    discount: Float
    "The total fees paid for this Order"
    fee: Float
    "The fees paid for this Order"
    fees: [CostBreakdownItem!]
    "The total fulfillment paid for this Order"
    fulfillment: Float
    "The total payment for this Order"
    payment: Float
    "The date the payment was made at for this Order"
    paymentMadeAt: String!
    "The plan fees paid for this Order"
    planFee: Float
    "The price paid for this Order"
    price: Float
    "The settlement cost breakdown"
    settlement: OrderCostBreakdown
    "The subtotal paid for this Order"
    subtotal: Float
    "The taxes paid for this Order"
    taxes: [CostBreakdownItem!]
    "The total taxes paid for this Order"
    taxesTotal: Float
    "The transactional cost breakdown"
    transactional: OrderCostBreakdown
    "The total commission voided for this Order"
    voidedCommission: Float
    "The total commission included voided for this Order"
    voidedCommissionIncluded: Float
    "The total discount voided for this Order"
    voidedDiscount: Float
    "The total fees voided for this Order"
    voidedFee: Float
    "The fees that were voided on this Order"
    voidedFees: [CostBreakdownItem!]
    "The total payment voided for this Order"
    voidedPayment: Float
    "The date the payment was voided at"
    voidedPaymentAt: String!
    "The plan fees voided for this Order"
    voidedPlanFee: Float
    "The price voided for this Order"
    voidedPrice: Float
    "The subtotal voided for this Order"
    voidedSubtotal: Float
    "The taxes that were voided on this Order"
    voidedTaxes: [CostBreakdownItem!]
    "The total taxes voided for this Order"
    voidedTaxesTotal: Float
}

"An order item cost breakdown"
type OrderCostItemBreakdown {
    "The total commission paid for this Order"
    commission: Float
    "The total commission included paid for this Order"
    commissionIncluded: Float
    createdAt: String
    "The currency used either for transactions or for settlement"
    currency: CurrencyCode
    description: String
    "The total discount for this Order"
    discount: Float
    "The total fees paid for this Order"
    fee: Float
    fees: [CostItemBreakdownFee!]
    "The total fulfillment paid for this Order"
    fulfillment: Float
    id: String
    mongoId: String
    "The total payment for this Order"
    payment: Float
    "The plan fees paid for this Order"
    planFee: Float
    "The price paid for this Order"
    price: Float
    rateId: String
    "The settlement cost breakdown"
    settlement: OrderCostBreakdown
    "The subtotal paid for this Order"
    subtotal: Float
    taxes: [CostItemBreakdownTax!]
    "The total taxes paid for this Order"
    taxesTotal: Float
    "The transactional cost breakdown"
    transactional: OrderCostBreakdown
    "Has this Order Item been voided"
    voided: Boolean
    "The total commission voided for this Order"
    voidedCommission: Float
    "The total commission included voided for this Order"
    voidedCommissionIncluded: Float
    "The total discount voided for this Order"
    voidedDiscount: Float
    "The total fees voided for this Order"
    voidedFee: Float
    voidedFees: [CostItemBreakdownFee!]
    "The total payment voided for this Order"
    voidedPayment: Float
    "The plan fees voided for this Order"
    voidedPlanFee: Float
    "The price voided for this Order"
    voidedPrice: Float
    "The subtotal voided for this Order"
    voidedSubtotal: Float
    voidedTaxes: [CostItemBreakdownTax!]
    "The total taxes voided for this Order"
    voidedTaxesTotal: Float
}

"Autogenerated return type of OrderDecline"
type OrderDeclinePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    order: Order
}

"An item in the order"
type OrderItem {
    "The AddOn for this OrderItem, if the rate is an AddOnRate"
    addOn: AddOn
    amount: Float!
    "Buyer's answers to checkout questions on the OrderItem level (i.e. Ticket)"
    answers: [Answer]!
    "The person that owns this OrderItem, who is not always the primary buyer"
    buyer: Buyer!
    "Whether or not the OrderItem was scanned in"
    checkInState: CheckInState!
    "Whether this order item is in a confirmed state"
    confirmed: Boolean
    "Cost breakdown for the Order Item"
    costBreakdown: OrderCostItemBreakdown!
    "In UTC"
    createdAt: Time!
    "Partially refunded amount"
    discountPrice: Float
    "Redemption objects for any Discount applied during checkout"
    discountRedemption: DiscountRedemption
    "Whether there are questions or answers on this order item that can be edited"
    editable: Boolean
    "Custom attribute associated with this OrderItem, settable by the Host"
    externalMetadata: String
    "Users first name"
    firstName: String
    "Determines if the OrderItem has been fully refunded, meaning the entire monetary amount has been returned to the buyer"
    fullyRefunded: Boolean
    id: ID!
    "Users first name"
    lastName: String
    name: String!
    optionName: String
    "The parent transaction for this Order Item"
    order: Order!
    "The state the Order is in"
    orderState: OrderState!
    "Determines if the OrderItem has been partially refunded. Partially refunded meaning a partial monetary amount has been returned to the buyer"
    partiallyRefunded: Boolean
    "The person that paid for this OrderItem, but does not necessarily own it"
    primaryBuyer: Buyer!
    qrCode: String
    "The rate associated with this OrderItem"
    rate: Rate!
    "The label of the seat if the Event sells seats"
    seatLabel: String
    "The state the OrderItem is in"
    state: OrderItemState!
    "In UTC"
    updatedAt: Time!
    "Whether this order item can be upgraded"
    upgradeable: Boolean
    "Whether this order item can be voided"
    voidable: Boolean!
}

"Autogenerated return type of OrderItemAttendeeInfoChange"
type OrderItemAttendeeInfoChangePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String]
    orderItem: OrderItem
}

"Autogenerated return type of OrderItemCheckIn"
type OrderItemCheckInPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String]
    orderItem: OrderItem
}

"Autogenerated return type of OrderItemCheckOut"
type OrderItemCheckOutPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String]
    orderItem: OrderItem
}

type OrderItemConnection {
    nodes(limit: Int = 10, offset: Int = 0): [OrderItem!]!
    pagination: JSON
    totalCount: Int!
}

"Information about a user that owns an order item(s)"
type OrderItemOwner {
    email: String!
    name: String!
}

"Autogenerated return type of OrderItemResend"
type OrderItemResendPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    orderItem: OrderItem!
}

"Autogenerated return type of OrderRefund"
type OrderRefundPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    order: Order
}

"Autogenerated return type of OrderResend"
type OrderResendPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    order: Order!
}

"Autogenerated return type of OrderTimeSlotUpdate"
type OrderTimeSlotUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    order: Order
}

"Autogenerated return type of OrderUpgrade"
type OrderUpgradePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    order: Order
}

"the organization owned by a particular user"
type Organization {
    commissionCode: String!
    "In UTC"
    createdAt: Time!
    id: ID!
    name: String
    "In UTC"
    updatedAt: Time!
}

"Settings related to means of payment on an Event."
type PaymentSettings {
    "Payment methods available to pay for an Order."
    methodsAvailable: [PaymentMethod!]!
    "Payment methods available to pay for an Order."
    methodsEnabled: [PaymentMethod!]!
    "Sales can be performed where the Credit Card payment method only accepts specific card brands (i.e. an Amex only presale). If empty, there are no restrictions. Note that these brand restrictions will only be applied to the Credit Card payment method. If other payment methods are enabled on the Event, they will not be brand restricted."
    restrictedCardBrands: [CardBrand!]!
    "Security methods available to pay for an Order."
    securityMethodsAvailable: [PaymentMethod!]!
    "Security methods enabled to pay for an Order."
    securityMethodsEnabled: [PaymentMethod!]!
}

"A Profile for a Universe account - an interface into a User as a Host or Buyer"
type Profile implements User {
    admin: Boolean!
    "Public-visibility Events in the past associated with Orders purchased by this account"
    attended: EventConnection
    "Public-visiblity Events in the future associated with Orders purchased by this account"
    attending: EventConnection
    "The avatar URL, 160x160 pixels"
    avatarUrl: String
    "The Profile is for a user who has configured their account as a business"
    business: Boolean
    "The Business Seller address for businesses in the EU"
    businessAddress: String
    "The Business Seller Email for businesses in the EU"
    businessEmail: String
    "The Business Seller Phone Number for businesses in the EU"
    businessPhoneNumber: String
    "The cover photo URL in the original size"
    coverPhotoUrl: String
    "A user-defined description"
    description: String
    "Facebook account URI"
    facebook: String
    "The first name of the type implementing a User interface"
    firstName: String
    "The Profile is for a user hosting events on Universe"
    host: Boolean
    "Public-visibility Events with no future Time Slots hosted by this account"
    hosted: EventConnection
    "Public-visibility Events with future Time Slots hosted by this account"
    hosting: EventConnection
    id: ID
    "Instagram account URI"
    instagram: String
    "The last name of the type implementing a User interface"
    lastName: String
    "User locale"
    locale: Locale
    "A plain-text user-inputed string referring to their self-defined location"
    location: String
    "Determines if a user is messageable"
    messageable: Boolean
    "A single field concatenating firstName and lastName"
    name: String
    "The type of the viewer account (Admin, User, Spammer, etc)"
    role: UserRole!
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String
    "The avatar URL, 50x50 pixels"
    smallAvatarUrl: String
    superAdmin: Boolean!
    "Twitter account URI"
    twitter: String
    "The Profile URI"
    url: String!
    visibility: ProfileVisibility!
    "A stringified URI, user-inputed"
    website: String
}

type Query {
    addOn(id: ID!): AddOn
    calendarWidget(id: ID!, startingDate: String!): CalendarWidget!
    calendarWidgets(hostId: ID!, startingDate: String!): [CalendarWidget]!
    categories(keywords: String): [Category!]!
    commissionCodes(code: PricingPlan, currencies: [CurrencyCode!]!): [CommissionCode!]!
    discount(id: ID!): Discount!
    event(id: ID!): Event!
    eventSet(id: ID!): EventSet!
    host(id: ID!): Host!
    manageBasics(id: ID!): ManageBasics!
    manageCustomize(id: ID!): ManageCustomize!
    manageCustomizeTickets(id: ID!, startingDate: String!): ManageCustomizeTickets!
    manageTickets(id: ID!): ManageTickets!
    manageWhenRegularEntry(id: ID!): ManageWhenRegularEntry!
    manageWhenTimedEntry(id: ID!): ManageWhenTimedEntry!
    order(id: ID!): Order!
    orderItem(id: ID!): OrderItem!
    orderItems(
        "Select order items on a given order"
        id: ID!
    ): [OrderItem!]!
    profile(id: ID, slug: String): Profile!
    settlementCurrency(latitude: Float!, longitude: Float!): CurrencyCode
    timeSlotSelect(id: ID!): TimeSlotSelect!
    timeslotFilter(id: ID!, startTimeAfter: String, startTimeBefore: String): TimeslotFilter!
    timezone(latitude: Float!, longitude: Float!): String
    transactionCurrency(latitude: Float!, longitude: Float!): CurrencyCode
    transfer(token: String!): Transfer!
    upgradableOrder(id: ID!, orderItemId: ID): UpgradableOrder!
    viewer: Viewer!
    whitelistedCountries: [Country!]!
}

type Question {
    context: AnswerContext!
    editable: String!
    hasOther: Boolean!
    id: ID!
    included: Boolean!
    index: Int!
    multiple: Boolean!
    "Question"
    question: String!
    "Rate ids for which this question is set"
    rateIds: [ID]!
    "Rates which this question needs to be set"
    rates: [Rate]!
    required: Boolean!
    selectOptions: JSON
    subType: String
    "Type of the question, have no idea which values it can have"
    type: AnswerType!
}

"Rates are product types available for sale - most typically these are tickets, but they are also configurable as Passes, and in the future other meta product types may be added"
type Rate {
    "Optional capacity for this rate"
    capacity: Int
    clientGroup: RateClientGroup!
    "Optional description for this rate"
    description: String
    "Displays a price that contains taxes and fees if the listing has all-in pricing enabled. If the listing does not have it enabled, this is identical to price."
    displayPrice: Float!
    endStamp: Int
    exclusionRules: [JSON!]
    id: ID!
    "A limit of the number of tickets of this type sellable for each TimeSlot on an Event"
    maxQuantity: Int
    "Optional amount of maximum tickets allowed when purchasing this rate"
    maxTickets: Int
    "The minimum price of this type of ticket, used only in PWYW/donation tickets"
    minPrice: Float!
    "Optional amount of minimum tickets required when purchasing this rate"
    minTickets: Int
    name: String!
    optionName: String
    "Confirmed OrderItems in the Order, don't include transfers"
    orderItems: OrderItemConnection!
    "The price of this type of ticket - 0.0 if free"
    price: Float!
    "Time (in seconds) setting when purchased orders on this rate will be released to the fan"
    releaseOffset: Int
    "Total net sales"
    sales: Money!
    "Total net sales amount"
    salesAmount: Float! @deprecated(reason: "Use new 'sales' field for more detail")
    startStamp: Int
    state: RateState!
    "Rate type I.E Ticket, Pass, or Add-on"
    type: RateType
}

"Capacity for a Rate within a Time Slot"
type RateCapacity {
    "Available capacity count for a Rate within a Time Slot. It depends on the Event and Rate maxQuantity. Returns null if there is no maxQuantity set for Event and Rate. "
    available: Int
    countAttending: Int
    countAvailable: Int
    id: ID!
    "Rate for the capacity in a Time Slot"
    rate: Rate!
    rateId: ID!
    timeSlotId: ID
    type: String!
}

type RateCapacityConnection {
    nodes(limit: Int = 10, offset: Int = 0): [RateCapacity!]!
    pagination: JSON
    totalCount: Int!
}

type RateConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Rate!]!
    pagination: JSON
    totalCount: Int!
}

"Autogenerated return type of RateCreate"
type RateCreatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [Error!]
    rate: Rate
}

"Customized Rate values"
type RateCustomization {
    capacity: Int
    enabled: Boolean
    eventId: ID
    id: ID!
    listingId: ID
    rateId: ID
}

"True if rate with state exists and false if rate with state does not exist"
type RateStateExists {
    inactive: Boolean!
    locked: Boolean!
    soldAtDoor: Boolean
}

"Autogenerated return type of RateUpdate"
type RateUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String]
    rate: Rate
}

"Autogenerated return type of RatesUpdate"
type RatesUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String]
    rates: [Rate!]
}

"Rule describing when ticket refunds should be allowed"
type RefundPolicy {
    offset: RefundOffset!
    type: RefundOffsetType!
}

"WIP"
type Report {
    columns: JSON!
    preview(
        "number of rows to return in the preview"
        limit: Int = 10,
        "number of rows to skip in the preview"
        offset: Int = 0
    ): JSON!
}

"Sales data through channel"
type SalesChannel {
    "Channel name"
    channelName: String
    "Sales amount"
    salesAmount: Int
    "Sales count"
    salesCount: Int
}

"Represents a Saver who Saved an Event"
type Saver implements User {
    admin: Boolean!
    "The avatar URL, 160x160 pixels"
    avatarUrl: String
    "The Business Seller address for businesses in the EU"
    businessAddress: String
    "The Business Seller Email for businesses in the EU"
    businessEmail: String
    "The Business Seller Phone Number for businesses in the EU"
    businessPhoneNumber: String
    "A user-defined description"
    description: String
    "The first name of the type implementing a User interface"
    firstName: String
    id: ID
    "The last name of the type implementing a User interface"
    lastName: String
    "User locale"
    locale: Locale
    "A single field concatenating firstName and lastName"
    name: String
    "The type of the viewer account (Admin, User, Spammer, etc)"
    role: UserRole!
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String
    "The avatar URL, 50x50 pixels"
    smallAvatarUrl: String
    superAdmin: Boolean!
}

type SaversConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Saver!]!
    pagination: JSON
    totalCount: Int!
}

"The object that controls the creation of batch timeslots"
type Schedule {
    "End date in YYYY/MM/DD"
    endDate: String
    id: ID!
    "The timeslot intervals assigned to this Schedule"
    intervals: [ScheduleInterval!]!
    "Current progress of this schedule"
    progress: Int!
    "True if there are associated ticket sales, False if there are no associated ticket sales."
    readOnly: Boolean
    "Start date in YYYY/MM/DD"
    startDate: String!
    "The state this schedule is in"
    state: ScheduleState!
    "Weekdays available in the schedule, represented by 0-6"
    weekdaysAvailable: [Days!]!
}

type ScheduleConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Schedule!]!
    pagination: JSON
    totalCount: Int!
}

"Each individual timeslot rule within a schedule"
type ScheduleInterval {
    "The timeslot intervals assigned to this Schedule"
    datesToSkip: [Date]!
    "How long a timeslot will last from the startHour and startMinute"
    duration: Int!
    id: ID!
    "True when there are associated ticket sales, False when there are no assocaited ticket sales"
    readOnly: Boolean
    "The hour when a timeslot will begin"
    startHour: Int!
    "The minute when a timeslot will begin"
    startMinute: Int!
}

"Autogenerated return type of SeatsPublishDraft"
type SeatsPublishDraftPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Autogenerated return type of SeatsSyncRates"
type SeatsSyncRatesPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    event: Event
}

"Stripe connect account properties"
type StripeConnectAccount {
    currency: CurrencyCode!
    "Stripe Connect Account Id"
    id: String!
    "Payment methods associated with stripe connect account"
    paymentMethods: [String!]
}

"A label on an Event indicating an interest the Event includes"
type Tag {
    "The name of the tag"
    name: String!
    "The slug for the tag"
    slug: String!
    "Whether the tag is suggestable or not"
    suggestable: Boolean
}

"A tax rate that can be applied to cost items"
type Tax {
    "The add ons that use this tax"
    addOns: [AddOn]
    "The creator of the tax"
    host: Host
    id: ID
    "The name of tax"
    name: String
    "The percentage of tax rate"
    percent: Float
    "Tax registration number if available"
    taxId: String
}

type TaxConnection {
    nodes(limit: Int = 10, offset: Int = 0): [Tax!]!
    pagination: JSON
    totalCount: Int!
}

"Autogenerated return type of TaxCreate"
type TaxCreatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    tax: Tax
}

"A range of time with a start and an end, for which tickets are sellable. A single Event may have one or many TimeSlots. For example, a three day Event could be configured either with one TimeSlot (say Friday to Monday), or with three Timeslots (one for each of Friday, Saturday, and Sunday). "
type TimeSlot {
    "A list of all attendees for the Event, includes tickets from all states, including invalid."
    attendees: AttendeeConnection!
    "Available capacity count for Time Slot. Returns null if no capacityAlert or maxQuantity set for Event."
    availableCapacity: Int @deprecated(reason: "Prefer using capacityAlert on the Event and state on the TimeSlot to determine if timeslot is FULL.")
    "In UTC"
    createdAt: Time!
    "In Event's time zone"
    endAt: TimeWithoutTz!
    "In Event's time zone"
    endDate: Date!
    "UNIX Timestamp"
    endStamp: Int!
    event: Event!
    id: ID!
    "Orders created for this Event"
    orders: OrderConnection!
    "Rate capacities for the Event"
    rateCapacities: RateCapacityConnection!
    rates: [Rate!]
    report(
        "array of {key: value} or 'string' where clauses"
        clauses: [JSON] = [],
        "columns to return"
        columns: [String] = [],
        "type of report"
        name: String = "AttendeesReport"
    ): Report!
    "Future or ongoing TimeSlots for the same Event within the same day"
    sameDayTimeSlots: TimeSlotConnection!
    "In Event's time zone"
    startAt: TimeWithoutTz!
    "In Event's time zone"
    startDate: Date!
    "UNIX Timestamp"
    startStamp: Int!
    state: TimeSlotState!
    timeSlotReport: TimeSlotReport!
    "An IANA Time Zone string"
    tz: String!
    "In UTC"
    updatedAt: Time!
}

type TimeSlotConnection {
    nodes(limit: Int, offset: Int = 0): [TimeSlot!]!
    pagination: JSON
    totalCount: Int!
}

"Report that provides overview information on order item sales"
type TimeSlotReport {
    addOnsByDate: [JSON]
    "Number of add-ons sold"
    addonItemsSold: Int!
    "Number of order items and add-ons sold"
    costItemsSold: Int!
    id: ID!
    invitationsByDate: [JSON]
    "Number of invitations sent out to potential buyers"
    invitationsSent: Int
    "The monetary value that represents the total of tickets sold in-person before Universe has made its deductions"
    offlineAmountGross: Float
    salesByDate: [JSON]
    "Number of order items sold"
    ticketItemsSold: Int!
    ticketsAvailableByRate: [JSON]
    ticketsByDate: [JSON]
    "Number of orders processed"
    ticketsSold: Int!
    totalAddonItemsGross: Float
    "Monetary amount of discounts applied to order items"
    totalAmountDiscount: Float
    "Commission amount given to Universe as payment per ticket"
    totalCommissionIncluded: Float
    "Fees on on order items"
    totalFee: Float
    "The monetary value that represents the total before Universe has made its deductions"
    totalGross: Float
    "The monetary value that represents the total after Universe has made its deductions such as Service Charge"
    totalNet: Float
    "Taxes on order items"
    totalTaxes: Float
    totalTicketItemsGross: Float
    "Taxes on Universe fees or Value Added Tax"
    totalVatIncluded: Float
}

"Returns fields required for TimeSlotSelect modal to function"
type TimeSlotSelect {
    "Dates on which there are time slots"
    datesWithTimeSlots: [String!]
}

"Autogenerated return type of TimeSlotUpdate"
type TimeSlotUpdatePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String!]
    timeSlot: TimeSlot
}

"Namespace for the timeslot filter query"
type TimeslotFilter {
    id: ID!
    "Timeslot filter timeslots"
    timeslots: [TimeslotFilterTimeslot]!
}

"TimeslotFilterTimeslot"
type TimeslotFilterTimeslot {
    countAttending: Int
    countAvailable: Int
    "Timeslot end date and time in events timezone"
    endAt: String!
    "In Event's time zone"
    endDate: Date!
    "UNIX Timestamp"
    endStamp: Int!
    id: ID!
    "Timeslot start date and time in events timezone"
    startAt: String!
    "In Event's time zone"
    startDate: Date!
    "UNIX Timestamp"
    startStamp: Int!
    "An IANA Time Zone string"
    tz: String!
}

"Autogenerated return type of TimeslotRateCustomization"
type TimeslotRateCustomizationPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [String]
    rates: [Rate]
    success: Boolean
}

"Transfers represents the act of transferring one ticket from an user to another one"
type Transfer {
    "In UTC"
    createdAt: Time!
    email: String
    firstName: String
    id: ID!
    lastName: String
    orderItem: OrderItem
    originalOrderItem: OrderItem
    state: TransferState!
    token: String
    "In UTC"
    updatedAt: Time!
}

"Autogenerated return type of TransferAccept"
type TransferAcceptPayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [Error!]
    transfer: Transfer
}

"Autogenerated return type of TransferDecline"
type TransferDeclinePayload {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    errors: [Error!]
    transfer: Transfer
}

"This type provides data necessary for Upgrade Tickets modal to function on manage panel"
type UpgradableOrder {
    "Buyer's answers to checkout questions on the Order level"
    answers: [Answer]!
    id: ID!
    "Collection of rate ids for the upgradable order items in this order"
    rateIds: [ID!]
    "Whether the order has upgradable items"
    upgradable: Boolean!
    "Order items that can be upgraded to a different rate"
    upgradableOrderItems: [UpgradableOrderItem!]!
}

"An order item in the order that is upgradable to another rate"
type UpgradableOrderItem {
    "Buyer's answers to checkout questions on the OrderItem level (i.e. CostItem)"
    answers: [Answer]!
    "In UTC"
    createdAt: Time!
    id: ID!
    name: String!
    "Owner of upgradable order item"
    owner: OrderItemOwner!
    rateId: ID!
    "In UTC"
    updatedAt: Time!
    "Determines wether OrderItem is upgradable"
    upgradable: Boolean!
    "Rates to which an oder item can be upgraded to"
    upgradableToRates: [Rate]!
}

"The user making the current GraphQL operation"
type Viewer implements User {
    admin: Boolean!
    "The avatar URL, 160x160 pixels"
    avatarUrl: String
    "The user has configured their account as a business"
    business: Boolean
    "The Business Seller address for businesses in the EU"
    businessAddress: String
    "The Business Seller Email for businesses in the EU"
    businessEmail: String
    "The Business Seller Phone Number for businesses in the EU"
    businessPhoneNumber: String
    "The approximate city of the location of Viewer either by saved location or IP address"
    cityName: String
    "The user has configured email"
    confirmed: Boolean
    "The approximate country of the location of Viewer either by saved location or IP address"
    countryName: String
    "the currencies of the viewer's organizations"
    currencies: [CurrencyCode!]
    "A user-defined description"
    description: String
    "The base currency for the event"
    displayCurrency: String
    "A (potentially unconfirmed) email address belong to the Viewer"
    email: String
    "All Events by this Viewer"
    events(currency: CurrencyCode, slugs: [String!], states: [EventState!]): EventConnection!
    "The first name of the type implementing a User interface"
    firstName: String
    "The user is hosting events on Universe"
    host: Boolean
    id: ID
    "The last name of the type implementing a User interface"
    lastName: String
    "The approximate latitude of the location of Viewer either by saved location or IP address"
    latitude: Float
    "User locale"
    locale: Locale
    "The approximate longitude of the location of Viewer either by saved location or IP address"
    longitude: Float
    "Viewers memberships organization information"
    memberships: MembershipConnection
    "A single field concatenating firstName and lastName"
    name: String
    "The type of the viewer account (Admin, User, Spammer, etc)"
    role: UserRole!
    "A unique identifier, shorter version of the ID. Should be used for URI construction."
    slug: String
    "The avatar URL, 50x50 pixels"
    smallAvatarUrl: String
    superAdmin: Boolean!
    "The predicted TimeSlot duration from startAt to endAt in seconds"
    timeSlotDuration: Int
    "The predicted TimeSlot startAt time"
    timeSlotStartAt: TimeWithoutTz!
    "The transacted currency for the event"
    transactedCurrency: String
}

"The state an access key can be in"
enum AccessKeyState {
    "The Access Key is available for use"
    ACTIVE
    "The Access Key is not available for use"
    INACTIVE
    "The Access Key has been fully used and cannot be redeemed"
    USED
}

"Answer context"
enum AnswerContext {
    "Once per order question"
    ORDER
    "Once per order item question"
    ORDER_ITEM
}

"Question types"
enum AnswerType {
    "Yes or no"
    CHECKBOX
    "Multiple choices from many"
    MULTI_SELECT
    "Single choice from many"
    SELECT
    "Regular text"
    TEXT
}

"Credit Card brands supported by our payment systems"
enum CardBrand {
    AMERICAN_EXPRESS
    DINERS_CLUB
    DISCOVER
    JCB
    MASTERCARD
    UNIONPAY
    UNKNOWN
    VISA
}

"List of potential event categories"
enum CategoryKey {
    "Business"
    BUSINESS
    "Comedy"
    COMEDY
    "Crafts"
    CRAFTS
    "Fashion"
    FASHION
    "Film"
    FILM
    "Food & Drink"
    FOOD_DRINK
    "Galleries"
    GALLERIES_MUSEUMS
    "Music"
    MUSIC
    "Other"
    OTHER
    "Performances"
    PERFORMING_ARTS
    "Social"
    SOCIAL
    "Sports"
    SPORTS
    "Tech"
    TECH
}

"CheckInState describes if an OrderItem was checked in or not."
enum CheckInState {
    "The initial check in state"
    CHECKED_OUT
    "Check in done by the host"
    MANUALLY_CHECKED_IN
    "QR Code was scanned at the door"
    SCANNED_IN
    "QR Code was scanned out"
    SCANNED_OUT
}

"Supported content formats."
enum ContentFormat {
    HTML
    TEXT
}

"Two letter continent code"
enum Continent {
    "Africa"
    AF
    "Antarctica"
    AN
    "Asia"
    AS
    "Europe"
    EU
    "North America"
    NA
    "Oceania"
    OC
    "South America"
    SA
}

"ISO 3166-1 alpha-2 country codes"
enum CountryCode {
    "Andorra"
    AD
    "United Arab Emirates"
    AE
    "Afghanistan"
    AF
    "Antigua and Barbuda"
    AG
    "Anguilla"
    AI
    "Albania"
    AL
    "Armenia"
    AM
    "Angola"
    AO
    "Argentina"
    AR
    "American Samoa"
    AS
    "Austria"
    AT
    "Australia"
    AU
    "Aruba"
    AW
    "Åland Islands"
    AX
    "Azerbaijan"
    AZ
    "Bosnia and Herzegovina"
    BA
    "Barbados"
    BB
    "Bangladesh"
    BD
    "Belgium"
    BE
    "Burkina Faso"
    BF
    "Bulgaria"
    BG
    "Bahrain"
    BH
    "Burundi"
    BI
    "Benin"
    BJ
    "Saint Barthélemy"
    BL
    "Bermuda"
    BM
    "Brunei Darussalam"
    BN
    "Bolivia"
    BO
    "Brazil"
    BR
    "Bahamas"
    BS
    "Bhutan"
    BT
    "Botswana"
    BW
    "Belarus"
    BY
    "Belize"
    BZ
    "Canada"
    CA
    "Cocos (Keeling) Islands"
    CC
    "Congo"
    CD
    "Central African Republic"
    CF
    "Congo"
    CG
    "Switzerland"
    CH
    "Côte d'Ivoire"
    CI
    "Cook Islands"
    CK
    "Chile"
    CL
    "Cameroon"
    CM
    "China"
    CN
    "Colombia"
    CO
    "Costa Rica"
    CR
    "Cuba"
    CU
    "Cape Verde"
    CV
    "Curaçao"
    CW
    "Christmas Island"
    CX
    "Cyprus"
    CY
    "Czech Republic"
    CZ
    "Germany"
    DE
    "Djibouti"
    DJ
    "Denmark"
    DK
    "Dominica"
    DM
    "Dominican Republic"
    DO
    "Algeria"
    DZ
    "Ecuador"
    EC
    "Estonia"
    EE
    "Egypt"
    EG
    "Western Sahara"
    EH
    "Eritrea"
    ER
    "Spain"
    ES
    "Ethiopia"
    ET
    "Finland"
    FI
    "Fiji"
    FJ
    "Falkland Islands (Malvinas)"
    FK
    "Micronesia"
    FM
    "Faroe Islands"
    FO
    "France"
    FR
    "Gabon"
    GA
    "United Kingdom"
    GB
    "Grenada"
    GD
    "Georgia"
    GE
    "French Guiana"
    GF
    "Guernsey"
    GG
    "Ghana"
    GH
    "Gibraltar"
    GI
    "Greenland"
    GL
    "Gambia"
    GM
    "Guinea"
    GN
    "Guadeloupe"
    GP
    "Equatorial Guinea"
    GQ
    "Greece"
    GR
    "South Georgia and the South Sandwich Islands"
    GS
    "Guatemala"
    GT
    "Guam"
    GU
    "Guinea-Bissau"
    GW
    "Guyana"
    GY
    "Hong Kong"
    HK
    "Honduras"
    HN
    "Croatia"
    HR
    "Haiti"
    HT
    "Hungary"
    HU
    "Indonesia"
    ID
    "Ireland"
    IE
    "Israel"
    IL
    "Isle of Man"
    IM
    "India"
    IN
    "Iraq"
    IQ
    "Iran"
    IR
    "Iceland"
    IS
    "Italy"
    IT
    "Jersey"
    JE
    "Jamaica"
    JM
    "Jordan"
    JO
    "Japan"
    JP
    "Kenya"
    KE
    "Kyrgyzstan"
    KG
    "Cambodia"
    KH
    "Kiribati"
    KI
    "Comoros"
    KM
    "Saint Kitts and Nevis"
    KN
    "North Korea"
    KP
    "South Korea"
    KR
    "Kuwait"
    KW
    "Cayman Islands"
    KY
    "Kazakhstan"
    KZ
    "Lao"
    LA
    "Lebanon"
    LB
    "Saint Lucia"
    LC
    "Liechtenstein"
    LI
    "Sri Lanka"
    LK
    "Liberia"
    LR
    "Lesotho"
    LS
    "Lithuania"
    LT
    "Luxembourg"
    LU
    "Latvia"
    LV
    "Libya"
    LY
    "Morocco"
    MA
    "Monaco"
    MC
    "Moldova"
    MD
    "Montenegro"
    ME
    "Saint Martin"
    MF
    "Madagascar"
    MG
    "Marshall Islands"
    MH
    "Macedonia"
    MK
    "Mali"
    ML
    "Myanmar"
    MM
    "Mongolia"
    MN
    "Macao"
    MO
    "Northern Mariana Islands"
    MP
    "Martinique"
    MQ
    "Mauritania"
    MR
    "Montserrat"
    MS
    "Malta"
    MT
    "Mauritius"
    MU
    "Maldives"
    MV
    "Malawi"
    MW
    "Mexico"
    MX
    "Malaysia"
    MY
    "Mozambique"
    MZ
    "Namibia"
    NA
    "New Caledonia"
    NC
    "Niger"
    NE
    "Norfolk Island"
    NF
    "Nigeria"
    NG
    "Nicaragua"
    NI
    "Netherlands"
    NL
    "Norway"
    NO
    "Nepal"
    NP
    "Nauru"
    NR
    "Niue"
    NU
    "New Zealand"
    NZ
    "Oman"
    OM
    "Panama"
    PA
    "Peru"
    PE
    "French Polynesia"
    PF
    "Papua New Guinea"
    PG
    "Philippines"
    PH
    "Pakistan"
    PK
    "Poland"
    PL
    "Saint Pierre and Miquelon"
    PM
    "Pitcairn"
    PN
    "Puerto Rico"
    PR
    "Palestine"
    PS
    "Portugal"
    PT
    "Palau"
    PW
    "Paraguay"
    PY
    "Qatar"
    QA
    "Réunion"
    RE
    "Romania"
    RO
    "Serbia"
    RS
    "Russia"
    RU
    "Rwanda"
    RW
    "Saudi Arabia"
    SA
    "Solomon Islands"
    SB
    "Seychelles"
    SC
    "Sudan"
    SD
    "Sweden"
    SE
    "Singapore"
    SG
    "Saint Helena, Ascension and Tristan da Cunha"
    SH
    "Slovenia"
    SI
    "Svalbard and Jan Mayen"
    SJ
    "Slovakia"
    SK
    "Sierra Leone"
    SL
    "San Marino"
    SM
    "Senegal"
    SN
    "Somalia"
    SO
    "Suriname"
    SR
    "South Sudan"
    SS
    "Sao Tome and Principe"
    ST
    "El Salvador"
    SV
    "Sint Maarten"
    SX
    "Syrian Arab Republic"
    SY
    "Swaziland"
    SZ
    "Turks and Caicos Islands"
    TC
    "Chad"
    TD
    "French Southern Territories"
    TF
    "Togo"
    TG
    "Thailand"
    TH
    "Tajikistan"
    TJ
    "Timor-Leste"
    TL
    "Turkmenistan"
    TM
    "Tunisia"
    TN
    "Tonga"
    TO
    "Turkey"
    TR
    "Trinidad and Tobago"
    TT
    "Tuvalu"
    TV
    "Taiwan"
    TW
    "Tanzania"
    TZ
    "Ukraine"
    UA
    "Uganda"
    UG
    "United States"
    US
    "Uruguay"
    UY
    "Uzbekistan"
    UZ
    "Vatican City"
    VA
    "Saint Vincent and the Grenadines"
    VC
    "Venezuela"
    VE
    "British Virgin Islands"
    VG
    "US Virgin Islands"
    VI
    "Viet Nam"
    VN
    "Vanuatu"
    VU
    "Wallis and Futuna"
    WF
    "Samoa"
    WS
    "Kosovo"
    XK
    "Yemen"
    YE
    "Mayotte"
    YT
    "South Africa"
    ZA
    "Zambia"
    ZM
    "Zimbabwe"
    ZW
}

"ISO 4217 currency codes"
enum CurrencyCode {
    "د.إ AED"
    AED
    "؋ AFN"
    AFN
    "L ALL"
    ALL
    "դր. AMD"
    AMD
    "ƒ ANG"
    ANG
    "Kz AOA"
    AOA
    "$ ARS"
    ARS
    "$ AUD"
    AUD
    "ƒ AWG"
    AWG
    "AZN"
    AZN
    "КМ BAM"
    BAM
    "$ BBD"
    BBD
    "৳ BDT"
    BDT
    "лв BGN"
    BGN
    "ب.د BHD"
    BHD
    "Fr BIF"
    BIF
    "$ BMD"
    BMD
    "$ BND"
    BND
    "Bs. BOB"
    BOB
    "R$ BRL"
    BRL
    "$ BSD"
    BSD
    "B⃦ BTC"
    BTC
    "Nu. BTN"
    BTN
    "P BWP"
    BWP
    "Br BYN"
    BYN
    "$ BZD"
    BZD
    "$ CAD"
    CAD
    "Fr CDF"
    CDF
    "Fr CHF"
    CHF
    "UF CLF"
    CLF
    "$ CLP"
    CLP
    "¥ CNY"
    CNY
    "$ COP"
    COP
    "₡ CRC"
    CRC
    "$ CUC"
    CUC
    "$ CUP"
    CUP
    "$ CVE"
    CVE
    "Kč CZK"
    CZK
    "Fdj DJF"
    DJF
    "kr DKK"
    DKK
    "$ DOP"
    DOP
    "د.ج DZD"
    DZD
    "ج.م EGP"
    EGP
    "Nfk ERN"
    ERN
    "Br ETB"
    ETB
    "€ EUR"
    EUR
    "$ FJD"
    FJD
    "£ FKP"
    FKP
    "£ GBP"
    GBP
    "ლ GEL"
    GEL
    "GGP"
    GGP
    "₵ GHS"
    GHS
    "£ GIP"
    GIP
    "D GMD"
    GMD
    "Fr GNF"
    GNF
    "Q GTQ"
    GTQ
    "$ GYD"
    GYD
    "$ HKD"
    HKD
    "L HNL"
    HNL
    "kn HRK"
    HRK
    "G HTG"
    HTG
    "Ft HUF"
    HUF
    "Rp IDR"
    IDR
    "₪ ILS"
    ILS
    "IMP"
    IMP
    "<U+20B9> INR"
    INR
    "ع.د IQD"
    IQD
    "﷼ IRR"
    IRR
    "kr ISK"
    ISK
    "£ JEP"
    JEP
    "$ JMD"
    JMD
    "د.ا JOD"
    JOD
    "¥ JPY"
    JPY
    "KSh KES"
    KES
    "som KGS"
    KGS
    "៛ KHR"
    KHR
    "Fr KMF"
    KMF
    "₩ KPW"
    KPW
    "₩ KRW"
    KRW
    "د.ك KWD"
    KWD
    "$ KYD"
    KYD
    "〒 KZT"
    KZT
    "₭ LAK"
    LAK
    "ل.ل LBP"
    LBP
    "₨ LKR"
    LKR
    "$ LRD"
    LRD
    "L LSL"
    LSL
    "ل.د LYD"
    LYD
    "د.م. MAD"
    MAD
    "L MDL"
    MDL
    "Ar MGA"
    MGA
    "ден MKD"
    MKD
    "K MMK"
    MMK
    "₮ MNT"
    MNT
    "P MOP"
    MOP
    "UM MRO"
    MRO
    "₨ MUR"
    MUR
    "MVR MVR"
    MVR
    "MK MWK"
    MWK
    "$ MXN"
    MXN
    "RM MYR"
    MYR
    "MTn MZN"
    MZN
    "$ NAD"
    NAD
    "₦ NGN"
    NGN
    "C$ NIO"
    NIO
    "kr NOK"
    NOK
    "₨ NPR"
    NPR
    "$ NZD"
    NZD
    "ر.ع. OMR"
    OMR
    "B/. PAB"
    PAB
    "S/. PEN"
    PEN
    "K PGK"
    PGK
    "₱ PHP"
    PHP
    "₨ PKR"
    PKR
    "zł PLN"
    PLN
    "₲ PYG"
    PYG
    "ر.ق QAR"
    QAR
    "Lei RON"
    RON
    "РСД RSD"
    RSD
    "р. RUB"
    RUB
    "FRw RWF"
    RWF
    "ر.س SAR"
    SAR
    "$ SBD"
    SBD
    "₨ SCR"
    SCR
    "£ SDG"
    SDG
    "kr SEK"
    SEK
    "$ SGD"
    SGD
    "£ SHP"
    SHP
    "Le SLL"
    SLL
    "Sh SOS"
    SOS
    "$ SRD"
    SRD
    "Db STD"
    STD
    "₡ SVC"
    SVC
    "£S SYP"
    SYP
    "L SZL"
    SZL
    "฿ THB"
    THB
    "ЅМ TJS"
    TJS
    "m TMT"
    TMT
    "د.ت TND"
    TND
    "T$ TOP"
    TOP
    "TL TRY"
    TRY
    "$ TTD"
    TTD
    "$ TWD"
    TWD
    "Sh TZS"
    TZS
    "₴ UAH"
    UAH
    "USh UGX"
    UGX
    "$ USD"
    USD
    "$ UYU"
    UYU
    " UZS"
    UZS
    "BsF VEF"
    VEF
    "₫ VND"
    VND
    "Vt VUV"
    VUV
    "T WST"
    WST
    "Fr XAF"
    XAF
    "ozt XAG"
    XAG
    "ozt XAU"
    XAU
    "$ XCD"
    XCD
    "SDR XDR"
    XDR
    "Fr XOF"
    XOF
    "XPD"
    XPD
    "Fr XPF"
    XPF
    "XPT"
    XPT
    "﷼ YER"
    YER
    "R ZAR"
    ZAR
    "ZK ZMK"
    ZMK
    "ZK ZMW"
    ZMW
    "$ ZWL"
    ZWL
}

"Days"
enum Days {
    "Friday"
    FRIDAY
    "Monday"
    MONDAY
    "Saturday"
    SATURDAY
    "Sunday"
    SUNDAY
    "Thursday"
    THURSDAY
    "Tuesday"
    TUESDAY
    "Wednesday"
    WEDNESDAY
}

"Possible redemption value types of Discounts"
enum DiscountRedemptionType {
    "If fixed, the value of the Discount is a fixed amount off"
    FIXED
    "If percent, the value of the Discount is a percentage off"
    PERCENT
}

"Possible states a Discount can be in"
enum DiscountState {
    "The Discount is available for use"
    ACTIVE
    "The Discount is not available for use"
    INACTIVE
    "The Discount has been fully used (no quantity remaining) and cannot be redeemed"
    USED
}

"The privacy setting for an Event"
enum EventPrivacy {
    "The Event is private, not publicly searchable"
    PRIVATE
    "The default privacy setting - publicly searchable"
    PUBLIC
}

"The Event state determines whether Orders can be created (assuming available inventory). To be sellable, the Event MUST be in the POSTED state."
enum EventState {
    ARCHIVED
    "The Event has been disabled by a moderator"
    DECLINED
    "The Event is not complete, default state"
    DRAFT
    EXPIRED
    INACTIVE
    "The Event is complete, and available to sell tickets for"
    POSTED
    "The Event is complete, but the Host's account has not been confirmed (i.e. email ownership has been confirmed)"
    PRESUMBITTED
}

"Set the image crop mode."
enum ImageCropMode {
    "Crop Image"
    CROP
    "Resize Image Proportionally"
    PREVIEW
    "Resize Image"
    RESIZE
    "Downscale and Crop Image"
    SCALE_CROP
}

"Supported output formats."
enum ImageFormat {
    JPEG
    PNG
    WEBP
}

"Adjust image quality. Works with JPEG and WEBP formats."
enum ImageQuality {
    "≈170% file size"
    BEST
    "≈125% file size"
    BETTER
    "≈80% file size"
    LIGHTER
    "≈50% file size compared to 'NORMAL'"
    LIGHTEST
    "≈100% file size"
    NORMAL
}

"Supported locales"
enum Locale {
    "Dansk"
    DA
    "Deutsch"
    DE
    "Ελληνικά"
    EL
    "English"
    EN
    "Español"
    ES
    "Suomen kieli"
    FI
    "Français"
    FR
    "Norsk Bokmål"
    NB
    "Nederlands"
    NL
    "Nederlands (België)"
    NL_BE
    "Svenska"
    SV
}

"Types of filters by which to send messages"
enum MessageType {
    AFTER_DATE
    ALL
    BY_RATE
    CHECKED_IN
    DECLINED
    UNAPPROVED
}

"OrderItemState describes the possible states an OrderItem may be in."
enum OrderItemState {
    "The OrderItem was created and processed, but has since been cancelled and any associated transactions have been reverted"
    CANCELLED
    "This state has been deprecated, and will be removed soon"
    CHECKOUT
    "The OrderItem has been processed, and funds captured by the charge have been transferred to the Event Host"
    CLOSED
    "The OrderItem has been processed, but the payment method was declined by the upstream gateway"
    DECLINED
    "The OrderItem was created and processed, and 48 hours has passed since the Event. The funds associated with this OrderItem are now pending a transfer to the Host"
    ENDED
    "The OrderItem could not be processed due to internal service disruption inside of"
    ERROR
    "The OrderItem was created but not processed for any reason, and can no longer be processed because the Event has happened"
    EXPIRED
    "The OrderItem has been processed, and processing failed"
    FAILED
    "The OrderItem has been successfully processed, and payment methods have been charged"
    PAID
    "The OrderItem has been processed and processed, but an outstanding balance remainds. This state is used specifically for our Payment Plans product. In general, exercise care in dealing with OrderItems in this state, because a default on future payments remains possible."
    PARTIALLY_PAID
    "The OrderItem has been created but a charge has not yet been authorized"
    PENDING
    "The OrderItem was created and was transferred to another buyer."
    TRANSFERRED
    "The OrderItem has been created, but requires approval by the Host to process"
    UNAPPROVED
    "The OrderItem was created and, but requires authorizeation by the Buyer."
    UNAUTHORIZED
    "The OrderItem has been created and a charge has been authorized but not yet processed - the default state"
    UNPAID
    "The OrderItem was created and was upgraded to a new ticket type. This OrderItem is no longer valid for entry."
    UPGRADED
}

"OrderState describes the possible states an Order may be in."
enum OrderState {
    "The Order was created and processed, but has since been cancelled and any associated transactions have been reverted"
    CANCELLED
    "This state has been deprecated, and will be removed soon"
    CHECKOUT
    "The Order has been processed, and funds captured by the charge have been transferred to the Event Host"
    CLOSED
    "The Order has been processed, but the payment method was declined by the upstream gateway"
    DECLINED
    "The Order was disputed. Ticket is invalid for entry, but counts towards capacity until resolved."
    DISPUTED
    "The Order was created and processed, and 48 hours has passed since the Event. The funds associated with this Order are now pending a transfer to the Host"
    ENDED
    "The Order could not be processed due to internal service disruption inside of"
    ERROR
    "The Order was created but not processed for any reason, and can no longer be processed because the Event has happened"
    EXPIRED
    "The Order has been processed, and processing failed"
    FAILED
    "The Order has been successfully processed, and payment methods have been charged"
    PAID
    "The Order has been processed and processed, but an outstanding balance remainds. This state is used specifically for our Payment Plans product. In general, exercise care in dealing with Orders in this state, because a default on future payments remains possible."
    PARTIALLY_PAID
    "The Order has been created but a charge has not yet been authorized"
    PENDING
    "The Order has been created, but requires approval by the Host to process"
    UNAPPROVED
    "The Order was created and, but requires authorizeation by the Buyer."
    UNAUTHORIZED
    "The Order has been created and a charge has been authorized but not yet processed - the default state"
    UNPAID
}

"When a card issuer declines a payment, they will provide a reason through the use of a decline code"
enum PaymentDeclineCode {
    "translation missing: en.misc.bank_decline_codes.approve_with_id"
    APPROVE_WITH_ID
    "translation missing: en.misc.bank_decline_codes.call_issuer"
    CALL_ISSUER
    "translation missing: en.misc.bank_decline_codes.card_declined"
    CARD_DECLINED
    "translation missing: en.misc.bank_decline_codes.card_not_supported"
    CARD_NOT_SUPPORTED
    "translation missing: en.misc.bank_decline_codes.card_velocity_exceeded"
    CARD_VELOCITY_EXCEEDED
    "translation missing: en.misc.bank_decline_codes.currency_not_supported"
    CURRENCY_NOT_SUPPORTED
    "translation missing: en.misc.bank_decline_codes.do_not_honor"
    DO_NOT_HONOR
    "translation missing: en.misc.bank_decline_codes.do_not_try_again"
    DO_NOT_TRY_AGAIN
    "translation missing: en.misc.bank_decline_codes.duplicate_transaction"
    DUPLICATE_TRANSACTION
    "translation missing: en.misc.bank_decline_codes.expired_card"
    EXPIRED_CARD
    "translation missing: en.misc.bank_decline_codes.fraudulent"
    FRAUDULENT
    "translation missing: en.misc.bank_decline_codes.generic_decline"
    GENERIC_DECLINE
    "translation missing: en.misc.bank_decline_codes.incorrect_cvc"
    INCORRECT_CVC
    "translation missing: en.misc.bank_decline_codes.incorrect_number"
    INCORRECT_NUMBER
    "translation missing: en.misc.bank_decline_codes.insufficient_funds"
    INSUFFICIENT_FUNDS
    "translation missing: en.misc.bank_decline_codes.invalid_account"
    INVALID_ACCOUNT
    "translation missing: en.misc.bank_decline_codes.invalid_amount"
    INVALID_AMOUNT
    "translation missing: en.misc.bank_decline_codes.invalid_cvc"
    INVALID_CVC
    "translation missing: en.misc.bank_decline_codes.invalid_expiry_year"
    INVALID_EXPIRY_YEAR
    "translation missing: en.misc.bank_decline_codes.issuer_not_available"
    ISSUER_NOT_AVAILABLE
    "translation missing: en.misc.bank_decline_codes.lost_card"
    LOST_CARD
    "translation missing: en.misc.bank_decline_codes.new_account_information_available"
    NEW_ACCOUNT_INFORMATION_AVAILABLE
    "translation missing: en.misc.bank_decline_codes.not_permitted"
    NOT_PERMITTED
    "translation missing: en.misc.bank_decline_codes.no_action_taken"
    NO_ACTION_TAKEN
    "translation missing: en.misc.bank_decline_codes.pickup_card"
    PICKUP_CARD
    "translation missing: en.misc.bank_decline_codes.processing_error"
    PROCESSING_ERROR
    "translation missing: en.misc.bank_decline_codes.restricted_card"
    RESTRICTED_CARD
    "translation missing: en.misc.bank_decline_codes.revocation_of_all_authorizations"
    REVOCATION_OF_ALL_AUTHORIZATIONS
    "translation missing: en.misc.bank_decline_codes.stolen_card"
    STOLEN_CARD
    "translation missing: en.misc.bank_decline_codes.stop_payment_order"
    STOP_PAYMENT_ORDER
    "translation missing: en.misc.bank_decline_codes.testmode_decline"
    TESTMODE_DECLINE
    "translation missing: en.misc.bank_decline_codes.try_again_later"
    TRY_AGAIN_LATER
    "translation missing: en.misc.bank_decline_codes.withdrawal_count_limit_exceeded"
    WITHDRAWAL_COUNT_LIMIT_EXCEEDED
}

enum PaymentMethod {
    ALIPAY
    BANCONTACT
    CARD
    EPS
    GIROPAY
    GLOBEE
    IDEAL
    INVOICE
    KLARNA
    MASTERPASS
    MULTIBANCO
    OFFLINE
    PRZELEWY
    SEPA
    SOFORT
    VISACHECKOUT
    WECHAT
}

"Possible permission types on a team membership (dashboard/organization)"
enum Permission {
    "Access to Account Activity Reports (financial summary of all money that came into and out of your account)"
    ACTIVITY_REPORT
    "Ability to add or upload attendees"
    ADD_ATTENDEES
    "Access to Add-ons Reports (includes the cost breakdown for each add-on)"
    ADD_ONS_REPORT
    "Ability to export Requires Approval Report (identifies all orders that have not been approved yet)"
    APPROVALS_REPORT
    "Ability view and contact attendees, and resend tickets"
    ATTENDEES
    "Ability to export Attendee's Report (includes data collected during checkout)"
    ATTENDEES_REPORT
    "Ability to export Audit Reports (shows a high-level daily summary of ticket sales)"
    AUDIT_REPORT
    "Ability to export Cancellations and Refunds Report"
    CANCELLATIONS_REPORT
    "Access to Chargeback Reports (all chargebacks for orders processed on Universe Payments)"
    CHARGEBACKS_REPORT
    "Access to At-the-Door (via the BoxOffice app) to scan and sell tickets onsite"
    CHECK_IN
    "Ability to export Check-in Report (list of all the check-ins and check-outs)"
    CHECK_INS_REPORT
    "Full access to all events and ability to create events"
    CREATABLE
    "Ability to delete events"
    DELETABLE
    "Ability to customize the \"Get Tickets\" button"
    DESIGN
    "Edit event details such as description, dates, checkout questions, etc., and advanced settings such as ticket transfers and waitlist options"
    EDIT
    "Access to Event Reports (A summary of tickets sold by ticket type on the event level)"
    EVENTS_REPORT
    "Ability to export Guestlists Report (ideal for checking people in at the door)"
    GUESTS_REPORT
    "Access to Invoice Reports"
    INVOICE_REPORT
    "Ability to manage events"
    MANAGE
    "Ability to manage all Add-ons"
    MANAGE_ADD_ONS
    "Access sales and ticket data on the event and account dashboards, and through integrations"
    MANAGE_OVERVIEW
    "Ability to view orders, contact buyers, refund and cancel orders"
    ORDERS
    "Access to Order Reports (includes a cost breakdown of each order)"
    ORDERS_REPORT
    "Promote the event using social deals, discount codes, social integrations, etc."
    PROMOTE
    "Access to Rebate Reports (all rebates received)"
    REBATES_REPORT
    "Access to Rebate Invoice Reports (all rebates received)"
    REBATE_INVOICE
    "Receive all emails regarding account activity"
    RECEIVES_EMAILS
    "Access to account level Reports"
    REPORT
    "Access to Universe Service Invoices"
    SERVICE_INVOICE
    "Access to Tickets Report (cost breakdown for each ticket)"
    TICKETS_REPORT
    "Access to Timeslot Reports (summary of tickets sold by ticket type on the timeslot level)"
    TIMESLOTS_REPORT
    "Ability to publish events"
    TRANSITION
}

"The pricing plan that a host is on."
enum PricingPlan {
    "A custom pricing plan."
    PRO
    "The standard pricing plan."
    STANDARD
    "The starter pricing plan."
    STARTER
}

"Possible visibility states a Profile can be in"
enum ProfileVisibility {
    "Hidden from search engines"
    HIDDEN
    "Private"
    PRIVATE
    "Public (recommended)"
    PUBLIC
}

"Payment methods supported by our payment systems"
enum ProviderSourceType {
    ALIPAY
    ANDROID_PAY
    APPLE_PAY
    BANCONTACT
    BCH
    BTC
    CARD
    DCR
    DOGE
    EPS
    ETH
    GIROPAY
    GLOBEE
    GOOGLE_PAY
    IDEAL
    INVOICE
    KLARNA
    LNBT
    LTC
    MASTERPASS
    MULTIBANCO
    OFFLINE
    PRZELEWY
    SEPA
    SOFORT
    VISACHECKOUT
    WECHAT
    XMR
    XRP
}

"A state representing which places a rate can be sold."
enum RateClientGroup {
    "The rate can only be sold at the door"
    AT_THE_DOOR
    "The rate can be sold both online and at-the-door"
    EVERYWHERE
    "The rate can only be sold online"
    ONLINE_ONLY
}

"Possible types to set on the createRate mutation."
enum RateCreateType {
    "The rate is for a free ticket"
    FREE_TICKET
    "The rate is for a paid ticket"
    PAID_TICKET
    "The rate is for a pay what you can ticket"
    PWYW_TICKET
}

"The state a rate can be in"
enum RateState {
    "The rate is available for purchase, if capacity is available"
    ACTIVE
    "The rate has been removed"
    HIDDEN
    INACTIVE
    "The rate is only available if the user provides a key"
    LOCKED
}

"Possible Rate types."
enum RateType {
    "The rate is for an add-on"
    ADD_ON
    "The rate is for a free ticket"
    FREE_TICKET
    "The rate is for a paid ticket"
    PAID_TICKET
    "The rate is for a pay what you can ticket"
    PWYW_TICKET
}

"What is the time of your refund policy?"
enum RefundOffset {
    "Tickets can never be refunded"
    NEVER
    "Your refund policy will affect 90 days"
    NINETY_DAYS
    "Your refund policy will affect 1 day"
    ONE_DAY
    "Your refund policy will affect 7 days"
    ONE_WEEK
    "Your refund policy will affect 60 days"
    SIXTY_DAYS
    "Your refund policy will affect 30 days"
    THIRTY_DAYS
    "Your refund policy will affect 3 days"
    THREE_DAYS
    "Your refund policy will affect 2 days"
    TWO_DAYS
}

"What is the scope of your refund policy?"
enum RefundOffsetType {
    "Your refund policy will be calculated from the event date"
    EVENT
    "Your refund policy will be calculated from the ticket purchase date"
    PURCHASE
}

"Specifies if a refund is flat or in percentage of the amount"
enum RefundType {
    FLAT
    PERCENT
}

"How long before the event would you like to release the ticket?"
enum ReleaseOffset {
    "Tickets will be released to attendees immediately"
    IMMEDIATELY
    "Tickets will never be released to attendees"
    NEVER
    "Tickets will be released to attendees 1 day before the event"
    ONE_DAY
    "Tickets will be released to attendees 7 days before the event"
    ONE_WEEK
    "Tickets will be released to attendees 3 days before the event"
    THREE_DAYS
    "Tickets will be released to attendees 2 days before the event"
    TWO_DAYS
}

"The state a schedule is in"
enum ScheduleState {
    "This schedule is currently manipulating timeslots"
    IN_SYNC
    "This schedule is done manipulating timeslots"
    SYNC_DONE
}

"The state an Event can be in"
enum TimeSlotState {
    "The event is sold out, no capacity remains"
    FULL
    "The event has been removed"
    HIDDEN
    "The event has valid tickets associated with it"
    NORMAL
    "No valid tickets have been sold for the event"
    UNBOOKED
}

"The state a transfer can be in"
enum TransferState {
    "The new ticket owner has accepted this transfer"
    ACCEPTED
    "The transfer has been cancelled"
    CANCELLED
    "The transfer recipient declined the transfer"
    DECLINED
    "The transfer expires once event begins"
    EXPIRED
    "The transfer has been sent to the new owner to be accepted"
    PENDING
}

"Possible roles a user can have"
enum UserRole {
    "The user has an admin account"
    ADMIN
    "The user has an Agent (call centre) account"
    AGENT
    "The user has a developer account"
    DEVELOPER
    "The user has a (tm) finance account"
    FINANCE
    "The user has a finance admin account"
    FINANCE_ADMIN
    "The user has a sales account"
    SALES
    "The user has a sales admin account"
    SALES_ADMIN
    "The user has been marked as a spammer"
    SPAMMER
    "The user has a super admin account"
    SUPER_ADMIN
    "The user has the default account type"
    USER
}

"Any type. Should only be used for checkout questions"
scalar Any

"Date string in ISO 8601 format: YYYY-mm-dd"
scalar Date

"A raw all-or-nothing JSON object"
scalar JSON

"Time string with timezone in ISO 8601 format. eg. 2017-09-15T17:50:00-04:00"
scalar Time

"Time string without timezone. E.g. 2017-09-15T17:50:00"
scalar TimeWithoutTz

"Properties for AccessKey creation"
input AccessKeyInputType {
    "Access key"
    key: String!
}

input AddOnAttributes {
    currency: CurrencyCode
    description: String
    hostPaysCommission: Boolean
    images: [ImageInputType]
    name: String
    rates: [AddOnRateInputType]
}

"Autogenerated input type of AddOnCreate"
input AddOnCreateInput {
    addOn: AddOnInputType!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Autogenerated input type of AddOnDelete"
input AddOnDeleteInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    hostId: ID
    id: ID!
}

input AddOnInputType {
    attributes: AddOnAttributes
    eventIds: [ID]
    hostId: ID
    id: ID
    taxIds: [ID]
}

"Shared updatable AddOnRate attributes"
input AddOnRateAttributes {
    capacity: Int
    description: String
    maxQuantity: Int
    minQuantity: Int
    name: String
    optionName: String
    price: Float
    sku: String
    state: RateState
}

"Properties for AddOnRate mutation"
input AddOnRateInputType {
    attributes: AddOnRateAttributes
    id: ID
}

"Autogenerated input type of AddOnUpdate"
input AddOnUpdateInput {
    addOn: AddOnInputType!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
}

"Input type for an answer."
input AnswerInputType {
    id: ID!
    value: Any
}

"Autogenerated input type of AttendeesMessage"
input AttendeesMessageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    datetime: Time
    id: ID!
    message: String!
    messageType: MessageType!
    rateIds: [ID!]
    timeSlotIds: [ID!]
}

"Autogenerated input type of BulkOrderTimeSlotUpdate"
input BulkOrderTimeSlotUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    orderIds: [ID!]!
    timeSlotId: ID!
}

input Category_EventCreate {
    id: ID!
}

input Category_EventUpdate {
    id: ID!
}

"Autogenerated input type of CustomReportCreate"
input CustomReportCreateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    columns: [String!]!
    currencyFilter: String
    days: [Days!]
    description: String
    enabled: Boolean!
    eventRangeFrom: Date
    eventRangeTo: Date
    events: [String!]
    filters: [JSON!]
    from: Date
    hour: Int
    name: String!
    order: String
    reportType: String!
    timeFilter: String
    to: Date
}

"Autogenerated input type of CustomReportDelete"
input CustomReportDeleteInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of CustomReportUpdate"
input CustomReportUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    columns: [String!]
    currencyFilter: String
    days: [Days!]
    description: String
    enabled: Boolean!
    eventRangeFrom: Date
    eventRangeTo: Date
    events: [String!]
    filters: [JSON!]
    from: Date
    hour: Int
    id: ID!
    name: String
    order: String
    reportType: String
    timeFilter: String
    to: Date
}

"Autogenerated input type of DiscountCreate"
input DiscountCreateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
    fixed: Float
    percent: Float
    quantity: Int
    redemptionType: DiscountRedemptionType!
    state: DiscountState!
    userId: ID!
}

"Autogenerated input type of DiscountDelete"
input DiscountDeleteInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    user_id: ID
}

input Discount_UpdateDiscount {
    code: String
    fixed: Float
    id: ID!
    percent: Float
    quantity: Int
    redemptionType: DiscountRedemptionType
    state: DiscountState
}

"Autogenerated input type of DiscountsCreate"
input DiscountsCreateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    codes: [String!]!
    fixed: Float
    percent: Float
    quantity: Int
    redemptionType: DiscountRedemptionType!
    state: DiscountState!
    userId: ID!
}

"Autogenerated input type of DiscountsUpdate"
input DiscountsUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    discounts: [Discount_UpdateDiscount!]!
}

"Autogenerated input type of EventCreate"
input EventCreateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    event: Event_EventCreate!
    publish: Boolean
}

"Autogenerated input type of EventDelete"
input EventDeleteInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of EventDuplicate"
input EventDuplicateInput {
    accessKeys: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    discountCodes: Boolean
    endAt: TimeWithoutTz!
    id: ID!
    startAt: TimeWithoutTz!
    title: String
}

"Autogenerated input type of EventPublish"
input EventPublishInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of EventReport"
input EventReportInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of EventSave"
input EventSaveInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    eventId: ID!
}

"Autogenerated input type of EventSetReport"
input EventSetReportInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of EventUnpublish"
input EventUnpublishInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of EventUpdate"
input EventUpdateInput {
    attributes: Event_EventUpdate!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

input Event_EventCreate {
    additionalPhotos: [ImageInputType!]
    address: String!
    allInPricing: Boolean
    availableCountries: [CountryCode]
    businessAddress: String
    businessEmail: String
    businessPhoneNumber: String
    capacityAlert: Boolean
    category: Category_EventCreate!
    contactDetails: String
    coverPhoto: ImageInputType
    descriptionHtml: String!
    eventPhoto: ImageInputType
    hiddenDate: Boolean
    latitude: Float!
    longitude: Float!
    maxQuantity: Int
    privacy: String
    privateNote: String
    publishLaterAt: Time
    rates: [RateCreateInputType!]!
    refundPolicy: RefundPolicyInputType
    schedules: [Schedule_EventCreate!]
    settlementCurrency: String
    socialButtons: Boolean
    timeSlots: [TimeSlot_EventCreate!]
    title: String!
    transactionCurrency: String
    userId: ID
    venueName: String
    virtual: Boolean
    virtualInfo: String
}

input Event_EventUpdate {
    additionalPhotos: [ImageUpdateInputType!]
    address: String
    allInPricing: Boolean
    capacityAlert: Boolean
    category: Category_EventUpdate
    contactDetails: String
    country: String
    coverPhoto: ImageInputType
    descriptionHtml: String
    eventPhoto: ImageInputType
    getTicketsText: String
    hiddenDate: Boolean
    latitude: Float
    longitude: Float
    maxQuantity: Int
    privacy: String
    privateNote: String
    rates: [RateUpdateInputType!]
    refundPolicy: RefundPolicyInputType
    schedules: [Schedule_EventUpdate!]
    settlementCurrency: String
    socialButtons: Boolean
    timeSlots: [TimeSlot_EventUpdate!]
    title: String
    transactionCurrency: String
    tz: String
    venueName: String
    virtual: Boolean
    virtualInfo: String
}

"Autogenerated input type of ExternalMetadataUpdate"
input ExternalMetadataUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    externalMetadata: String!
    id: ID!
}

"Autogenerated input type of HostGaIntegrationUpdate"
input HostGaIntegrationUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    hostGaIntegration: Host_GaIntegration!
}

input Host_GaIntegration {
    googleAnalyticsEcommerce: Boolean!
    googleAnalyticsId: String!
    hostId: ID!
}

"Image for listings, avatars, and add on options"
input ImageInputType {
    cropHeight: Int
    cropWidth: Int
    cropX: Int
    cropY: Int
    isGif: Boolean
    uploadId: String!
}

"Image for listings, avatars, and add on options"
input ImageUpdateInputType {
    cropHeight: Int
    cropWidth: Int
    cropX: Int
    cropY: Int
    id: ID
    isGif: Boolean
    uploadId: String
}

"Autogenerated input type of LocaleChange"
input LocaleChangeInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    locale: Locale!
}

"Autogenerated input type of MarkInvoiceAsPaid"
input MarkInvoiceAsPaidInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Input type for a new answer."
input NewAnswerInputType {
    questionId: ID!
    value: Any
}

"Autogenerated input type of OrderApprove"
input OrderApproveInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of OrderBuyerInfoChange"
input OrderBuyerInfoChangeInput {
    answers: [AnswerInputType!]!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String
    firstName: String
    id: ID!
    lastName: String
    newAnswers: [NewAnswerInputType!]!
}

"Autogenerated input type of OrderDecline"
input OrderDeclineInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of OrderItemAttendeeInfoChange"
input OrderItemAttendeeInfoChangeInput {
    answers: [AnswerInputType!]!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String
    firstName: String
    id: ID!
    lastName: String
    newAnswers: [NewAnswerInputType!]!
}

"Autogenerated input type of OrderItemCheckIn"
input OrderItemCheckInInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of OrderItemCheckOut"
input OrderItemCheckOutInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Refund arguments related to a single OrderItem"
input OrderItemRefundData {
    amount: Float!
    id: ID!
    refundType: RefundType!
    void: Boolean!
}

"Autogenerated input type of OrderItemResend"
input OrderItemResendInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of OrderRefund"
input OrderRefundInput {
    cancelNoRefund: Boolean!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    orderItemRefundDatas: [OrderItemRefundData!]!
    totalReturning: Int!
    transactionRefund: Boolean!
}

"Autogenerated input type of OrderResend"
input OrderResendInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    receiptOnly: Boolean = false
}

"Autogenerated input type of OrderTimeSlotUpdate"
input OrderTimeSlotUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    timeSlotId: ID!
}

"Autogenerated input type of OrderUpgrade"
input OrderUpgradeInput {
    answers: [QuestionInputType!]!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    upgrades: [UpgradeInputType!]!
}

"Input type for an question."
input QuestionInputType {
    name: String!
    value: Any
}

"Attributes that define a template for a ticket offering"
input RateCreateAttributes {
    "Access key for locked rates"
    accessKey: AccessKeyInputType
    "Number of tickets available"
    capacity: Int
    "Where this ticket is available"
    clientGroup: RateClientGroup
    "Description of the ticket"
    description: String
    "Rate exclusion rules"
    exclusionRules: [JSON!]
    "Maximum number of tickets allowed per order"
    maxQuantity: Int
    "Min price of the ticket (For PWYW_TICKET only)"
    minPrice: Float
    "Minimum number of tickets required per order"
    minQuantity: Int
    "Name of the ticket"
    name: String
    "Price of the ticket"
    price: Float
    "When to release purchased tickets to attendees"
    releaseOffset: ReleaseOffset
    "When the ticket is no longer available for sale"
    saleEnd: Time
    "When the ticket is available for sale"
    saleStart: Time
    "Used to specify tickets as being locked, hidden, active, etc"
    state: RateState
    "Ticket type"
    type: RateCreateType
}

"Autogenerated input type of RateCreate"
input RateCreateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    eventId: ID!
    rate: RateCreateInputType!
}

"Properties for RateCreate mutation"
input RateCreateInputType {
    attributes: RateCreateAttributes!
}

input RateCustomization_TimeslotRateCustomization {
    "Customized capacity for ticket type timeslot pair"
    capacity: Int
    "Ticket type is enabled for timeslot when true and disabled when false"
    enabled: Boolean
    "Ticket type to be customized"
    rateId: ID!
    "Event to be customized"
    timeslotId: ID!
}

"Shared updatable Rate attributes"
input RateUpdateAttributes {
    "Access key for locked rates"
    accessKey: AccessKeyInputType
    "Number of tickets available"
    capacity: Int
    "Where this ticket is available"
    clientGroup: RateClientGroup
    "Description of the ticket"
    description: String
    "Rate exclusion rules"
    exclusionRules: [JSON!]
    "Maximum number of tickets allowed per order"
    maxQuantity: Int
    "Min price of the ticket (For PWYW_TICKET only)"
    minPrice: Float
    "Minimum number of tickets required per order"
    minQuantity: Int
    "Name of the ticket"
    name: String
    "Price of the ticket"
    price: Float
    "When to release purchased tickets to attendees"
    releaseOffset: ReleaseOffset
    "When the ticket is no longer available for sale"
    saleEnd: Time
    "When the ticket is available for sale"
    saleStart: Time
    sku: String
    "Used to specify tickets as being locked, hidden, active, etc"
    state: RateState
    "Ticket type"
    type: RateCreateType
}

"Autogenerated input type of RateUpdate"
input RateUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    rate: RateUpdateInputType!
}

"Properties for RateUpdate mutation"
input RateUpdateInputType {
    attributes: RateUpdateAttributes!
    id: ID
}

"Autogenerated input type of RatesUpdate"
input RatesUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    rates: [RateUpdateInputType]!
}

"Attributes that define a template for a refund policy"
input RefundPolicyAttributes {
    "Time offset"
    offset: RefundOffset
    "Time scope"
    type: RefundOffsetType
}

"Properties for a Refund policy on event creation"
input RefundPolicyInputType {
    attributes: RefundPolicyAttributes!
}

"Used to bulk create recurring timeslots based on certain rules and intervals"
input Schedule_EventCreate {
    endDate: Date
    intervals: [Schedule_Intervals_EventCreate!]!
    startDate: Date!
    "Days of the week timeslots will be available"
    weekdaysAvailable: [Days!]
}

"Used to bulk update recurring timeslots based on certain rules and intervals"
input Schedule_EventUpdate {
    endDate: Date
    id: ID
    intervals: [Schedule_Intervals_EventUpdate!]
    startDate: Date
    "Days of the week timeslots will be available"
    weekdaysAvailable: [Days!]
}

"Each recurring timeslots start time and duration"
input Schedule_Intervals_EventCreate {
    datesToSkip: [Date!]
    "The length of the interval in seconds"
    duration: Int!
    startHour: Int!
    startMinute: Int!
}

"Each recurring timeslots start time and duration"
input Schedule_Intervals_EventUpdate {
    datesToSkip: [Date!]
    "The length of the interval in seconds"
    duration: Int
    id: ID
    startHour: Int
    startMinute: Int
}

"Autogenerated input type of SeatsPublishDraft"
input SeatsPublishDraftInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of SeatsSyncRates"
input SeatsSyncRatesInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Attributes for Tax mutation"
input TaxAttributesType {
    name: String
    percent: Float
    taxId: String
    userId: ID
}

"Autogenerated input type of TaxCreate"
input TaxCreateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    tax: TaxInputType!
}

"Properties for Tax mutation"
input TaxInputType {
    attributes: TaxAttributesType
    id: ID
}

"Autogenerated input type of TimeSlotUpdate"
input TimeSlotUpdateInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    endTime: Time
    id: ID!
    sendEmail: Boolean!
    startTime: Time
}

input TimeSlot_EventCreate {
    endAt: TimeWithoutTz!
    startAt: TimeWithoutTz!
}

input TimeSlot_EventUpdate {
    endAt: TimeWithoutTz
    id: ID
    startAt: TimeWithoutTz
}

"Autogenerated input type of TimeslotRateCustomization"
input TimeslotRateCustomizationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    eventId: ID!
    rateCustomizations: [RateCustomization_TimeslotRateCustomization!]!
}

"Autogenerated input type of TransferAccept"
input TransferAcceptInput {
    answers: [JSON!]
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    token: String!
}

"Autogenerated input type of TransferDecline"
input TransferDeclineInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    token: String!
}

"Properties for OrderUpgrade mutation"
input UpgradeInputType {
    answers: [QuestionInputType!]!
    newRateId: ID!
    orderItemId: ID!
}
