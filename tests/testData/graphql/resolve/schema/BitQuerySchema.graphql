# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
}

"Smart contract method or event"
union Signature = Event | Method

"Search result subject"
union Subject = Address | Currency | SmartContract | TransactionHash

"Account"
type Account {
    "Account ID"
    id: String!
    "Account number, the equivalent of a human-friendly public key"
    num: Int!
    "Realm number "
    realmId: Int!
    "Shard number"
    shardId: Int!
}

"Solana Action"
type Action {
    name: String!
    type: String!
}

"Blockchain address"
type Address {
    "Address"
    address: String
    "Annotations ( tags ), if exists"
    annotation: String
}

"Blockchain account with address and type"
type AddressWithAccount {
    "Account ID"
    account: String!
    "Address"
    address: String
    "Annotations ( tags ), if exists"
    annotation: String
    "Account type"
    type: String!
}

"Algorand Blockchain"
type Algorand {
    "Basic information about address ( or smart contract )"
    address(address: [AddressSelectorIn!]!): [AlgorandAddressInfo!]!
    "Arguments of Smart Contract Calls and Events"
    arguments(any: [AlgorandArgumentFilter!], argindex: ArgumentIndexSelector, argument: [ArgumentSelector!], caller: [AddressSelector!], date: DateSelector, height: BlockSelector, options: QueryOptions, reference: [AddressSelector!], smartContractAddress: [AddressSelector!], time: DateTimeSelector, txFrom: [AddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, value: [ArgumentValueSelector!]): [AlgorandArguments!]
    "Blockchain Blocks"
    blocks(any: [AlgorandBlockFilter!], blockHash: HashSelector, blockReward: [AmountSelector!], currentProtocol: StringIdSelector, date: DateSelector, height: BlockSelector, nextProtocol: StringIdSelector, options: QueryOptions, proposer: [AddressSelector!], time: DateTimeSelector): [AlgorandBlocks!]
    "Money flow using Coinpath technology"
    coinpath(currency: [AlgorandCurrencySelector!], date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [AlgorandCoinpath!]
    "Smart Contract Calls"
    smartContractCalls(any: [AlgorandSmartContractCallFilter!], date: DateSelector, height: BlockSelector, options: QueryOptions, smartContractAddress: [AddressSelector!], time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txType: TxTypeSelector): [AlgorandSmartContractCalls!]
    "Blockchain Transactions"
    transactions(any: [AlgorandTransactionFilter!], date: DateSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector, txCurrency: [AlgorandCurrencySelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txSubtype: TxSubtypeSelector, txType: TxTypeSelector): [AlgorandTransactions!]
    "Currency Transfers"
    transfers(amount: [AmountSelector!], any: [AlgorandTransferFilter!], currency: [AlgorandCurrencySelector!], date: DateSelector, height: BlockSelector, options: QueryOptions, receiver: [AddressSelector!], sender: [AddressSelector!], time: DateTimeSelector, transferType: AlgorandTransferTypeSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txType: TxTypeSelector): [AlgorandTransfers!]
}

"Address detailed information for Algorand network"
type AlgorandAddressInfo {
    "Address"
    address: Address
    "Current address balance"
    balance: Float
    "Current pending rewards"
    pendingRewards: Float
    "Current rewards"
    rewards: Float
    "Current round"
    round: String
    "Smart Contract if exists on the address"
    smartContract: AlgorandSmartContract
    "Current status"
    status: String
}

"Arguments of Smart Contract Calls"
type AlgorandArguments {
    any(of: AlgorandArgumentsMeasureable!): String
    "Sequential index of value in array ( multi-dimensional)"
    argindex: Int!
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Counts and other metrics"
    count(argindex: ArgumentIndexSelector, argument: [ArgumentSelector!], caller: [AddressSelector!], date: DateSelector, height: BlockSelector, reference: [AddressSelector!], smartContractAddress: [AddressSelector!], time: DateTimeSelector, txFrom: [AddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, uniq: SmartContractCallsUniq, value: [ArgumentValueSelector!]): Int
    "Counts and other metrics"
    countBigInt(argindex: ArgumentIndexSelector, argument: [ArgumentSelector!], caller: [AddressSelector!], date: DateSelector, height: BlockSelector, reference: [AddressSelector!], smartContractAddress: [AddressSelector!], time: DateTimeSelector, txFrom: [AddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, uniq: SmartContractCallsUniq, value: [ArgumentValueSelector!]): BigInt
    "Calendar date"
    date: Date
    firstRound: Int
    genesisHash64: String
    genesisId: String
    lastRound: Int
    maximum(get: AlgorandArgumentsMeasureable, of: AlgorandArgumentsMeasureable!): String
    minimum(get: AlgorandArgumentsMeasureable, of: AlgorandArgumentsMeasureable!): String
    note: String
    poolerror: String
    "Smart contract being called"
    smartContract(smartContractAddress: [AddressSelector!]): AlgorandSmartContract
    "Transaction where call happened"
    transaction(txFrom: [AddressSelector!], txHash: [HashSelector!]): TransactionHashIndex
    "Transaction sender"
    txSender(txSender: [AddressSelector!]): Address
    "Transaction type in which the transfer happened"
    txType(txType: [AlgorandTxType!]): AlgorandTxType
    "The Value of argument"
    value(value: [ArgumentValueSelector!]): String
}

"Blocks in Algorand blockchain"
type AlgorandBlocks {
    any(of: AlgorandBlocksMeasureable!): String
    count(blockHash: HashSelector, blockReward: [AmountSelector!], currentProtocol: StringIdSelector, date: DateSelector, height: BlockSelector, nextProtocol: StringIdSelector, proposer: [AddressSelector!], time: DateTimeSelector, uniq: AlgorandBlocksUniq): Int
    countBigInt(blockHash: HashSelector, blockReward: [AmountSelector!], currentProtocol: StringIdSelector, date: DateSelector, height: BlockSelector, nextProtocol: StringIdSelector, proposer: [AddressSelector!], time: DateTimeSelector, uniq: AlgorandBlocksUniq): BigInt
    currentProtocol: String
    "Calendar date"
    date: Date
    frac: BigInt!
    "Block hash"
    hash(blockHash: [HashSelector!]): String!
    "Block number (height) in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: AlgorandBlocksMeasureable, of: AlgorandBlocksMeasureable!): String
    minimum(get: AlgorandBlocksMeasureable, of: AlgorandBlocksMeasureable!): String
    nextProtocol: String
    nextProtocolApprovals: BigInt
    nextProtocolSwitchOn: BigInt
    nextProtocolVoteBefore: BigInt
    "Previous block hash"
    previousBlockHash: String!
    "Block proposer"
    proposer(proposer: [AddressSelector!]): Address
    rate(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, currentProtocol: StringIdSelector, date: DateSelector, height: BlockSelector, nextProtocol: StringIdSelector, proposer: [AddressSelector!], time: DateTimeSelector): Float
    reward(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, currentProtocol: StringIdSelector, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, nextProtocol: StringIdSelector, proposer: [AddressSelector!], time: DateTimeSelector): Float
    seed: String
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    txnRoot: String!
    upgradeApprove: Int
    upgradePropose: String
}

"Coinpath"
type AlgorandCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: Address
    "Sender address"
    sender: Address
    "Transaction of transfer happened"
    transaction: TransactionHashValue
}

"Algorand smart contract"
type AlgorandSmartContract {
    "Smart Contract Address"
    address: Address!
    "Smart Contract byte code"
    bytecode: String
    "Smart Contract Deassembled source code"
    source: String
}

"Smart Contract Calls"
type AlgorandSmartContractCalls {
    any(of: AlgorandCallsMeasureable!): String
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Counts and other metrics"
    count(date: DateSelector, height: BlockSelector, smartContractAddress: [AddressSelector!], time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txType: TxTypeSelector, uniq: SmartContractCallsUniq): Int
    "Counts and other metrics"
    countBigInt(date: DateSelector, height: BlockSelector, smartContractAddress: [AddressSelector!], time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txType: TxTypeSelector, uniq: SmartContractCallsUniq): BigInt
    "Calendar date"
    date: Date
    "Fee used in transaction call"
    fee(calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, smartContractAddress: [AddressSelector!], time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txType: TxTypeSelector): Float
    firstRound: Int
    genesisHash64: String
    genesisId: String
    lastRound: Int
    maximum(get: AlgorandCallsMeasureable, of: AlgorandCallsMeasureable!): String
    minimum(get: AlgorandCallsMeasureable, of: AlgorandCallsMeasureable!): String
    note: String
    poolerror: String
    "Smart contract being called"
    smartContract(smartContractAddress: [AddressSelector!]): AlgorandSmartContract
    "Transaction where call happened"
    transaction(txFrom: [AddressSelector!], txHash: [HashSelector!]): TransactionHashIndex
    "Transaction sender"
    txSender(txSender: [AddressSelector!]): Address
    "Transaction type in which the transfer happened"
    txType(txType: [AlgorandTxType!]): AlgorandTxType
}

"Algorand transaction with attributes"
type AlgorandTransactionWithAttributes {
    "Block of the Output Transaction for this input"
    block: Int
    "Transaction fee"
    fee: Float
    firstRound: Int
    "Transaction rewards ( from ) "
    fromrewards: Float
    "Hash hex representation"
    hash: String!
    "Transaction index in block, 0-based"
    index: String!
    lastRound: Int
    lease: String
    note: String
    poolerror: String
    "Transfer transaction sender"
    sender: Address
    "Transaction sub type"
    subtype: AlgorandTxSubType
    "Transaction type in which the transfer happened"
    type: AlgorandTxType
}

"Transactions in Algorand blockchain"
type AlgorandTransactions {
    any(of: AlgorandTransactionsMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(date: DateSelector, height: BlockSelector, time: DateTimeSelector, txCurrency: [AlgorandCurrencySelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txSubtype: TxSubtypeSelector, txType: TxTypeSelector, uniq: AlgorandTransactionsUniq): Int
    countBigInt(date: DateSelector, height: BlockSelector, time: DateTimeSelector, txCurrency: [AlgorandCurrencySelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txSubtype: TxSubtypeSelector, txType: TxTypeSelector, uniq: AlgorandTransactionsUniq): BigInt
    "Asset related to transaction"
    currency(txCurrency: [AlgorandCurrencySelector!]): Currency
    "Calendar date"
    date: Date
    fee(calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, time: DateTimeSelector, txCurrency: [AlgorandCurrencySelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txSubtype: TxSubtypeSelector, txType: TxTypeSelector): Float
    firstRound: Int
    genesisHash: String
    genesisId: String
    "Hash hex representation"
    hash(txHash: [HashSelector!]): String!
    "Transaction index in block, 0 based"
    index(txIndex: [TxIndexSelector!]): Int
    lastRound: Int
    maximum(get: AlgorandTransactionsMeasureable, of: AlgorandTransactionsMeasureable!): String
    minimum(get: AlgorandTransactionsMeasureable, of: AlgorandTransactionsMeasureable!): String
    note: String
    poolerror: String
    "Transaction sender"
    sender(txSender: [AddressSelector!]): Address
    "Transaction sub type"
    subtype(txType: TxSubtypeSelector): AlgorandTxSubType
    "Transaction type"
    type(txType: TxTypeSelector): AlgorandTxType
}

"Currency transfers from/to addresses in crypto currencies"
type AlgorandTransfers {
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, currency: [AlgorandCurrencySelector!], date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, receiver: [AddressSelector!], sender: [AddressSelector!], time: DateTimeSelector, transferType: AlgorandTransferTypeSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txType: TxTypeSelector): Float
    any(of: AlgorandTransfersMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(amount: [AmountSelector!], currency: [AlgorandCurrencySelector!], date: DateSelector, height: BlockSelector, receiver: [AddressSelector!], sender: [AddressSelector!], time: DateTimeSelector, transferType: AlgorandTransferTypeSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txType: TxTypeSelector, uniq: TransfersUniq): Int
    countBigInt(amount: [AmountSelector!], currency: [AlgorandCurrencySelector!], date: DateSelector, height: BlockSelector, receiver: [AddressSelector!], sender: [AddressSelector!], time: DateTimeSelector, transferType: AlgorandTransferTypeSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], txType: TxTypeSelector, uniq: TransfersUniq): BigInt
    "Currency of transfer"
    currency(currency: [AlgorandCurrencySelector!]): Currency
    "Calendar date"
    date: Date
    firstRound: Int
    lastRound: Int
    maximum(get: AlgorandTransfersMeasureable, of: AlgorandTransfersMeasureable!): String
    memo: String
    minimum(get: AlgorandTransfersMeasureable, of: AlgorandTransfersMeasureable!): String
    "Transfer receiver"
    receiver(receiver: [AddressSelector!]): Address
    "Transfer sender"
    sender(sender: [AddressSelector!]): Address
    "Transaction where transfer happened"
    transaction(txHash: [HashSelector!]): AlgorandTransactionWithAttributes
    "Transfer Type"
    transferType(transferType: [AlgorandTransferType!]): AlgorandTransferType
}

"Argument of Smart contract method or event"
type ArgumentName {
    "Name"
    name: String!
    "Type"
    type: String!
}

"Argument name and value of smart contract call or event"
type ArgumentNameValue {
    "Argument name"
    argument: String!
    "Argument data type"
    argumentType: String!
    "Sequential index of value in array ( multi-dimensional)"
    index: String!
    "Value as String"
    value: String!
}

"Argument value of smart contract call or event"
type ArgumentValue {
    "Value as Address"
    address: EthereumAddressInfo
    "Value as String"
    value: String!
}

"Binance DEX"
type Binance {
    "Binance DEX Network Blocks"
    blocks(any: [BinanceBlockFilter!], blockId: StringIdSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector, validatorFeeAddr: BinanceAddressSelector, validatorMoniker: StringIdSelector, validatorOperahraddress: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector): [BinanceBlock!]
    "Money flow using Coinpath technology"
    coinpath(currency: [BinanceCurrencySelector!], date: DateSelector, depth: IntegerLimitedSelector, initialAddress: BinanceAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: BinanceAddressSelector, sender: BinanceAddressSelector, time: DateTimeSelector): [BinanceCoinpath!]
    "Binance DEX Network Exchange Orders"
    orders(any: [BinanceOrderFilter!], baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], date: DateSelector, height: BlockSelector, options: QueryOptions, orderId: [OrderIdSelector!], orderOwner: [BinanceAddressSelector!], orderSide: [OrderSideSelector!], orderStatus: [OrderStatusSelector!], orderTimeInForce: [OrderTimeInForceSelector!], orderType: [OrderTypeSelector!], price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], time: DateTimeSelector, txHash: HashSelector): [BinanceOrders!]
    "Binance DEX Network Trades between currencies"
    trades(any: [BinanceTradeFilter!], baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], buyOrderId: [OrderIdSelector!], buyer: [BinanceAddressSelector!], date: DateSelector, height: BlockSelector, options: QueryOptions, price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], sellOrderId: [OrderIdSelector!], seller: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], txHash: HashSelector): [BinanceTrades!]
    "Binance DEX Network Transactions"
    transactions(any: [BinanceTransactionFilter!], currency: [BinanceCurrencySelector!], date: DateSelector, deposit: [AmountSelector!], height: BlockSelector, options: QueryOptions, proposalId: StringIdSelector, time: DateTimeSelector, transactionCode: IntIdSelector, transactionSource: IntIdSelector, transactionType: BinanceTransactionTypeSelector, txHash: HashSelector): [BinanceTransactions!]
    "Binance DEX Network Currency Transfers"
    transfers(amount: [AmountSelector!], any: [BinanceTransferFilter!], currency: [BinanceCurrencySelector!], date: DateSelector, height: BlockSelector, options: QueryOptions, orderId: [OrderIdSelector!], outputIndex: [OutputIndexSelector!], receiver: [BinanceAddressSelector!], sender: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], transferType: [BinanceTransferTypeSelector!], txHash: HashSelector): [BinanceTransfers!]
}

"Block"
type BinanceBlock {
    any(of: BinanceBlocksMeasureable!): String
    "Block ID"
    blockId(blockId: StringIdSelector): String
    count(blockId: StringIdSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: BinanceBlockUniq, validatorFeeAddr: BinanceAddressSelector, validatorMoniker: StringIdSelector, validatorOperahraddress: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector): Int
    countBigInt(blockId: StringIdSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: BinanceBlockUniq, validatorFeeAddr: BinanceAddressSelector, validatorMoniker: StringIdSelector, validatorOperahraddress: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector): BigInt
    "Calendar date"
    date: Date
    "Block number (height) in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: BinanceBlocksMeasureable, of: BinanceBlocksMeasureable!): String
    minimum(get: BinanceBlocksMeasureable, of: BinanceBlocksMeasureable!): String
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "Validator consensus pubkey"
    validatorConsensusPubkey(validatorConsensusPubkey: StringIdSelector): String
    "Validator fee address"
    validatorFeeAddr(validatorFeeAddr: BinanceAddressSelector): Address
    "Validator moniker"
    validatorMoniker(validatorMoniker: StringIdSelector): String
    "Validator operator HR address"
    validatorOperaHrAddress(validatorOperaHrAddress: BinanceAddressSelector): Address
    "Validator operator address"
    validatorOperatorAddress(validatorOperatorAddress: BinanceAddressSelector): Address
}

"Coinpath"
type BinanceCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: Address
    "Sender address"
    sender: Address
    "Transaction of transfer happened"
    transaction: TransactionHashValue
}

"Binance DEX Order"
type BinanceOrders {
    any(of: BinanceOrdersMeasureable!): String
    baseAmount(baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, orderId: [OrderIdSelector!], orderOwner: [BinanceAddressSelector!], orderSide: [OrderSideSelector!], orderStatus: [OrderStatusSelector!], orderTimeInForce: [OrderTimeInForceSelector!], orderType: [OrderTypeSelector!], price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], time: DateTimeSelector, txHash: HashSelector): Float
    baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency
    "Block where order transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], date: DateSelector, height: BlockSelector, orderId: [OrderIdSelector!], orderOwner: [BinanceAddressSelector!], orderSide: [OrderSideSelector!], orderStatus: [OrderStatusSelector!], orderTimeInForce: [OrderTimeInForceSelector!], orderType: [OrderTypeSelector!], price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], time: DateTimeSelector, txHash: HashSelector, uniq: BinanceOrdersUniq): Int
    countBigInt(baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], date: DateSelector, height: BlockSelector, orderId: [OrderIdSelector!], orderOwner: [BinanceAddressSelector!], orderSide: [OrderSideSelector!], orderStatus: [OrderStatusSelector!], orderTimeInForce: [OrderTimeInForceSelector!], orderType: [OrderTypeSelector!], price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], time: DateTimeSelector, txHash: HashSelector, uniq: BinanceOrdersUniq): BigInt
    "Calendar date"
    date: Date
    maximum(get: BinanceOrdersMeasureable, of: BinanceOrdersMeasureable!): String
    minimum(get: BinanceOrdersMeasureable, of: BinanceOrdersMeasureable!): String
    "Order ID"
    orderId(orderId: [OrderIdSelector!]): String
    "Order owner address"
    orderOwner(owner: [BinanceAddressSelector!]): Address
    "Order Side"
    orderSide(orderSide: [OrderSideSelector!]): BinanceOrderSide
    "Order Status"
    orderStatus(orderStatus: [OrderStatusSelector!]): BinanceOrderStatus
    "Order Time In Force"
    orderTimeInForce(orderTimeInForce: [OrderTimeInForceSelector!]): BinanceOrderTimeInForce
    "Order Type"
    orderType(orderType: [OrderTypeSelector!]): BinanceOrderType
    price: Float
    quoteAmount(baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, orderId: [OrderIdSelector!], orderOwner: [BinanceAddressSelector!], orderSide: [OrderSideSelector!], orderStatus: [OrderStatusSelector!], orderTimeInForce: [OrderTimeInForceSelector!], orderType: [OrderTypeSelector!], price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], time: DateTimeSelector, txHash: HashSelector): Float
    quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency
    "Transaction where order created"
    transaction(txHash: [HashSelector!]): TransactionHash
}

"Binance DEX Trades"
type BinanceTrades {
    any(of: BinanceTradesMeasureable!): String
    baseAmount(baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], buyOrderId: [OrderIdSelector!], buyer: [BinanceAddressSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], sellOrderId: [OrderIdSelector!], seller: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], txHash: HashSelector): Float
    baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency
    "Block where trade transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Buy Order ID"
    buyOrderId(buyOrderId: [OrderIdSelector!]): String
    "Trade buyer address"
    buyer(buyer: [BinanceAddressSelector!]): Address
    count(baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], buyOrderId: [OrderIdSelector!], buyer: [BinanceAddressSelector!], date: DateSelector, height: BlockSelector, price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], sellOrderId: [OrderIdSelector!], seller: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], txHash: HashSelector, uniq: BinanceTradesUniq): Int
    countBigInt(baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], buyOrderId: [OrderIdSelector!], buyer: [BinanceAddressSelector!], date: DateSelector, height: BlockSelector, price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], sellOrderId: [OrderIdSelector!], seller: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], txHash: HashSelector, uniq: BinanceTradesUniq): BigInt
    "Calendar date"
    date: Date
    maximum(get: BinanceTradesMeasureable, of: BinanceTradesMeasureable!): String
    minimum(get: BinanceTradesMeasureable, of: BinanceTradesMeasureable!): String
    price: Float
    quoteAmount(baseAmount: [AmountSelector!], baseCurrency: [BinanceCurrencySelector!], buyOrderId: [OrderIdSelector!], buyer: [BinanceAddressSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, price: [AmountSelector!], quoteAmount: [AmountSelector!], quoteCurrency: [BinanceCurrencySelector!], sellOrderId: [OrderIdSelector!], seller: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], txHash: HashSelector): Float
    quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency
    "Sell Order ID"
    sellOrderId(sellOrderId: [OrderIdSelector!]): String
    "Trade seller address"
    seller(seller: [BinanceAddressSelector!]): Address
    "Trade ID"
    tradeId(tradeId: [TradeIdSelector!]): String
    "Transaction where trade happened"
    transaction(txHash: [HashSelector!]): TransactionHashIndex
}

"Transaction"
type BinanceTransactions {
    any(of: BinanceTransactionsMeasureable!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(currency: [BinanceCurrencySelector!], date: DateSelector, deposit: [AmountSelector!], height: BlockSelector, proposalId: StringIdSelector, time: DateTimeSelector, transactionCode: IntIdSelector, transactionSource: IntIdSelector, transactionType: BinanceTransactionTypeSelector, txHash: HashSelector, uniq: BinanceTransactionsUniq): Int
    countBigInt(currency: [BinanceCurrencySelector!], date: DateSelector, deposit: [AmountSelector!], height: BlockSelector, proposalId: StringIdSelector, time: DateTimeSelector, transactionCode: IntIdSelector, transactionSource: IntIdSelector, transactionType: BinanceTransactionTypeSelector, txHash: HashSelector, uniq: BinanceTransactionsUniq): BigInt
    "Currency issued in transaction"
    currency(currency: [BinanceCurrencySelector!]): Currency
    "Calendar date"
    date: Date
    "Deposit amount in transaction"
    deposit(deposit: [AmountSelector!]): Float
    "Transaction Description"
    description: String
    "Hash hex representation"
    hash(txHash: [HashSelector!]): String!
    "TX index in block, 0 based"
    index: Int
    "Transaction Log"
    log: String
    maximum(get: BinanceTransactionsMeasureable, of: BinanceTransactionsMeasureable!): String
    "Transaction Memo"
    memo: String
    minimum(get: BinanceTransactionsMeasureable, of: BinanceTransactionsMeasureable!): String
    "Proposal ID"
    proposalId(proposalId: [IntIdSelector!]): Int
    "Transaction Type"
    transactionCode(transactionCode: IntIdSelector): Int
    "Transaction Source"
    transactionSource(transactionSource: IntIdSelector): TransactionSource
    "Transaction Type"
    transactionType(transactionType: [BinanceTransactionTypeSelector!]): BinanceTransactionType
}

"Currency transfers from/to addresses in crypto currencies"
type BinanceTransfers {
    "Transfer amount"
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, currency: [BinanceCurrencySelector!], date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, orderId: [OrderIdSelector!], outputIndex: [OutputIndexSelector!], receiver: [BinanceAddressSelector!], sender: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], transferType: [BinanceTransferTypeSelector!], txHash: HashSelector): Float
    any(of: BinanceTransfersMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Transfer count"
    count(amount: [AmountSelector!], currency: [BinanceCurrencySelector!], date: DateSelector, height: BlockSelector, orderId: [OrderIdSelector!], outputIndex: [OutputIndexSelector!], receiver: [BinanceAddressSelector!], sender: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], transferType: [BinanceTransferTypeSelector!], txHash: HashSelector, uniq: TransfersUniq): Int
    "Transfer count"
    countBigInt(amount: [AmountSelector!], currency: [BinanceCurrencySelector!], date: DateSelector, height: BlockSelector, orderId: [OrderIdSelector!], outputIndex: [OutputIndexSelector!], receiver: [BinanceAddressSelector!], sender: [BinanceAddressSelector!], time: DateTimeSelector, tradeId: [TradeIdSelector!], transferType: [BinanceTransferTypeSelector!], txHash: HashSelector, uniq: TransfersUniq): BigInt
    "Currency of transfer"
    currency(currency: [BinanceCurrencySelector!]): Currency
    "Calendar date"
    date: Date
    maximum(get: BinanceTransfersMeasureable, of: BinanceTransfersMeasureable!): String
    minimum(get: BinanceTransfersMeasureable, of: BinanceTransfersMeasureable!): String
    "Order Id of trade where transfer happened"
    orderId(orderId: [OrderIdSelector!]): String
    "Index of the output for the transfer, 0-based"
    outputIndex(outputIndex: [OutputIndexSelector!]): Int
    "Transfer receiver"
    receiver(receiver: [BinanceAddressSelector!]): Address
    "Transfer sender"
    sender(sender: [BinanceAddressSelector!]): Address
    "Id of trade where transfer happened"
    tradeId(tradeId: [TradeIdSelector!]): String
    "Transaction where transfer happened"
    transaction(txHash: [HashSelector!]): TransactionHashIndex
    "Transfer type"
    transferType(transferType: [BinanceTransferTypeSelector!]): BinanceTransferType
}

"Bitcoin and other UTXO type blockchains"
type Bitcoin {
    "Blockchain Blocks"
    blocks(any: [BitcoinBlockFilter!], blockHash: StringIdSelector, blockSize: IntegerSelector, blockStrippedSize: IntegerSelector, blockVersion: IntegerSelector, blockWeight: IntegerSelector, date: DateSelector, difficulty: FloatSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector, transactionCount: IntegerSelector): [BitcoinBlock!]
    "Money flow using Coinpath technology"
    coinpath(date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: BitcoinCoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [BitcoinCoinpath!]
    "Blockchain Transaction Inputs"
    inputs(any: [BitcoinInputFilter!], date: DateSelector, height: BlockSelector, inOutputIndex: IntegerSelector, inOutputTxId: HashSelector, inputAddress: AddressSelector, inputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector, options: QueryOptions, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector): [BitcoinTransactionInput!]
    "Blockchain Transaction OmniTransactions"
    omniTransactions(any: [BitcoinOmniTransactionsFilter!], date: DateSelector, feeValue: FloatSelector, height: BlockSelector, invalidReason: StringSelector, options: QueryOptions, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSender: HashSelector, type: StringSelector, typeId: IntegerSelector, valid: IntegerSelector, version: IntegerSelector): [BitcoinOmniTransactiosn!]
    "Blockchain Transaction OmniTransfers"
    omniTransfers(any: [BitcoinOmniTransfersFilter!], date: DateSelector, feeValue: FloatSelector, height: BlockSelector, invalidReason: StringSelector, options: QueryOptions, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSender: HashSelector, type: StringSelector, typeId: IntegerSelector, valid: IntegerSelector, version: IntegerSelector): [BitcoinOmniTransfers!]
    "Blockchain Transaction Outputs"
    outputs(any: [BitcoinOutputFilter!], date: DateSelector, height: BlockSelector, options: QueryOptions, outputAddress: AddressSelector, outputDirection: BitcoinOutputDirectionSelector, outputIndex: IntegerSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector): [BitcoinTransactionOutput!]
    "Blockchain Transactions"
    transactions(any: [BitcoinTransactionFilter!], date: DateSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, options: QueryOptions, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): [BitcoinTransaction!]
}

"Block"
type BitcoinBlock {
    any(of: BitcoinBlocksMeasureable!): String
    "Block Hash"
    blockHash(blockHash: StringIdSelector): String
    "Block size"
    blockSize(blockSize: IntegerSelector): Int
    "Block stripped size"
    blockStrippedSize(blockStrippedSize: IntegerSelector): Int
    "Block version"
    blockVersion(blockVersion: IntegerSelector): Int
    "Block weight"
    blockWeight(blockWeight: IntegerSelector): Int
    "Block chainwork"
    chainwork: String
    count(blockHash: StringIdSelector, blockSize: IntegerSelector, blockStrippedSize: IntegerSelector, blockVersion: IntegerSelector, blockWeight: IntegerSelector, date: DateSelector, difficulty: FloatSelector, height: BlockSelector, time: DateTimeSelector, txCount: IntegerSelector, uniq: BitcoinBlockUniq): Int
    countBigInt(blockHash: StringIdSelector, blockSize: IntegerSelector, blockStrippedSize: IntegerSelector, blockVersion: IntegerSelector, blockWeight: IntegerSelector, date: DateSelector, difficulty: FloatSelector, height: BlockSelector, time: DateTimeSelector, txCount: IntegerSelector, uniq: BitcoinBlockUniq): BigInt
    "Calendar date"
    date: Date
    "Difficulty"
    difficulty(difficulty: FloatSelector): Float
    "Block number (height) in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: BitcoinBlocksMeasureable, of: BitcoinBlocksMeasureable!): String
    "Block median timestamp"
    medianTime: DateTime
    minimum(get: BitcoinBlocksMeasureable, of: BitcoinBlocksMeasureable!): String
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "Transaction count in block"
    transactionCount(transactionCount: IntegerSelector): Int
}

"Coinpath"
type BitcoinCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: Address
    "Sender address"
    sender: Address
    "Transaction of transfer happened"
    transaction: BitcoinTransactionHashIndexValues
    "Attributes of transaction included in Coinpath result"
    transactions: [CoinpathEntry!]
}

"OmniTransactions"
type BitcoinOmniTransactiosn {
    any(of: BitcoinOmniTransactionsMeasureablse!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Hash of the block"
    blockHash(blockHash: HashSelector): String!
    "OmniTransaction s count"
    count(date: DateSelector, feeValue: FloatSelector, height: BlockSelector, invalidReason: StringSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSender: HashSelector, type: StringSelector, typeId: IntegerSelector, uniq: BitcoinOmniTransactionsUniq, valid: IntegerSelector, version: IntegerSelector): Int
    "OmniTransaction s count"
    countBigInt(date: DateSelector, feeValue: FloatSelector, height: BlockSelector, invalidReason: StringSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSender: HashSelector, type: StringSelector, typeId: IntegerSelector, uniq: BitcoinOmniTransactionsUniq, valid: IntegerSelector, version: IntegerSelector): BigInt
    "Calendar date"
    date: Date
    "Transactions total fee value"
    feeValue(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, invalidReason: StringSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSender: HashSelector, type: StringSelector, typeId: IntegerSelector, valid: IntegerSelector, version: IntegerSelector): Float
    "Hash hex representation"
    hash(txHash: StringIdSelector): String!
    "OmniTransactions index in block, 0-based"
    index(txIndex: IntegerSelector): String!
    "Invalid Reason"
    invalidReason(invalidReason: StringSelector): String!
    "Invalid Reason"
    json(json: StringSelector): String!
    maximum(get: BitcoinOmniTransactionsMeasureablse, of: BitcoinOmniTransactionsMeasureablse!): String
    minimum(get: BitcoinOmniTransactionsMeasureablse, of: BitcoinOmniTransactionsMeasureablse!): String
    "Transaction Sender"
    txSender(txSender: HashSelector): String!
    "Type"
    type(type: StringSelector): String!
    "Type Int"
    typeInt(typeInt: IntegerSelector): Int!
    "Version"
    valid(valid: IntegerSelector): Int!
    "Version"
    version(version: IntegerSelector): Int!
}

"OmniTransfers"
type BitcoinOmniTransfers {
    any(of: BitcoinOmniTransfersMeasureablse!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Hash of the block"
    blockHash(blockHash: HashSelector): String!
    "Transaction s count"
    count(date: DateSelector, feeValue: FloatSelector, height: BlockSelector, invalidReason: StringSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSender: HashSelector, type: StringSelector, typeId: IntegerSelector, uniq: BitcoinOmniTransfersUniq, valid: IntegerSelector, version: IntegerSelector): Int
    "Transaction s count"
    countBigInt(date: DateSelector, feeValue: FloatSelector, height: BlockSelector, invalidReason: StringSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSender: HashSelector, type: StringSelector, typeId: IntegerSelector, uniq: BitcoinOmniTransfersUniq, valid: IntegerSelector, version: IntegerSelector): BigInt
    "Currency of transfer"
    currency: Currency
    "Calendar date"
    date: Date
    "Direction"
    direction(direction: StringSelector): String
    "Divisible"
    divisible(divisible: IntegerSelector): Int
    "Transactions total fee value"
    feeValue(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, invalidReason: StringSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSender: HashSelector, type: StringSelector, typeId: IntegerSelector, valid: IntegerSelector, version: IntegerSelector): Float
    "Hash hex representation"
    hash(txHash: StringIdSelector): String!
    "Transactions index in block, 0-based"
    index(txIndex: IntegerSelector): String!
    "Ismine"
    ismine(ismine: IntegerSelector): Int
    maximum(get: BitcoinOmniTransfersMeasureablse, of: BitcoinOmniTransfersMeasureablse!): String
    minimum(get: BitcoinOmniTransfersMeasureablse, of: BitcoinOmniTransfersMeasureablse!): String
    "Transfer From"
    transferFrom(transferFrom: HashSelector): String!
    "Transfer From"
    transferTo(transferTo: HashSelector): String!
    "Transaction Sender"
    txSender(txSender: HashSelector): String!
    "Type"
    type(type: StringSelector): String!
    "Type Int"
    typeInt(typeInt: IntegerSelector): Int!
    "value"
    value(value: FloatSelector): Float
}

"Transaction"
type BitcoinTransaction {
    any(of: BitcoinTransactionsMeasureable!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Transaction  count"
    count(date: DateSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, uniq: BitcoinTransactionUniq): Int
    "Transaction  count"
    countBigInt(date: DateSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, uniq: BitcoinTransactionUniq): BigInt
    "Calendar date"
    date: Date
    "Transaction total fee value"
    feeValue(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): Float
    "Hash hex representation"
    hash(txHash: StringIdSelector): String!
    "Transaction index in block, 0-based"
    index(txIndex: IntegerSelector): String!
    "Transaction total input count"
    inputCount(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): Int
    "Transaction total input count"
    inputCountbigint(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): BigInt
    "Transaction total input value"
    inputValue(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): Float
    maximum(get: BitcoinTransactionsMeasureable, of: BitcoinTransactionsMeasureable!): String
    "Transaction total mined value"
    minedValue(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): Float
    minimum(get: BitcoinTransactionsMeasureable, of: BitcoinTransactionsMeasureable!): String
    "Transaction total output count"
    outputCount(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): Int
    "Transaction total output count"
    outputCountbigint(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): BigInt
    "Transaction total output value"
    outputValue(calculate: AmountAggregateFunction, date: DateSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, minedValue: FloatSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txCoinbase: Boolean, txHash: HashSelector, txIndex: IntegerSelector, txLocktime: IntegerSelector, txSize: IntegerSelector, txVersion: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector): Float
    "Transaction is coinbase"
    txCoinbase(txCoinbase: Boolean): Boolean
    "Transaction locktime"
    txLocktime(txLocktime: IntegerSelector): BigInt
    "Transaction size"
    txSize(txSize: IntegerSelector): Int
    "Transaction version"
    txVersion(txVersion: IntegerSelector): Int
    "Transaction vsize"
    txVsize(txVsize: IntegerSelector): Int
    "Transaction weight"
    txWeight(txWeight: IntegerSelector): Int
}

"Blockchain transaction"
type BitcoinTransactionHashIndexValues {
    "Hash hex representation"
    hash: String!
    "Transaction index in block, 0-based"
    index: String!
    "Transaction value in input"
    valueIn: Float!
    "Transaction value in output"
    valueOut: Float!
}

"Transaction Input"
type BitcoinTransactionInput {
    any(of: BitcoinInputsMeasureable!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Input count"
    count(date: DateSelector, height: BlockSelector, inOutputIndex: IntegerSelector, inOutputTxId: HashSelector, inputAddress: AddressSelector, inputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: BitcoinInputUniq): Int
    "Input count"
    countBigInt(date: DateSelector, height: BlockSelector, inOutputIndex: IntegerSelector, inOutputTxId: HashSelector, inputAddress: AddressSelector, inputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: BitcoinInputUniq): BigInt
    "Calendar date"
    date: Date
    "Input address"
    inputAddress(inputAddress: AddressSelector): Address
    "Input index"
    inputIndex(inputIndex: IntegerSelector): Int
    "Input script"
    inputScript: String
    "Input script type and attributes"
    inputScriptType(inputScriptType: BitcoinInputScriptTypeSelector): InputScript
    maximum(get: BitcoinInputsMeasureable, of: BitcoinInputsMeasureable!): String
    minimum(get: BitcoinInputsMeasureable, of: BitcoinInputsMeasureable!): String
    "Output Transaction for this input"
    outputTransaction(inOutputIndex: IntegerSelector, inOutputTxId: StringIdSelector): TransactionHashIndex
    "Transaction ID Hash"
    transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
    "Input value"
    value(calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, inOutputIndex: IntegerSelector, inOutputTxId: HashSelector, inputAddress: AddressSelector, inputIndex: IntegerSelector, inputScriptType: BitcoinInputScriptTypeSelector, inputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector): Float
}

"Transaction Output"
type BitcoinTransactionOutput {
    any(of: BitcoinOutputsMeasureable!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Output count"
    count(date: DateSelector, height: BlockSelector, outputAddress: AddressSelector, outputDirection: BitcoinOutputDirectionSelector, outputIndex: IntegerSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: BitcoinOutputUniq): Int
    "Output count"
    countBigInt(date: DateSelector, height: BlockSelector, outputAddress: AddressSelector, outputDirection: BitcoinOutputDirectionSelector, outputIndex: IntegerSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: BitcoinOutputUniq): BigInt
    "Calendar date"
    date: Date
    maximum(get: BitcoinOutputsMeasureable, of: BitcoinOutputsMeasureable!): String
    minimum(get: BitcoinOutputsMeasureable, of: BitcoinOutputsMeasureable!): String
    "Output address"
    outputAddress(outputAddress: AddressSelector): Address
    "Output guessed direction"
    outputDirection(outputDirection: BitcoinOutputDirectionSelector): BitcoinOutputDirection
    "Output index"
    outputIndex(outputIndex: IntegerSelector): Int
    "Output script"
    outputScript: String
    "Output script type and attributes"
    outputScriptType(inputScriptType: BitcoinOutputScriptTypeSelector): OutputScript
    reqSigs: Int
    "Transaction ID Hash"
    transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
    "Output value"
    value(calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, outputAddress: AddressSelector, outputDirection: BitcoinOutputDirectionSelector, outputIndex: IntegerSelector, outputScriptType: BitcoinOutputScriptTypeSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector): Float
}

"Block"
type Block {
    "Block number (height) in blockchain"
    height: Int!
    "Block timestamp"
    timestamp: DateTime
}

"BlockExtended"
type BlockExtended {
    "Hash hex representation"
    hash: String!
    "Block number (height) in blockchain"
    height: Int!
    "Block timestamp"
    timestamp: DateTime
}

"ConfluxBlock"
type BlockInfo {
    "Block hash"
    hash: String
    "Block number (height) in blockchain"
    height: Int!
    "Block timestamp"
    timestamp: DateTime
}

"Blockchain network"
type BlockchainNetwork {
    "Network name"
    network: Network!
    "Network protocol type"
    protocol: Protocol!
}

"Information about call"
type CallElrond {
    "Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."
    callDepth: String
    "Contract method invoked"
    smartContractAddress(smartContractAddress: HashSelector): String
    "Smart contract name"
    smartContractName(smartContractName: StringSelector): String
    "Smart contract signature"
    smartContractSignature(smartContractSignature: StringSelector): String
    "Signature Hash"
    smartContractSignatureHash(smartContractSignatureHash: HashSelector): String
}

"Cardano"
type Cardano {
    "Information about address"
    address(address: [AddressSelectorIn!]!): [CardanoAddressInfo!]!
    "Blockchain Blocks"
    blocks(any: [CardanoBlockFilter!], blockHash: StringIdSelector, blockSize: IntegerSelector, blockVersion: IntegerSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, opCert: StringSelector, options: QueryOptions, slot: IntegerSelector, slotInEpoch: IntegerSelector, slotLeaderHash: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, version: StringSelector, vrfKey: StringSelector): [CardanoBlock!]
    "Money flow using Coinpath technology"
    coinpath(currency: [CardanoCurrencySelector!], date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CardanoCoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [CardanoCoinpath!]
    "Blockchain Transaction Inputs"
    inputs(any: [CardanoInputFilter!], currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, inOutputIndex: IntegerSelector, inOutputTxId: HashSelector, inputAddress: AddressSelector, inputIndex: IntegerSelector, inputValue: FloatSelector, options: QueryOptions, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector): [CardanoTransactionInput!]
    "Blockchain Tokens Mints"
    mints(any: [CardanoMintFilter!], currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector): [CardanoTransactionMint!]
    "Blockchain Transaction Outputs"
    outputs(any: [CardanoOutputFilter!], currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, options: QueryOptions, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputIndex: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector): [CardanoTransactionOutput!]
    "Blockchain Transactions"
    transactions(any: [CardanoTransactionFilter!], date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, options: QueryOptions, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): [CardanoTransaction!]
}

"Address balance information for Cardano network"
type CardanoAddressBalance {
    "Currency"
    currency: Currency
    "Currency value"
    value: Float
}

"Address detailed information for Cardano network"
type CardanoAddressInfo {
    "Address"
    address: Address
    "Current address balances"
    balance: [CardanoAddressBalance!]
    "Current staking addressese info"
    staking: [CardanoStakingAddress!]
}

"Block"
type CardanoBlock {
    any(of: CardanoBlocksMeasureable!): String
    "Block Hash"
    blockHash(blockHash: StringIdSelector): String
    "Block size"
    blockSize(blockSize: IntegerSelector): Int
    "Block version"
    blockVersion(blockVersion: IntegerSelector): Int
    count(blockHash: StringIdSelector, blockSize: IntegerSelector, blockStrippedSize: IntegerSelector, blockVersion: IntegerSelector, blockWeight: IntegerSelector, date: DateSelector, difficulty: FloatSelector, height: BlockSelector, time: DateTimeSelector, txCount: IntegerSelector, uniq: CardanoBlockUniq): Int
    countBigInt(blockHash: StringIdSelector, blockSize: IntegerSelector, blockStrippedSize: IntegerSelector, blockVersion: IntegerSelector, blockWeight: IntegerSelector, date: DateSelector, difficulty: FloatSelector, height: BlockSelector, time: DateTimeSelector, txCount: IntegerSelector, uniq: CardanoBlockUniq): BigInt
    "Calendar date"
    date: Date
    "Epoch number"
    epoch: Int
    "Block number (height) in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: CardanoBlocksMeasureable, of: CardanoBlocksMeasureable!): String
    minimum(get: CardanoBlocksMeasureable, of: CardanoBlocksMeasureable!): String
    "Op cert"
    opCert: String
    "Slot number"
    slot: Int
    "Slot in epoch number"
    slotInEpoch: Int
    "Slot leader description"
    slotLeaderDescription: String
    "Slot leader hash"
    slotLeaderHash: String
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "Transaction count in block"
    transactionCount(transactionCount: IntegerSelector): Int
    "VRF Key"
    vrfKey: String
}

"Coinpath"
type CardanoCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: Address
    "Sender address"
    sender: Address
    "Transaction of transfer happened"
    transaction: CardanoTransactionHashIndexValues
    "Attributes of transaction included in Coinpath result"
    transactions: [CoinpathEntry!]
}

"Address staking information for Cardano network"
type CardanoStakingAddress {
    "Staking Address"
    address: Address
    "Rewards value"
    rewardsAmount: Float
    "Staked value"
    stakedAmount: Float
    "Staked value including rewards"
    stakedAmountWithRewards: Float
    "Withdrawn value"
    withdrawnAmount: Float
}

"Transaction"
type CardanoTransaction {
    any(of: CardanoTransactionsMeasureable!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Transaction  count"
    count(date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, uniq: CardanoTransactionUniq, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Int
    "Transaction  count"
    countBigInt(date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, uniq: CardanoTransactionUniq, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): BigInt
    "Calendar date"
    date: Date
    "Transaction total deposit value"
    depositValue(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Float
    "Transaction total fee value"
    feeValue(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Float
    "Hash hex representation"
    hash(txHash: StringIdSelector): String!
    "Included at timestamp"
    includedAt: DateTime
    "Transaction index in block, 0-based"
    index(txIndex: IntegerSelector): String!
    "Transaction total input count"
    inputCount(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Int
    "Transaction total input count"
    inputCountbigint(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): BigInt
    "Transaction total input value"
    inputValue(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Float
    "Invalid before"
    invalidBefore: String
    "Invalid hereafter"
    invalidHereafter: String
    maximum(get: CardanoTransactionsMeasureable, of: CardanoTransactionsMeasureable!): String
    "Metadata"
    metadata: String
    minimum(get: CardanoTransactionsMeasureable, of: CardanoTransactionsMeasureable!): String
    "Transaction total mint count"
    mintCount(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Int
    "Transaction total mint count"
    mintCountbigint(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): BigInt
    "Transaction total output count"
    outputCount(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Int
    "Transaction total output count"
    outputCountbigint(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): BigInt
    "Transaction total output value"
    outputValue(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Float
    "Transaction size"
    txSize(txSize: IntegerSelector): Int
    "Transaction total withdrawal count"
    withdrawalCount(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Int
    "Transaction total withdrawal count"
    withdrawalCountbigint(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): BigInt
    "Transaction total withdrawal value"
    withdrawalValue(calculate: AmountAggregateFunction, date: DateSelector, depositValue: FloatSelector, feeValue: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, inputAddress: AddressSelectorIn, inputCount: IntegerSelector, inputValue: FloatSelector, mintCount: IntegerSelector, outputAddress: AddressSelectorIn, outputCount: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, withdrawalCount: IntegerSelector, withdrawalValue: FloatSelector): Float
}

"Blockchain transaction"
type CardanoTransactionHashIndexValues {
    depositValue: Float!
    feeValue: Float!
    "Hash hex representation"
    hash: String!
    includedAt: DateTime!
    "Transaction index in block, 0-based"
    index: String!
    invalidBefore: String!
    invalidHereafter: String!
    metadata: String!
    txSize: Int!
    "Transaction value in input"
    valueIn: Float!
    "Transaction value in output"
    valueOut: Float!
    withdrawalValue: Float!
}

"Transaction Input"
type CardanoTransactionInput {
    any(of: CardanoInputsMeasureable!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Input count"
    count(currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, inOutputIndex: IntegerSelector, inOutputTxId: HashSelector, inputAddress: AddressSelector, inputIndex: IntegerSelector, inputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: CardanoInputUniq): Int
    "Input count"
    countBigInt(currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, inOutputIndex: IntegerSelector, inOutputTxId: HashSelector, inputAddress: AddressSelector, inputIndex: IntegerSelector, inputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: CardanoInputUniq): BigInt
    "Currency of the input"
    currency: Currency
    "Calendar date"
    date: Date
    "Input address"
    inputAddress(inputAddress: AddressSelector): Address
    "Input index"
    inputIndex(inputIndex: IntegerSelector): Int
    maximum(get: CardanoInputsMeasureable, of: CardanoInputsMeasureable!): String
    minimum(get: CardanoInputsMeasureable, of: CardanoInputsMeasureable!): String
    "Output Transaction for this input"
    outputTransaction(inOutputIndex: IntegerSelector, inOutputTxId: StringIdSelector): TransactionHashIndex
    "Source of the input"
    source: CardanoInputSource
    "Transaction ID Hash"
    transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
    "Input value"
    value(calculate: AmountAggregateFunction, currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, inOutputIndex: IntegerSelector, inOutputTxId: HashSelector, inputAddress: AddressSelector, inputIndex: IntegerSelector, inputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector): Float
}

"Transaction Mint"
type CardanoTransactionMint {
    any(of: CardanoMintsMeasureable!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Mint count"
    count(currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: CardanoMintUniq, value: FloatSelector): Int
    "Mint count"
    countBigInt(currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: CardanoMintUniq, value: FloatSelector): BigInt
    "Currency of the mint"
    currency: Currency
    "Calendar date"
    date: Date
    maximum(get: CardanoMintsMeasureable, of: CardanoMintsMeasureable!): String
    minimum(get: CardanoMintsMeasureable, of: CardanoMintsMeasureable!): String
    "Transaction ID Hash"
    transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
    "Mint value"
    value(calculate: AmountAggregateFunction, currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector): Float
}

"Transaction Output"
type CardanoTransactionOutput {
    any(of: CardanoOutputsMeasureable!): String
    "Block where transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Output count"
    count(currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputIndex: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: CardanoOutputUniq): Int
    "Output count"
    countBigInt(currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputIndex: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector, uniq: CardanoOutputUniq): BigInt
    "Currency of the output"
    currency: Currency
    "Calendar date"
    date: Date
    maximum(get: CardanoOutputsMeasureable, of: CardanoOutputsMeasureable!): String
    minimum(get: CardanoOutputsMeasureable, of: CardanoOutputsMeasureable!): String
    "Output address"
    outputAddress(outputAddress: AddressSelector): Address
    "Output guessed direction"
    outputDirection(outputDirection: CardanoOutputDirectionSelector): CardanoOutputDirection
    "Output index"
    outputIndex(outputIndex: IntegerSelector): Int
    "Transaction ID Hash"
    transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
    "Output value"
    value(calculate: AmountAggregateFunction, currency: [CardanoCurrencySelector!], date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputIndex: IntegerSelector, outputValue: FloatSelector, time: DateTimeSelector, txHash: HashSelector, txIndex: IntegerSelector): Float
}

"Transaction attributes in coinpath"
type CoinpathEntry {
    "Amount involved in the flow"
    amount: Float!
    "Block of transaction"
    height: Int!
    "Time of transaction in ISO 8601 format"
    timestamp: ISO8601DateTime!
    "Hash of transaction"
    txHash: String!
    "Amount transfered in transaction"
    txValue: Float!
}

"Conflux Chain"
type Conflux {
    "Basic information about address ( or smart contract )"
    address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!
    "Arguments of Smart Contract Calls and Events"
    arguments(any: [EthereumArgumentFilter!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, options: QueryOptions, reference: [EthereumAddressSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractMethod: MethodSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, value: [ArgumentValueSelector!]): [EthereumArguments!]
    "Blockchain Blocks"
    blocks(any: [ConfluxBlockFilter!], blockHash: HashSelector, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], options: QueryOptions, pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): [ConfluxBlocks!]
    "Money flow using Coinpath technology"
    coinpath(currency: [EthereumCurrencySelector!], date: DateSelector, depth: IntegerLimitedSelector, initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: EthereumAddressSelector, sender: EthereumAddressSelector, time: DateTimeSelector): [EthereumCoinpath!]
    "Trades on Ethereum DEX Smart Contracts"
    dexTrades(any: [EthereumDexTradeFilter!], baseCurrency: [EthereumCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [EthereumCurrencySelector!], date: DateSelector, exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [EthereumAddressSelector!], makerOrTaker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], options: QueryOptions, price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [EthereumCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [EthereumCurrencySelector!], smartContractAddress: [EthereumAddressSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): [EthereumDexTrades!]
    "Smart Contract Calls"
    smartContractCalls(any: [EthereumSmartContractCallFilter!], caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, options: QueryOptions, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, success: [Boolean!], time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): [EthereumSmartContractCalls!]
    "Smart Contract Events"
    smartContractEvents(any: [EthereumSmartContractEventFilter!], date: DateSelector, height: BlockSelector, options: QueryOptions, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractType: SmartContractTypeSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): [EthereumSmartContractEvent!]
    "Blockchain Transactions"
    transactions(amount: [AmountSelector!], any: [ConfluxTransactionFilter!], blockHash: HashSelector, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], height: BlockSelector, options: QueryOptions, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): [ConfluxTransactions!]
    "Currency Transfers"
    transfers(amount: [AmountSelector!], any: [EthereumTransferFilter!], currency: [EthereumCurrencySelector!], date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, options: QueryOptions, receiver: [EthereumAddressSelector!], sender: [EthereumAddressSelector!], success: Boolean, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): [EthereumTransfers!]
}

"Blocks in Conflux blockchain"
type ConfluxBlocks {
    "Block is adaptive"
    adaptive: Boolean!
    any(of: ConfluxBlocksMeasureable!): String
    "Blame"
    blame: Int!
    "Block index in epoch"
    blockPosition: Int!
    count(blockHash: HashSelector, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], uniq: EthereumBlocksUniq): Int
    countBigInt(blockHash: HashSelector, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], uniq: EthereumBlocksUniq): BigInt
    "Calendar date"
    date: Date
    "Epoch in blockchain"
    epoch(height: BlockSelector): Int!
    "Block hash"
    hash(blockHash: [HashSelector!]): String!
    "Block height in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: ConfluxBlocksMeasureable, of: ConfluxBlocksMeasureable!): String
    "Block miner"
    miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
    minimum(get: ConfluxBlocksMeasureable, of: ConfluxBlocksMeasureable!): String
    "Block nonce"
    nonce: Int!
    "Parent block hash"
    parentHash: String!
    "Block is pivot"
    pivot: Boolean!
    "Power Quality"
    powerQuality: BigInt!
    refereeCount(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Int
    refereeCountbigint(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): BigInt
    "Reference Block hash"
    referenceBlockHash(referenceBlockHash: [HashSelector!]): String!
    size(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Int
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    totalDifficulty(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Float
    transactionCount(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Int
    transactionCountbigint(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): BigInt
    "Hash of Transaction included in block"
    txHash(txHash: [HashSelector!]): String!
    uncleCount(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Int
    uncleCountbigint(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, epoch: BlockSelector, height: BlockSelector, miner: [EthereumAddressSelector!], pivot: Boolean, refereeCount: [IntegerSelector!], referenceBlockHash: HashSelector, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): BigInt
}

"Transactions in Conflux blockchain"
type ConfluxTransactions {
    amount(amount: [AmountSelector!], blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], height: BlockSelector, in: BaseCurrencyEnum, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float
    any(of: ConfluxTransactionsMeasureable!): String
    "Block where transfer transaction is included"
    block(blockHash: HashSelector, height: BlockSelector, time: DateTimeSelector): BlockInfo
    count(amount: [AmountSelector!], blockHash: HashSelector, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], height: BlockSelector, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], uniq: EthereumTransactionsUniq): Int
    countBigInt(amount: [AmountSelector!], blockHash: HashSelector, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], height: BlockSelector, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], uniq: EthereumTransactionsUniq): BigInt
    "Created smart contract"
    creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo
    "Currency of amount"
    currency: Currency
    "Calendar date"
    date: Date
    "Error message if any"
    error: String
    gas(amount: [AmountSelector!], blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], height: BlockSelector, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Int
    "Currency of gas"
    gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency
    "Gas price in Gwei"
    gasPrice(amount: [AmountSelector!], blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], height: BlockSelector, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float!
    gasValue(amount: [AmountSelector!], blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], height: BlockSelector, in: BaseCurrencyEnum, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float
    "Hash hex representation"
    hash(txHash: [HashSelector!]): String!
    "Transaction index in block, 0 based"
    index(txIndex: [TxIndexSelector!]): Int
    maximum(get: ConfluxTransactionsMeasureable, of: ConfluxTransactionsMeasureable!): String
    minimum(get: ConfluxTransactionsMeasureable, of: ConfluxTransactionsMeasureable!): String
    "Transaction nonce"
    nonce: Int
    "Transaction sender"
    sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo
    "Success"
    success(success: Boolean): Boolean
    "Transaction receiver"
    to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
}

"Country"
type CovidCountry {
    "Area, km2"
    areaKm2: Float
    "Continent name"
    continent: Continent
    "Gross Domestic Product"
    gdp: Float
    "ISO 2 letter code"
    iso2: CountryCode
    "ISO 3 letter code"
    iso3: String
    "ISO numeric code"
    isoNumeric: Int
    "Location latitude"
    latitude: Float
    "Location longitude"
    longitude: Float
    "Country name"
    name: String
    "Population density in thousands per km2"
    populationPerKm2: Float
    "Population total in thousands"
    populationTotal: Float
}

"Facts of Covid virus development"
type CovidFact {
    "Count of confirmed cases"
    confirmed(continent: ContinentSelector, country: CountrySelector, date: DateSelector): Int
    "Country"
    country(continent: ContinentSelector, country: CountrySelector): CovidCountry
    "Calendar date"
    date: Date
    "Count of death cases"
    deaths(continent: ContinentSelector, country: CountrySelector, date: DateSelector): Int
    "Location"
    location: CovidLocation
    "Count of recovered cases"
    recovered(continent: ContinentSelector, country: CountrySelector, date: DateSelector): Int
}

"Covid History"
type CovidHistory {
    "COVID daily facts"
    facts(continent: ContinentSelector, country: CountrySelector, date: DateSelector, options: QueryOptions): [CovidFact!]
}

"Geo Location"
type CovidLocation {
    "Admin center name"
    adminCenter: String
    "FIPS code for USA"
    fipsCode: Int
    "Location latitude"
    latitude: Float
    "Location longitude"
    longitude: Float
    "Location Country name"
    name: String
    "Location Province / State name"
    province: String
}

"Crypto currency ( token, coin, currency )"
type Currency {
    "Token Smart Contract Address"
    address: String
    "Decimals"
    decimals: Int!
    "Currency name"
    name: String
    "Currency symbol"
    symbol: String!
    "Token ID"
    tokenId: String
    "Token Type"
    tokenType: String
}

"Date"
type Date {
    "String date representation with default format as YYYY-MM-DD"
    date(format: String): String!
    "Day of month (1-31)"
    dayOfMonth: Int!
    "Day of week  (Monday is 1, and Sunday is 7)"
    dayOfWeek: Int!
    "Month number (1-12)"
    month: Int!
    """

    Returns start of date interval ,
    date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
    starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
    """
    startOfInterval(format: String, interval: Int, offset: Int, unit: DateInterval!): String!
    "Year number"
    year: Int!
}

"Date and Time"
type DateTime {
    "Day of month (1-31)"
    dayOfMonth: Int!
    "Day of week  (Monday is 1, and Sunday is 7)"
    dayOfWeek: Int!
    "Hour (0-23)"
    hour: Int!
    "ISO8601 date time such as '2020-03-02T13:30:41+00:00'"
    iso8601: ISO8601DateTime!
    "Minute (0-59)"
    minute: Int!
    "Month number (1-12)"
    month: Int!
    "Second (0-59)"
    second: Int!
    "String date representation with default format as YYYY-MM-DD"
    time(format: String): String!
    "Unix timestamp"
    unixtime: Int!
    "Year number"
    year: Int!
}

"Elrond Chain"
type Elrond {
    "Arguments of Smart Contract Calls and Events"
    arguments(any: [ElrondArgumentFilter!], argumentIndex: IntegerSelector, argumentValue: IntIdSelector, blockHash: HashSelector, blockNonce: IntegerSelector, callDepth: IntegerSelector, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, index: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, nonce: IntegerSelector, options: QueryOptions, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, smartContractAddress: HashSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, type: StringSelector): [ElrondArgument!]
    "Information about validators of the block"
    blockValidators(any: [ElrondBlockValidatorFilter!], blockHash: HashSelector, blockNonce: IntegerSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, options: QueryOptions, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, time: DateTimeSelector, transactionCount: IntegerSelector, validator: HashSelector): [ElrondBlockValidator!]
    "Information about blocks"
    blocks(any: [ElrondBlockFilter!], date: DateSelector, epoch: IntegerSelector, hash: HashSelector, height: BlockSelector, nonce: IntegerSelector, options: QueryOptions, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: IntegerSelector, time: DateTimeSelector, transactionCount: IntegerSelector): [ElrondBlock!]
    "Information about calls"
    callResults(any: [ElrondCallResultFilter!], blockHash: HashSelector, blockNonce: IntegerSelector, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultGasLimit: FloatSelector, callResultGasPrice: FloatSelector, callResultHash: HashSelector, callResultIndex: IntegerSelector, callResultNonce: IntegerSelector, callResultReceiver: HashSelector, callResultRelayedValue: FloatSelector, callResultSender: HashSelector, callResultType: StringSelector, callResultValue: FloatSelector, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, index: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, nonce: IntegerSelector, options: QueryOptions, originTxHash: HashSelector, previousBlockHash: HashSelector, previousTxHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, relayed: StringSelector, returnMessage: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, type: StringSelector): [ElrondCallResult!]
    "Information about calls"
    calls(any: [ElrondCallFilter!], blockHash: HashSelector, blockNonce: IntegerSelector, callDepth: StringSelector, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, index: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, nonce: IntegerSelector, options: QueryOptions, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, smartContractAddress: HashSelector, smartContractMethod: MethodSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, type: StringSelector): [ElrondCall!]
    "Money flow using Coinpath technology"
    coinpath(currency: CurrencySelector, date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [ElrondCoinpath!]
    "Information about miniblocks"
    miniblocks(any: [ElrondMiniblockFilter!], blockHash: HashSelector, blockNonce: IntegerSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, miniblockHash: HashSelector, options: QueryOptions, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, receiverBlockHash: HashSelector, receiverShard: IntIdSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, time: DateTimeSelector, transactionCount: IntegerSelector, type: StringSelector): [ElrondMiniblock!]
    "Information about notarized block"
    notarizedBlock(any: [ElrondNotarizedBlockFilter!], blockHash: HashSelector, blockNonce: IntegerSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, notarizedBlockHash: HashSelector, options: QueryOptions, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, time: DateTimeSelector, transactionCount: IntegerSelector): [ElrondNotarizedBlock!]
    "Information about transactions"
    transactions(any: [ElrondTransactionFilter!], blockHash: HashSelector, blockNonce: IntegerSelector, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, fee: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, gasUsed: FloatSelector, height: BlockSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, options: QueryOptions, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, txValue: FloatSelector, type: StringSelector): [ElrondTransaction!]
    "Information about transactions"
    transfers(any: [ElrondTransferFilter!], blockHash: HashSelector, blockNonce: IntegerSelector, currency: CurrencySelector, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, index: IntegerSelector, metadata: StringSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, nftNonce: IntIdSelector, nonce: IntegerSelector, options: QueryOptions, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, transferReason: TransferReasonSelector, transferReceiver: AddressSelector, transferSender: AddressSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, type: StringSelector): [ElrondTransfer!]
}

"Blockchain address hash"
type ElrondAddressHash {
    "String hex address representation"
    hex: String!
}

"Arguments of Smart Contract Calls and Events"
type ElrondArgument {
    any(of: ElrondArgumentsMeasureable!): String
    "Information about arguments call"
    call(callDepth: IntegerSelector, smartContractAddress: HashSelector): CallElrond
    count(uniq: ElrondArgumentUniq): Int
    countBigInt(uniq: ElrondArgumentUniq): BigInt
    "The date this transaction was created"
    date: Date
    "Index of the argument"
    index(argumentIndex: IntIdSelector): Int
    maximum(get: ElrondArgumentsMeasureable, of: ElrondArgumentsMeasureable!): String
    "Information about arguments miniblock"
    miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, type: StringSelector): MiniblockElrond
    minimum(get: ElrondArgumentsMeasureable, of: ElrondArgumentsMeasureable!): String
    "Information about arguments block"
    senderBlock(blockHash: HashSelector, blockNonce: IntegerSelector, epoch: IntegerSelector, height: BlockSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
    "The time this transaction was created"
    time: DateTime
    "Information about arguments transaction"
    transaction(data: StringSelector, dataOperation: StringSelector, index: IntegerSelector, nonce: IntegerSelector, signature: HashSelector, status: StringSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector): TransactionElrond
    "Value of the argument"
    value(argumentValue: StringSelector): String
}

"Blocks in Elrond  blockchain"
type ElrondBlock {
    any(of: ElrondBlocksMeasureable!): String
    count(uniq: ElrondBlockUniq): Int
    countBigInt(uniq: ElrondBlockUniq): BigInt
    "The date this transaction was created"
    date: Date
    "Epoch"
    epoch(epoch: IntegerSelector): Int
    "Hash of the the block"
    hash(hash: HashSelector): String
    "Number of block in the blockchains"
    height(height: BlockSelector): BigInt
    maximum(get: ElrondBlocksMeasureable, of: ElrondBlocksMeasureable!): String
    minimum(get: ElrondBlocksMeasureable, of: ElrondBlocksMeasureable!): String
    "Block Height"
    nonce(nonce: IntegerSelector): BigInt
    "The block hash of this block`s parent"
    previousBlockHash(previousBlockHash: HashSelector): String
    "Proposer block hash"
    proposer(proposer: HashSelector): ElrondAddressHash
    "Public Key Bitmap"
    publicKeyBitmap(publicKeyBitmap: StringSelector): String
    "Round"
    round(round: IntegerSelector): BigInt
    "Shard number of block"
    shard(shard: IntIdSelector): String
    "Size"
    size(size: IntegerSelector): Int
    "Size Tx"
    sizeTxs(sizeTxs: IntegerSelector): Int
    "State root hash"
    stateRootHash(stateRootHash: HashSelector): String
    "The time this transaction was created"
    time: DateTime
    "Count of transactions in this block"
    transactionCount(transactionCount: IntegerSelector): BigInt
}

"Information about block"
type ElrondBlockDimension {
    "Epoch"
    epoch(epoch: IntegerSelector): Int
    "Hash of the block"
    hash(blockHash: HashSelector): String
    "Number of block in the blockchains"
    height(height: BlockSelector): BigInt
    "Block Height"
    nonce(blockNonce: IntegerSelector): BigInt
    "The block hash of this block`s parent"
    previousBlockHash(previousBlockHash: HashSelector): String
    "Proposer block hash"
    proposer(proposer: HashSelector): ElrondAddressHash
    "Public Key Bitmap"
    publicKeyBitmap(publicKeyBitmap: StringSelector): String
    "Round"
    round(round: IntegerSelector): BigInt
    "Shard number of block"
    shard(shard: IntIdSelector): String
    "Size"
    size(size: IntegerSelector): Int
    "Size Tx"
    sizeTxs(sizeTxs: IntegerSelector): Int
    "State root hash"
    stateRootHash(stateRootHash: HashSelector): String
    "Count of transactions in this block"
    transactionCount(transactionCount: IntegerSelector): BigInt
}

"BlockValidators in Elrond  blockchain"
type ElrondBlockValidator {
    any(of: ElrondBlockValidatorsMeasureable!): String
    "Information about blocks notarized block"
    block(blockHash: HashSelector, blockNonce: IntegerSelector, epoch: IntegerSelector, height: BlockSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
    count(uniq: ElrondBlockValidatorUniq): Int
    countBigInt(uniq: ElrondBlockValidatorUniq): BigInt
    "The date this transaction was created"
    date: Date
    maximum(get: ElrondBlockValidatorsMeasureable, of: ElrondBlockValidatorsMeasureable!): String
    minimum(get: ElrondBlockValidatorsMeasureable, of: ElrondBlockValidatorsMeasureable!): String
    "The time this transaction was created"
    time: DateTime
    "Hash of validator"
    validator(validator: HashSelector): ElrondAddressHash
}

"Calls in Elrond blockchain"
type ElrondCall {
    any(of: ElrondCallsMeasureable!): String
    """

    Depth of the call. Empty string for external call, then counted
    as 0...N, and the next layer is added through '-'. For example 0-3-9.
    """
    callDepth(callDepth: StringSelector): String
    count(uniq: ElrondCallsUni): Int
    countBigInt(uniq: ElrondCallsUni): BigInt
    "The date this transaction was created"
    date: Date
    maximum(get: ElrondCallsMeasureable, of: ElrondCallsMeasureable!): String
    "Information about calls miniblock"
    miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, type: StringSelector): MiniblockElrond
    minimum(get: ElrondCallsMeasureable, of: ElrondCallsMeasureable!): String
    "Information about calls block"
    senderBlock(blockHash: HashSelector, blockNonce: IntegerSelector, epoch: IntegerSelector, height: BlockSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
    "Contract method invoked"
    smartContractAddress(smartContractAddress: HashSelector): Address
    "Contract method invoked"
    smartContractMethod(smartContractMethod: MethodSelector): Method
    "The time this transaction was created"
    time: DateTime
    "Information about calls transaction"
    transaction(data: StringSelector, dataOperation: StringSelector, index: IntegerSelector, nonce: IntegerSelector, signature: HashSelector, status: StringSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector): TransactionElrond
}

"CallResults in Elrond blockchain"
type ElrondCallResult {
    any(of: ElrondCallResultsMeasureable!): String
    count(uniq: ElrondCallResultUniq): Int
    countBigInt(uniq: ElrondCallResultUniq): BigInt
    "Call result data"
    data(callResultData: StringSelector): String
    "Call result data operation"
    dataOperation(callResultDataOperation: StringSelector): String
    "The date this transaction was created"
    date: Date
    "Call result gas limit"
    gasLimit(callResultGasLimit: IntegerSelector): BigInt
    "Call result gas price"
    gasPrice(callResultGasPrice: IntegerSelector): BigInt
    "Hash of the call result"
    hash(callResultHash: HashSelector): String
    "Call result index"
    index(callResultIndex: IntegerSelector): Int
    maximum(get: ElrondCallResultsMeasureable, of: ElrondCallResultsMeasureable!): String
    "Information about calls miniblock"
    miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, type: StringSelector): MiniblockElrond
    minimum(get: ElrondCallResultsMeasureable, of: ElrondCallResultsMeasureable!): String
    "Nonce of the call result"
    nonce(callResultNonce: IntegerSelector): BigInt
    "Hash of the origin transaction"
    originTxHash(originTxHash: HashSelector): String
    "Hash of the previous transaction"
    previousTxHash(previousTxHash: HashSelector): String
    "Call result receiver"
    receiver(callResultReceiver: HashSelector): Address
    "Call result relayed"
    relayed(relayed: StringSelector): String
    relayedValue(blockHash: HashSelector, blockNonce: IntegerSelector, calculate: AmountAggregateFunction, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultGasLimit: FloatSelector, callResultGasPrice: FloatSelector, callResultHash: HashSelector, callResultIndex: IntegerSelector, callResultNonce: IntegerSelector, callResultReceiver: HashSelector, callResultRelayedValue: FloatSelector, callResultSender: HashSelector, callResultType: StringSelector, callResultValue: FloatSelector, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, nonce: IntegerSelector, originTxHash: HashSelector, previousBlockHash: HashSelector, previousTxHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, relayed: StringSelector, returnMessage: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, type: StringSelector): Float
    "Call result return message"
    returnMessage(returnMessage: StringSelector): String
    "Call result sender"
    sender(callResultSender: HashSelector): Address
    "Information about calls block"
    senderBlock(blockHash: HashSelector, blockNonce: IntegerSelector, epoch: IntegerSelector, height: BlockSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
    "The time this transaction was created"
    time: DateTime
    "Information about calls transaction"
    transaction(data: StringSelector, dataOperation: StringSelector, index: IntegerSelector, nonce: IntegerSelector, signature: HashSelector, status: StringSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector): TransactionElrond
    "Call result type"
    type(callResultType: StringSelector): String
    value(blockHash: HashSelector, blockNonce: IntegerSelector, calculate: AmountAggregateFunction, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultGasLimit: FloatSelector, callResultGasPrice: FloatSelector, callResultHash: HashSelector, callResultIndex: IntegerSelector, callResultNonce: IntegerSelector, callResultReceiver: HashSelector, callResultRelayedValue: FloatSelector, callResultSender: HashSelector, callResultType: StringSelector, callResultValue: FloatSelector, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, nonce: IntegerSelector, originTxHash: HashSelector, previousBlockHash: HashSelector, previousTxHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, relayed: StringSelector, returnMessage: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, type: StringSelector): Float
}

"Elrond Coinpath"
type ElrondCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: ElrondCoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: ElrondCoinpathMeasureable, of: ElrondCoinpathMeasureable!): String
    minimum(get: ElrondCoinpathMeasureable, of: ElrondCoinpathMeasureable!): String
    "Receiver address"
    receiver: Address
    "Sender address"
    sender: Address
    "Transaction of transfer happened"
    transaction: ElrondTransactionValueDimension
}

"Miniblocks in Elrond  blockchain"
type ElrondMiniblock {
    any(of: ElrondMiniblocksMeasureable!): String
    count(uniq: ElrondMiniblockUniq): Int
    countBigInt(uniq: ElrondMiniblockUniq): BigInt
    "The date this transaction was created"
    date: Date
    "Miniblock hash"
    hash(miniblockHash: HashSelector): String
    maximum(get: ElrondMiniblocksMeasureable, of: ElrondMiniblocksMeasureable!): String
    minimum(get: ElrondMiniblocksMeasureable, of: ElrondMiniblocksMeasureable!): String
    "Hash of the receiver block"
    receiverBlockHash(receiverBlockHash: HashSelector): String
    "Number of the receiver shard"
    receiverShard(receiverShard: IntIdSelector): String
    "Information about miniblocks block"
    senderBlock(blockHash: HashSelector, blockNonce: IntegerSelector, epoch: IntegerSelector, height: BlockSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
    "The time this transaction was created"
    time: DateTime
    "Miniblock type"
    type(type: StringSelector): String
}

"NotarizedBlocks in Elrond blockchain"
type ElrondNotarizedBlock {
    any(of: ElrondNotarizedBlocksMeasureable!): String
    "Information about blocks notarized block"
    block(blockHash: HashSelector, blockNonce: IntegerSelector, epoch: IntegerSelector, height: BlockSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
    count(uniq: ElrondNotarizedBlockUniq): Int
    countBigInt(uniq: ElrondNotarizedBlockUniq): BigInt
    "The date this transaction was created"
    date: Date
    maximum(get: ElrondNotarizedBlocksMeasureable, of: ElrondNotarizedBlocksMeasureable!): String
    minimum(get: ElrondNotarizedBlocksMeasureable, of: ElrondNotarizedBlocksMeasureable!): String
    "Hash of the notarized block"
    notarizedBlockHash(notarizedBlockHash: HashSelector): String
    "The time this transaction was created"
    time: DateTime
}

"Transactions in Elrond blockchain"
type ElrondTransaction {
    any(of: ElrondTransactionsMeasureable!): String
    count(uniq: ElrondTransactionUniq): Int
    countBigInt(uniq: ElrondTransactionUniq): BigInt
    "Shard number of sender"
    data(data: StringSelector): String
    "Shard number of sender"
    dataOperation(dataOperation: StringSelector): String
    "The date this transaction was created"
    date: Date
    fee(blockHash: HashSelector, blockNonce: IntegerSelector, calculate: AmountAggregateFunction, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, fee: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, gasUsed: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, txValue: FloatSelector, type: StringSelector): Float
    "Number of gas limit"
    gasLimit(gasLimit: IntegerSelector): BigInt
    "Number of gas price"
    gasPrice(gasPrice: IntegerSelector): BigInt
    "Number of gas used"
    gasUsed(gasUsed: IntegerSelector): BigInt
    "Transaction hash"
    hash(txHash: HashSelector): String
    "Transaction index"
    index(txIndex: IntegerSelector): Int
    maximum(get: ElrondTransactionsMeasureable, of: ElrondTransactionsMeasureable!): String
    "Information about transactions miniblock"
    miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, type: StringSelector): MiniblockElrond
    minimum(get: ElrondTransactionsMeasureable, of: ElrondTransactionsMeasureable!): String
    "Transaction nonce"
    nonce(txNonce: IntegerSelector): Int
    "TX  receiver"
    receiver(txReceiver: HashSelector): Address
    "Shard number of receiver"
    receiverShard(txReceiverShard: IntIdSelector): BigInt
    "Hash of the sender"
    sender(txSender: HashSelector): Address
    "Information about transactions block"
    senderBlock(blockHash: HashSelector, blockNonce: IntegerSelector, epoch: IntegerSelector, height: BlockSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
    "Shard number of sender"
    senderShard(txSenderShard: IntIdSelector): BigInt
    "Shard number of sender"
    signature(signature: HashSelector): String
    "Shard number of sender"
    status(status: StringSelector): String
    "The time this transaction was created"
    time: DateTime
    value(blockHash: HashSelector, blockNonce: IntegerSelector, calculate: AmountAggregateFunction, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, fee: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, gasUsed: FloatSelector, height: BlockSelector, in: BaseCurrencyEnum, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, txValue: FloatSelector, type: StringSelector): Float
}

"Blockchain transaction with value"
type ElrondTransactionValueDimension {
    "Transaction hash"
    hash: String!
    "Transaction value"
    value: Float!
}

"Transfers of Smart Contract Calls and Events"
type ElrondTransfer {
    amount(blockHash: HashSelector, blockNonce: IntegerSelector, calculate: AmountAggregateFunction, currency: CurrencySelector, data: StringSelector, dataOperation: StringSelector, date: DateSelector, epoch: IntegerSelector, height: BlockSelector, index: IntegerSelector, metadata: StringSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, nftNonce: IntIdSelector, nonce: IntegerSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, signature: HashSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, status: StringSelector, time: DateTimeSelector, transactionCount: IntegerSelector, transferReason: TransferReasonSelector, transferReceiver: AddressSelector, transferSender: AddressSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector, type: StringSelector): Float
    any(of: ElrondTransfersMeasureable!): String
    count(uniq: ElrondTransferUniq): Int
    countBigInt(uniq: ElrondTransferUniq): BigInt
    "Currency of transfer"
    currency(currency: CurrencySelector): Currency
    "The date this transaction was created"
    date: Date
    maximum(get: ElrondTransfersMeasureable, of: ElrondTransfersMeasureable!): String
    "Metadata"
    metadata(metadata: StringSelector): String
    "Information about arguments miniblock"
    miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: IntIdSelector, type: StringSelector): MiniblockElrond
    minimum(get: ElrondTransfersMeasureable, of: ElrondTransfersMeasureable!): String
    "NFT nonce"
    nftNonce(nftNonce: IntIdSelector): String
    "How the money was transferred"
    reason(transferReason: TransferReasonSelector): String
    "Receiver account address"
    receiver(transferReceiver: AddressSelector): Address
    "Sender account address"
    sender(transferSender: AddressSelector): Address
    "Information about arguments block"
    senderBlock(blockHash: HashSelector, blockNonce: IntegerSelector, epoch: IntegerSelector, height: BlockSelector, previousBlockHash: HashSelector, proposer: HashSelector, publicKeyBitmap: StringSelector, round: IntegerSelector, shard: IntIdSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
    "The time this transaction was created"
    time: DateTime
    "Information about arguments transaction"
    transaction(data: StringSelector, dataOperation: StringSelector, index: IntegerSelector, nonce: IntegerSelector, signature: HashSelector, status: StringSelector, txHash: HashSelector, txReceiver: HashSelector, txReceiverShard: IntIdSelector, txSender: HashSelector, txSenderShard: IntIdSelector): TransactionElrond
}

"Entity"
type Entity {
    "Entity ID"
    id(entityId: String): String!
    "Entity number"
    num: Int!
    "Entity realm ID"
    realmId: Int!
    "Entity shard ID"
    shardId: Int!
    "Entity Type"
    type: String!
}

"EOS Chain"
type Eos {
    "Basic information about address ( or smart contract )"
    address(address: [AddressSelectorIn!]!): [EosAddressInfo!]!
    "Blockchain Blocks"
    blocks(any: [EosBlockFilter!], blockHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, proposer: AddressSelector, time: DateTimeSelector): [EosBlocks!]
    "Money flow using Coinpath technology"
    coinpath(currency: EosCurrencySelector, date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [EosCoinpath!]
    "Smart Contract Calls"
    smartContractCalls(any: [EosSmartContractCallFilter!], date: DateSelector, external: Boolean, height: BlockSelector, options: QueryOptions, scheduled: Boolean, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): [EosSmartContractCalls!]
    "Blockchain Transactions"
    transactions(any: [EosTransactionFilter!], date: DateSelector, height: BlockSelector, options: QueryOptions, scheduled: Boolean, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): [EosTransactions!]
    "Currency Transfers"
    transfers(amount: [AmountSelector!], any: [EosTransferFilter!], currency: EosCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, options: QueryOptions, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): [EosTransfers!]
}

"Address detailed information for EOS network"
type EosAddressInfo {
    "Address"
    address: String
    "Annotations ( tags ), if exists"
    annotation: String
    "Smart Contract if exists on the address"
    smartContract: EosSmartContractInfo
}

"Blocks in EOS blockchain"
type EosBlocks {
    any(of: EosBlocksMeasureable!): String
    count(blockHash: HashSelector, date: DateSelector, height: BlockSelector, proposer: AddressSelector, time: DateTimeSelector, uniq: EosBlocksUniq): Int
    countBigInt(blockHash: HashSelector, date: DateSelector, height: BlockSelector, proposer: AddressSelector, time: DateTimeSelector, uniq: EosBlocksUniq): BigInt
    "Calendar date"
    date: Date
    "Block hash"
    hash(blockHash: [HashSelector!]): String!
    "Block number (height) in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: EosBlocksMeasureable, of: EosBlocksMeasureable!): String
    minimum(get: EosBlocksMeasureable, of: EosBlocksMeasureable!): String
    "Block producer"
    producer(producer: AddressSelector): Address
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
}

"Coinpath"
type EosCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: EosAddressInfo
    "Sender address"
    sender: EosAddressInfo
    "Transaction of transfer happened"
    transaction: TransactionHashValue
}

"Eos smart contract"
type EosSmartContract {
    "Smart Contract Address"
    address: Address!
    "Smart Contract Type"
    contractType: SmartContractType
    "Token implemented in this smart contract"
    currency: Currency
    "Smart Contract Protocol Type"
    protocolType: String
}

"Smart Contract Calls"
type EosSmartContractCalls {
    "Actors"
    actors: String
    any(of: EosCallsMeasureable!): String
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."
    callDepth: String
    "Console"
    console: String
    "Counts and other metrics"
    count(date: DateSelector, external: Boolean, height: BlockSelector, scheduled: Boolean, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: SmartContractCallsUniq): Int
    "Counts and other metrics"
    countBigInt(date: DateSelector, external: Boolean, height: BlockSelector, scheduled: Boolean, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: SmartContractCallsUniq): BigInt
    "Calendar date"
    date: Date
    "Error Code"
    errorCode(errorCode: IntIdSelector): Int
    "External call executed explicitly by tx sender. Internal calls executed by smart contracts."
    external(external: Boolean): Boolean
    maximum(get: EosCallsMeasureable, of: EosCallsMeasureable!): String
    minimum(get: EosCallsMeasureable, of: EosCallsMeasureable!): String
    "Permissions"
    permissions: String
    "Receivers"
    receivers: String
    "True if call scheduled"
    scheduled(scheduled: [Boolean!]): Boolean
    "Smart contract being called"
    smartContract(smartContractAddress: AddressSelector): EosSmartContract
    "Contract method invoked"
    smartContractMethod(smartContractMethod: MethodSelector): Method
    "True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."
    success(success: [Boolean!]): Boolean
    "Action from address"
    txFrom(txFrom: AddressSelector): Address
    "Transaction hash where transfer happened"
    txHash(txHash: HashSelector): String
    "Action to address"
    txTo(txTo: AddressSelector): Address
}

"Blockchain smart contract"
type EosSmartContractInfo {
    "Smart Contract Type"
    contractType: SmartContractType
    "Token implemented in this smart contract"
    currency: Currency
    "Smart Contract Protocol Type"
    protocolType: String
}

"Transactions in EOS blockchain"
type EosTransactions {
    any(of: EosTransactionsMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(date: DateSelector, height: BlockSelector, scheduled: Boolean, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector, uniq: EosTransactionsUniq): Int
    countBigInt(date: DateSelector, height: BlockSelector, scheduled: Boolean, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector, uniq: EosTransactionsUniq): BigInt
    cpuUsageUs(calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, scheduled: Boolean, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Int
    "Calendar date"
    date: Date
    "Hash hex representation"
    hash(txHash: [HashSelector!]): String!
    "Transaction index in block, 0 based"
    index(txIndex: [TxIndexSelector!]): Int
    maximum(get: EosTransactionsMeasureable, of: EosTransactionsMeasureable!): String
    minimum(get: EosTransactionsMeasureable, of: EosTransactionsMeasureable!): String
    netUsageWords(calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, scheduled: Boolean, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Int
    "Success"
    scheduled(scheduled: Boolean): Boolean
    "Success"
    success(success: Boolean): Boolean
}

"Currency transfers from/to addresses in crypto currencies"
type EosTransfers {
    "Actors"
    actors: String
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, currency: EosCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    any(of: EosTransfersMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(amount: [AmountSelector!], currency: EosCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: TransfersUniq): Int
    countBigInt(amount: [AmountSelector!], currency: EosCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: TransfersUniq): BigInt
    "Currency of transfer"
    currency(currency: EosCurrencySelector): Currency
    "Calendar date"
    date: Date
    "Entity identifier ( for ERC-721 NFT tokens )"
    entityId(entityId: EntitySelector): String
    "External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts."
    external(external: Boolean): Boolean
    maximum(get: EosTransfersMeasureable, of: EosTransfersMeasureable!): String
    "Memo"
    memo: String
    minimum(get: EosTransfersMeasureable, of: EosTransfersMeasureable!): String
    "Transfer receiver"
    receiver(receiver: AddressSelector): Address
    "Transfer sender"
    sender(sender: AddressSelector): Address
    "Transfer succeeded"
    success(success: Boolean): Boolean
    "Action from address"
    txFrom(txFrom: AddressSelector): Address
    "Transaction hash where transfer happened"
    txHash(txHash: HashSelector): String
    "Action to address"
    txTo(txTo: AddressSelector): Address
}

"Ethereum Chain"
type Ethereum {
    "Basic information about address ( or smart contract )"
    address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!
    "Arguments of Smart Contract Calls and Events"
    arguments(any: [EthereumArgumentFilter!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, options: QueryOptions, reference: [EthereumAddressSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractMethod: MethodSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, value: [ArgumentValueSelector!]): [EthereumArguments!]
    "Blockchain Blocks"
    blocks(any: [EthereumBlockFilter!], blockHash: HashSelector, blockReward: [AmountSelector!], date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], options: QueryOptions, size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): [EthereumBlocks!]
    "Money flow using Coinpath technology"
    coinpath(currency: [EthereumCurrencySelector!], date: DateSelector, depth: IntegerLimitedSelector, initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: EthereumAddressSelector, sender: EthereumAddressSelector, time: DateTimeSelector): [EthereumCoinpath!]
    "Trades on Ethereum DEX Smart Contracts"
    dexTrades(any: [EthereumDexTradeFilter!], baseCurrency: [EthereumCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [EthereumCurrencySelector!], date: DateSelector, exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [EthereumAddressSelector!], makerOrTaker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], options: QueryOptions, price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [EthereumCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [EthereumCurrencySelector!], smartContractAddress: [EthereumAddressSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): [EthereumDexTrades!]
    "Smart Contract Calls"
    smartContractCalls(any: [EthereumSmartContractCallFilter!], caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, options: QueryOptions, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, success: [Boolean!], time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): [EthereumSmartContractCalls!]
    "Smart Contract Events"
    smartContractEvents(any: [EthereumSmartContractEventFilter!], date: DateSelector, height: BlockSelector, options: QueryOptions, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractType: SmartContractTypeSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): [EthereumSmartContractEvent!]
    "Blockchain Transactions"
    transactions(amount: [AmountSelector!], any: [EthereumTransactionFilter!], date: DateSelector, gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], height: BlockSelector, options: QueryOptions, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): [EthereumTransactions!]
    "Currency Transfers"
    transfers(amount: [AmountSelector!], any: [EthereumTransferFilter!], currency: [EthereumCurrencySelector!], date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, options: QueryOptions, receiver: [EthereumAddressSelector!], sender: [EthereumAddressSelector!], success: Boolean, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): [EthereumTransfers!]
}

"Ethereum v 2.0 Baecon Chain"
type Ethereum2 {
    "Attestations in block"
    attestations(any: [Ethereum2Filter!], attestationEpoch: [IntegerSelector!], attestationSlot: [IntegerSelector!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, committeeIndex: [IntegerSelector!], date: DateSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector, validatorIndex: [IntegerSelector!]): [Ethereum2Attestation!]
    "Attester Slashings"
    attesterSlashings(any: [Ethereum2Filter!], attestationEpoch: [IntegerSelector!], attestationSlot: [IntegerSelector!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector, validatorIndex: [IntegerSelector!]): [Ethereum2AttesterSlashing!]
    "Blockchain Blocks"
    blocks(any: [Ethereum2Filter!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector): [Ethereum2Blocks!]
    "Attestations of blocks"
    deposits(any: [Ethereum2Filter!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector, validatorIndex: [IntegerSelector!]): [Ethereum2Deposit!]
    "Proposer Slashings"
    proposerSlashings(any: [Ethereum2Filter!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, slashingEpoch: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], time: DateTimeSelector): [Ethereum2ProposerSlashing!]
    "Voluntary Exits"
    voluntaryExits(any: [Ethereum2Filter!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, time: DateTimeSelector, validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): [Ethereum2VoluntaryExit!]
}

"Attestations in Ethereum v2.0 blockchain"
type Ethereum2Attestation {
    aggregationBits: String!
    any(of: Ethereum2AttestationsMeasureable!): String
    attestation: Ethereum2AttestationInfo!
    "Attestation Index (0 based ) in block"
    attestationIndex: Int!
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Block root hash"
    blockRoot(blockRootHash: [HashSelector!]): String!
    "Committee index for attestation"
    committeeIndex: Int!
    count(attestationEpoch: [IntegerSelector!], attestationSlot: [IntegerSelector!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, committeeIndex: [IntegerSelector!], date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2AttestationsUniq, validatorIndex: [IntegerSelector!]): Int
    countBigInt(attestationEpoch: [IntegerSelector!], attestationSlot: [IntegerSelector!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, committeeIndex: [IntegerSelector!], date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2AttestationsUniq, validatorIndex: [IntegerSelector!]): BigInt
    "Calendar date"
    date: Date
    "Block Eth1 information"
    eth1: Ethereum2Eth1Info!
    maximum(get: Ethereum2AttestationsMeasureable, of: Ethereum2AttestationsMeasureable!): String
    minimum(get: Ethereum2AttestationsMeasureable, of: Ethereum2AttestationsMeasureable!): String
    "Block parent hash"
    parentRoot: String!
    "Block proposer"
    proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
    "Block state root hash"
    stateRoot: String!
    "Validator"
    validator: Ethereum2ValidatorInfo!
    "Sequential index of validator in committee ( 0-based)"
    validatorInCommitteeIndex: Int!
}

"AttestationFieldInfo for Ethereum v 2.0 network"
type Ethereum2AttestationFieldInfo {
    epoch: Int!
    "Root Hash"
    root: String!
}

"AttestationInfo for Ethereum v 2.0 network"
type Ethereum2AttestationInfo {
    beaconBlockRoot: String!
    epoch: Int!
    signature: String!
    slot: Int!
    source: Ethereum2AttestationFieldInfo!
    target: Ethereum2AttestationFieldInfo!
}

"Attester Slashing in Ethereum v2.0 blockchain"
type Ethereum2AttesterSlashing {
    any(of: Ethereum2AttesterSlashingMeasureable!): String
    attestation: Ethereum2AttestationInfo!
    "Attestation slashing sequential number"
    attestationOrder: Int!
    "Attester Slashing Index (0 based ) in block"
    attesterSlashingIndex: Int!
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Block root hash"
    blockRoot(blockRootHash: [HashSelector!]): String!
    count(attestationEpoch: [IntegerSelector!], attestationSlot: [IntegerSelector!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2AttesterSlashingsUniq, validatorIndex: [IntegerSelector!]): Int
    countBigInt(attestationEpoch: [IntegerSelector!], attestationSlot: [IntegerSelector!], blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2AttesterSlashingsUniq, validatorIndex: [IntegerSelector!]): BigInt
    "Calendar date"
    date: Date
    "Block Eth1 information"
    eth1: Ethereum2Eth1Info!
    maximum(get: Ethereum2AttesterSlashingMeasureable, of: Ethereum2AttesterSlashingMeasureable!): String
    minimum(get: Ethereum2AttesterSlashingMeasureable, of: Ethereum2AttesterSlashingMeasureable!): String
    "Block parent hash"
    parentRoot: String!
    "Block proposer"
    proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
    "Block state root hash"
    stateRoot: String!
    "Validator"
    validator: Ethereum2ValidatorInfo!
    "Validator index in slashing sequential numbern"
    validatorInAttestationIndex: Int!
}

"Blocks in Ethereum v2.0 blockchain"
type Ethereum2Blocks {
    any(of: Ethereum2BlocksMeasureable!): String
    attestationsCount(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): Int
    attestationsCountbigint(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): BigInt
    attesterSlashingsCount(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): Int
    attesterSlashingsCountbigint(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): BigInt
    "Block root hash"
    blockRoot(blockRootHash: [HashSelector!]): String!
    count(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2BlocksUniq): Int
    countBigInt(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2BlocksUniq): BigInt
    "Calendar date"
    date: Date
    depositsCount(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): Int
    depositsCountbigint(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): BigInt
    "Block Eth1 information"
    eth1: Ethereum2Eth1Info!
    "Graffiti"
    graffiti: String!
    "Block number (height) in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: Ethereum2BlocksMeasureable, of: Ethereum2BlocksMeasureable!): String
    minimum(get: Ethereum2BlocksMeasureable, of: Ethereum2BlocksMeasureable!): String
    "Block parent hash"
    parentRoot: String!
    "Block proposer"
    proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
    proposerSlashingsCount(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): Int
    proposerSlashingsCountbigint(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): BigInt
    "Randao Reveal"
    randaoReveal: String!
    "Block signature"
    signature: String!
    "Block state root hash"
    stateRoot: String!
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    voluntaryExitsCount(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): Int
    voluntaryExitsCountbigint(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector): BigInt
}

"Deposit in Ethereum v2.0 blockchain"
type Ethereum2Deposit {
    amount(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, time: DateTimeSelector, validatorIndex: [IntegerSelector!]): Float
    any(of: Ethereum2DepositsMeasureable!): String
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Block root hash"
    blockRoot(blockRootHash: [HashSelector!]): String!
    count(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2DepositsUniq): Int
    countBigInt(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2DepositsUniq): BigInt
    "Calendar date"
    date: Date
    "Deposit Index (0 based ) in block"
    depositIndex: Int!
    "Block Eth1 information"
    eth1: Ethereum2Eth1Info!
    maximum(get: Ethereum2DepositsMeasureable, of: Ethereum2DepositsMeasureable!): String
    minimum(get: Ethereum2DepositsMeasureable, of: Ethereum2DepositsMeasureable!): String
    "Block parent hash"
    parentRoot: String!
    proof: String!
    "Block proposer"
    proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
    signature: String!
    "Block state root hash"
    stateRoot: String!
    "Validator"
    validator: Ethereum2ValidatorInfo!
}

"Eth1 attributes for Ethereum v 2.0 network"
type Ethereum2Eth1Info {
    "Block Eth1 block hash"
    blockHash: String!
    "Block Eth1 deposit count"
    depositCount: Int!
    "Block Eth1 deposit root hash"
    depositRoot: String!
}

"Proposer Slashing in Ethereum v2.0 blockchain"
type Ethereum2ProposerSlashing {
    any(of: Ethereum2ProposerSlashingMeasureable!): String
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Block root hash"
    blockRoot(blockRootHash: [HashSelector!]): String!
    count(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, slashingEpoch: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], time: DateTimeSelector, uniq: Ethereum2ProposerSlashingsUniq): Int
    countBigInt(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, slashingEpoch: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], time: DateTimeSelector, uniq: Ethereum2ProposerSlashingsUniq): BigInt
    "Calendar date"
    date: Date
    "Block Eth1 information"
    eth1: Ethereum2Eth1Info!
    "Header slashing sequential numbern"
    headerOrder: Int!
    maximum(get: Ethereum2ProposerSlashingMeasureable, of: Ethereum2ProposerSlashingMeasureable!): String
    minimum(get: Ethereum2ProposerSlashingMeasureable, of: Ethereum2ProposerSlashingMeasureable!): String
    "Block parent hash"
    parentRoot: String!
    "Block proposer"
    proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
    "Proposer Slashing Index (0 based ) in block"
    proposerSlashingIndex: Int!
    slashing: Ethereum2SlashingInfo!
    "Block state root hash"
    stateRoot: String!
}

"SlashingInfo for Ethereum v 2.0 network"
type Ethereum2SlashingInfo {
    "Block body hash"
    bodyRoot: String!
    epoch: Int!
    "Block parent hash"
    parentRoot: String!
    "Block proposer"
    proposer: Ethereum2ValidatorInfo
    signature: String!
    slot: Int!
    "Block state root hash"
    stateRoot: String!
}

"Validator attributes for Ethereum v 2.0 network"
type Ethereum2ValidatorInfo {
    "Validator Index as Integer"
    index: Int!
    "Validator Pub Key"
    pubkey: String!
    "Validator Withdrawal"
    withdrawalCredentials: String!
}

"Voluntary Exit in Ethereum v2.0 blockchain"
type Ethereum2VoluntaryExit {
    any(of: Ethereum2VoluntaryExitsMeasureable!): String
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Block root hash"
    blockRoot(blockRootHash: [HashSelector!]): String!
    count(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2VoluntaryExitsUniq, validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): Int
    countBigInt(blockProposerIndex: [IntegerSelector!], blockRootHash: HashSelector, date: DateSelector, height: BlockSelector, time: DateTimeSelector, uniq: Ethereum2VoluntaryExitsUniq, validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): BigInt
    "Calendar date"
    date: Date
    "Block Eth1 information"
    eth1: Ethereum2Eth1Info!
    maximum(get: Ethereum2VoluntaryExitsMeasureable, of: Ethereum2VoluntaryExitsMeasureable!): String
    minimum(get: Ethereum2VoluntaryExitsMeasureable, of: Ethereum2VoluntaryExitsMeasureable!): String
    "Block parent hash"
    parentRoot: String!
    "Block proposer"
    proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
    "Signature"
    signature: String!
    "Block state root hash"
    stateRoot: String!
    "Validator"
    validator: Ethereum2ValidatorInfo!
    voluntaryExitEpoch: Int!
    "Voluntary Exit Index (0 based ) in block"
    voluntaryExitIndex: Int!
}

"Address detailed information for Ethereum network"
type EthereumAddressInfo {
    "Address"
    address: String
    "Annotations ( tags ), if exists"
    annotation: String
    "Smart Contract if exists on the address"
    smartContract: EthereumSmartContractInfo
}

"Blockchain address"
type EthereumAddressInfoWithBalance {
    "Address"
    address: String
    "Annotations ( tags ), if exists"
    annotation: String
    "DEPRECATED Current address balance"
    balance: Float
    "DEPRECATED Balances by currencies for the address"
    balances(currency: EthereumCurrencySelector, date: DateSelector, height: BlockSelectorRange, time: DateTimeSelector): [EthereumBalance!]
    "Smart Contract if exists on the address"
    smartContract: EthereumSmartContractInfoWithAttributes
}

"Arguments of Smart Contract Calls and Events"
type EthereumArguments {
    any(argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], as: EthereumArgumentsConvertable, caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, of: EthereumArgumentsMeasureable!, reference: [EthereumAddressSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractMethod: MethodSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, value: [ArgumentValueSelector!]): String
    "Method or event argument"
    argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."
    callDepth: String
    "Caller of the method invocation ( tx sender or another smart contract )"
    caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo
    "Counts and other metrics"
    count(argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, reference: [EthereumAddressSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractMethod: MethodSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, uniq: SmartContractArgumentsUniq, value: [ArgumentValueSelector!]): Int
    "Counts and other metrics"
    countBigInt(argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, reference: [EthereumAddressSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractMethod: MethodSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, uniq: SmartContractArgumentsUniq, value: [ArgumentValueSelector!]): BigInt
    "Calendar date"
    date: Date
    "External call executed explicitly by tx sender. Internal calls executed by smart contracts."
    external(external: Boolean): Boolean
    "Sequential index of value in array ( multi-dimensional)"
    index: String!
    maximum(argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], as: EthereumArgumentsConvertable, caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, get: EthereumArgumentsMeasureable, height: BlockSelector, of: EthereumArgumentsMeasureable!, reference: [EthereumAddressSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractMethod: MethodSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, value: [ArgumentValueSelector!]): String
    minimum(argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], as: EthereumArgumentsConvertable, caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, get: EthereumArgumentsMeasureable, height: BlockSelector, of: EthereumArgumentsMeasureable!, reference: [EthereumAddressSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractMethod: MethodSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, value: [ArgumentValueSelector!]): String
    number(argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], calculate: AmountAggregateFunction, caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, reference: [EthereumAddressSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractMethod: MethodSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, value: [ArgumentValueSelector!]): Float
    "Address value of method or event argument"
    reference(reference: [EthereumAddressSelector!]): EthereumAddressInfo
    "Smart contract being called"
    smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
    "Contract method or event"
    smartContractSignature(signatureType: SignatureTypeSelector, smartContractEvent: EventSelector, smartContractMethod: MethodSelector): Signature
    "True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."
    success(success: [Boolean!]): Boolean
    "Transaction where call happened"
    transaction(txFrom: [EthereumAddressSelector!], txHash: [HashSelector!]): EthereumTransactionInfo
    "The Value of method or event argument"
    value(value: [ArgumentValueSelector!]): ArgumentValue
}

"Balance in a currency"
type EthereumBalance {
    "Currency of transfer"
    currency: Currency
    "History of balance changes by currencies for the address"
    history(currency: [EthereumCurrencySelector!], height: BlockSelectorRange): [EthereumBalanceChange!]
    value: Float
}

"Change of balance in a currency"
type EthereumBalanceChange {
    "Block number (height) in blockchain"
    block: Int!
    "Block timestamp"
    timestamp: ISO8601DateTime
    "Transfer amount ( positive inbound, negative outbound)"
    transferAmount: Float
    value: Float
}

"Blocks in Ethereum blockchain"
type EthereumBlocks {
    any(of: EthereumBlocksMeasureable!): String
    count(blockHash: HashSelector, blockReward: [AmountSelector!], date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], uniq: EthereumBlocksUniq): Int
    countBigInt(blockHash: HashSelector, blockReward: [AmountSelector!], date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], uniq: EthereumBlocksUniq): BigInt
    "Calendar date"
    date: Date
    difficulty(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Float
    "Block hash"
    hash(blockHash: [HashSelector!]): String!
    "Block number (height) in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: EthereumBlocksMeasureable, of: EthereumBlocksMeasureable!): String
    "Block miner"
    miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
    minimum(get: EthereumBlocksMeasureable, of: EthereumBlocksMeasureable!): String
    "Block nonce"
    nonce: Int!
    "Parent block hash"
    parentHash: String!
    reward(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Float
    "Currency of reward"
    rewardCurrency: Currency
    size(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Int
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    totalDifficulty(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Float
    transactionCount(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Int
    transactionCountbigint(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): BigInt
    uncleCount(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): Int
    uncleCountbigint(blockHash: HashSelector, blockReward: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, miner: [EthereumAddressSelector!], size: [IntegerSelector!], time: DateTimeSelector, transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!]): BigInt
}

"Coinpath"
type EthereumCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: EthereumAddressInfo
    "Sender address"
    sender: EthereumAddressInfo
    "Transaction of transfer happened"
    transaction: TransactionHashValue
    "Attributes of transaction included in Coinpath result"
    transactions: [CoinpathEntry!]
}

"Ethereum DEX attributes"
type EthereumDex {
    "Address for DEX exchange identification"
    address: Address!
    "Full name ( name for known, Protocol for unknown )"
    fullName: String!
    "Full name ( name for known, Protocol / address for unknown )"
    fullNameWithId: String!
    "Name for known exchanges"
    name: String
}

"Trades on DEX smart contracts"
type EthereumDexTrades {
    "Trader (maker or taker)"
    address(makerOrTaker: [EthereumAddressSelector!]): EthereumAddressInfo
    any(of: EthereumDexTradesMeasureable!): String
    baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Base currency"
    baseCurrency(baseCurrency: [EthereumCurrencySelector!]): Currency
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): BlockExtended
    buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Maker buys this currency"
    buyCurrency(buyCurrency: [EthereumCurrencySelector!]): Currency
    count(baseCurrency: [EthereumCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [EthereumCurrencySelector!], date: DateSelector, exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [EthereumAddressSelector!], makerOrTaker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [EthereumCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [EthereumCurrencySelector!], smartContractAddress: [EthereumAddressSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], uniq: EthereumDexTradesUniq): Int
    countBigInt(baseCurrency: [EthereumCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [EthereumCurrencySelector!], date: DateSelector, exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [EthereumAddressSelector!], makerOrTaker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [EthereumCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [EthereumCurrencySelector!], smartContractAddress: [EthereumAddressSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], uniq: EthereumDexTradesUniq): BigInt
    "Calendar date"
    date: Date
    "Identification of admin / manager / factory of smart contract, executing trades"
    exchange(exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!]): EthereumDex
    gas(baseCurrency: [EthereumCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [EthereumCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [EthereumAddressSelector!], makerOrTaker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [EthereumCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [EthereumCurrencySelector!], smartContractAddress: [EthereumAddressSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float
    "Gas price in Gwei"
    gasPrice(baseCurrency: [EthereumCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [EthereumCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [EthereumAddressSelector!], makerOrTaker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [EthereumCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [EthereumCurrencySelector!], smartContractAddress: [EthereumAddressSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float!
    gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Trade 'maker' side"
    maker(maker: [EthereumAddressSelector!]): EthereumAddressInfo
    maximum(get: EthereumDexTradesMeasureable, of: EthereumDexTradesMeasureable!): String
    minimum(get: EthereumDexTradesMeasureable, of: EthereumDexTradesMeasureable!): String
    price(baseCurrency: [EthereumCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [EthereumCurrencySelector!], calculate: PriceAggregateFunction, date: DateSelector, exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [EthereumAddressSelector!], makerOrTaker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [EthereumCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [EthereumCurrencySelector!], smartContractAddress: [EthereumAddressSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float
    "Protocol name of the smart contract"
    protocol(protocol: [StringSelector!]): String
    quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Quote currency"
    quoteCurrency(quoteCurrency: [EthereumCurrencySelector!]): Currency
    quotePrice(baseCurrency: [EthereumCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [EthereumCurrencySelector!], calculate: PriceAggregateFunction, date: DateSelector, exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [EthereumAddressSelector!], makerOrTaker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [EthereumCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [EthereumCurrencySelector!], smartContractAddress: [EthereumAddressSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float
    sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Maker sells this currency"
    sellCurrency(sellCurrency: [EthereumCurrencySelector!]): Currency
    "Side of trade ( SELL / BUY )"
    side: TradeSide
    "Smart contract being called"
    smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
    "Trade 'taker' side"
    taker(taker: [EthereumAddressSelector!]): EthereumAddressInfo
    "Time interval"
    timeInterval: TimeInterval
    tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float
    "Index of trade in transaction, used to separate trades in transaction"
    tradeIndex(tradeIndex: [StringSelector!]): String
    "Transaction of DexTrade"
    transaction(txHash: [HashSelector!], txSender: [EthereumAddressSelector!]): EthereumTransactionInfoExtended
}

"Ethereum smart contract"
type EthereumSmartContract {
    "Smart Contract Address"
    address: Address!
    "Smart Contract Type"
    contractType: SmartContractType
    "Token implemented in this smart contract"
    currency: Currency
    "Smart Contract Protocol Type"
    protocolType: String
}

"Smart Contract Calls"
type EthereumSmartContractCalls {
    amount(calculate: AmountAggregateFunction, caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, success: [Boolean!], time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): Float
    any(of: EthereumCallsMeasureable!): String
    "Call arguments"
    arguments: [ArgumentNameValue!]
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."
    callDepth: String
    "Caller of the method invocation ( tx sender or another smart contract )"
    caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo
    "Counts and other metrics"
    count(caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, success: [Boolean!], time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, uniq: SmartContractCallsUniq): Int
    "Counts and other metrics"
    countBigInt(caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, success: [Boolean!], time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, uniq: SmartContractCallsUniq): BigInt
    "Calendar date"
    date: Date
    "External call executed explicitly by tx sender. Internal calls executed by smart contracts."
    external(external: Boolean): Boolean
    "Gas used for transaction in external call, or by methd in internal call"
    gasValue(calculate: AmountAggregateFunction, caller: [EthereumAddressSelector!], date: DateSelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, success: [Boolean!], time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): Float
    maximum(get: EthereumCallsMeasureable, of: EthereumCallsMeasureable!): String
    minimum(get: EthereumCallsMeasureable, of: EthereumCallsMeasureable!): String
    "Smart contract being called"
    smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
    "Contract method invoked"
    smartContractMethod(smartContractMethod: MethodSelector): Method
    "True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."
    success(success: [Boolean!]): Boolean
    "Transaction where call happened"
    transaction(txFrom: [EthereumAddressSelector!], txHash: [HashSelector!]): EthereumTransactionInfo
}

"Smart Contract Events"
type EthereumSmartContractEvent {
    any(of: EthereumEventsMeasureable!): String
    "Event arguments"
    arguments: [ArgumentNameValue!]
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Counts and other metrics"
    count(date: DateSelector, height: BlockSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractType: SmartContractTypeSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, uniq: SmartContractCallsUniq): Int
    "Counts and other metrics"
    countBigInt(date: DateSelector, height: BlockSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, smartContractType: SmartContractTypeSelector, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, uniq: SmartContractCallsUniq): BigInt
    "Calendar date"
    date: Date
    "Event index"
    eventIndex: String
    maximum(get: EthereumEventsMeasureable, of: EthereumEventsMeasureable!): String
    minimum(get: EthereumEventsMeasureable, of: EthereumEventsMeasureable!): String
    "Smart contract being called"
    smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
    "Contract event logged"
    smartContractEvent(smartContractEvent: EventSelector): Event
    "Transaction where event happened"
    transaction(txFrom: [EthereumAddressSelector!], txHash: [HashSelector!]): EthereumTransactionInfo
}

"Blockchain smart contract"
type EthereumSmartContractInfo {
    "Smart Contract Type"
    contractType: SmartContractType
    "Token implemented in this smart contract"
    currency: Currency
    "Smart Contract Protocol Type"
    protocolType: String
}

"Blockchain smart contract"
type EthereumSmartContractInfoWithAttributes {
    "Attributes from readonly methods"
    attributes: [SmartContractReadonlyAttribute!]
    "Smart Contract Type"
    contractType: SmartContractType
    "Token implemented in this smart contract"
    currency: Currency
    "Smart Contract Protocol Type"
    protocolType: String
}

"Blockchain transaction info"
type EthereumTransactionInfo {
    "Gas consumed"
    gas: Int!
    "Gas price in Gwei"
    gasPrice: Float!
    "Gas value cost"
    gasValue: Float!
    "Hash hex representation"
    hash: String!
    "Transaction from address"
    txFrom: EthereumAddressInfo!
}

"Blockchain Transaction Extended info"
type EthereumTransactionInfoExtended {
    "Gas consumed"
    gas: Int!
    "Gas price in Gwei"
    gasPrice: Float!
    "Gas value cost"
    gasValue: Float!
    "Hash hex representation"
    hash: String!
    "Transaction index in block, 0 based"
    index: Int
    "Transaction nonce"
    nonce: Int
    "Transaction receiver"
    to: EthereumAddressInfo
    "Transaction from address"
    txFrom: EthereumAddressInfo!
}

"Transactions in Ethereum blockchain"
type EthereumTransactions {
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], height: BlockSelector, in: BaseCurrencyEnum, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float
    any(of: EthereumTransactionsMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(amount: [AmountSelector!], date: DateSelector, gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], height: BlockSelector, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], uniq: EthereumTransactionsUniq): Int
    countBigInt(amount: [AmountSelector!], date: DateSelector, gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], height: BlockSelector, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], uniq: EthereumTransactionsUniq): BigInt
    "Created smart contract"
    creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo
    "Currency of amount"
    currency: Currency
    "Calendar date"
    date: Date
    "Error message if any"
    error: String
    gas(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], height: BlockSelector, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float
    "Currency of gas"
    gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency
    "Gas price in Gwei"
    gasPrice(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], height: BlockSelector, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float!
    gasValue(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], height: BlockSelector, in: BaseCurrencyEnum, success: Boolean, time: DateTimeSelector, txCreates: [EthereumAddressSelector!], txHash: HashSelector, txIndex: TxIndexSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!]): Float
    "Hash hex representation"
    hash(txHash: [HashSelector!]): String!
    "Transaction index in block, 0 based"
    index(txIndex: [TxIndexSelector!]): Int
    maximum(get: EthereumTransactionsMeasureable, of: EthereumTransactionsMeasureable!): String
    minimum(get: EthereumTransactionsMeasureable, of: EthereumTransactionsMeasureable!): String
    "Transaction nonce"
    nonce: Int
    "Transaction sender"
    sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo
    "Success"
    success(success: Boolean): Boolean
    "Transaction receiver"
    to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
}

"Currency transfers from/to addresses in crypto currencies"
type EthereumTransfers {
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, currency: [EthereumCurrencySelector!], date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, receiver: [EthereumAddressSelector!], sender: [EthereumAddressSelector!], success: Boolean, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): Float
    any(of: EthereumTransfersMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(amount: [AmountSelector!], currency: [EthereumCurrencySelector!], date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, receiver: [EthereumAddressSelector!], sender: [EthereumAddressSelector!], success: Boolean, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, uniq: TransfersUniq): Int
    countBigInt(amount: [AmountSelector!], currency: [EthereumCurrencySelector!], date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, receiver: [EthereumAddressSelector!], sender: [EthereumAddressSelector!], success: Boolean, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector, uniq: TransfersUniq): BigInt
    "Currency of transfer"
    currency(currency: [EthereumCurrencySelector!]): Currency
    "Calendar date"
    date: Date
    "Entity identifier ( for ERC-721 NFT tokens )"
    entityId(entityId: EntitySelector): String
    "External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts."
    external(external: Boolean): Boolean
    gasValue(amount: [AmountSelector!], calculate: AmountAggregateFunction, currency: [EthereumCurrencySelector!], date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, receiver: [EthereumAddressSelector!], sender: [EthereumAddressSelector!], success: Boolean, time: DateTimeSelector, txFrom: [EthereumAddressSelector!], txHash: HashSelector): Float
    maximum(get: EthereumTransfersMeasureable, of: EthereumTransfersMeasureable!): String
    minimum(get: EthereumTransfersMeasureable, of: EthereumTransfersMeasureable!): String
    "Transfer receiver"
    receiver(receiver: [EthereumAddressSelector!]): EthereumAddressInfo
    "Transfer sender"
    sender(sender: [EthereumAddressSelector!]): EthereumAddressInfo
    "Success flag"
    success(success: Boolean): Boolean
    "Transaction where transfer happened"
    transaction(txFrom: [EthereumAddressSelector!], txHash: [HashSelector!]): EthereumTransactionInfo
}

"Smart contract event"
type Event {
    "Name"
    name: String
    "Signature"
    signature: String
    "Signature Hash"
    signatureHash: String!
}

"Solana External Action"
type ExternalAction {
    name: String!
}

"Filecoin"
type Filecoin {
    "Filecoin Network Blocks"
    blocks(any: [FilecoinBlockFilter!], blockHash: HashSelector, blockIndex: IntegerSelector, date: DateSelector, height: BlockSelector, miner: [AddressSelector!], options: QueryOptions, time: DateTimeSelector): [FilecoinBlock!]
    "Filecoin Network Calls"
    calls(amount: AmountSelector, any: [FilecoinCallFilter!], date: DateSelector, hash: HashSelector, height: BlockSelector, messageMethod: IntegerSelector, method: IntegerSelector, options: QueryOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [FilecoinCalls!]
    "Money flow using Coinpath technology"
    coinpath(date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [FilecoinCoinpath!]
    "Filecoin Network Messages ( blocks, transfers, ... )"
    messages(amount: AmountSelector, any: [FilecoinMessageFilter!], date: DateSelector, hash: HashSelector, height: BlockSelector, index: IntegerSelector, method: IntegerSelector, options: QueryOptions, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): [FilecoinMessages!]
    "Filecoin Network Currency Transfers"
    transfers(amount: AmountSelector, any: [FilecoinTransferFilter!], date: DateSelector, hash: HashSelector, height: BlockSelector, messageMethod: IntegerSelector, method: IntegerSelector, options: QueryOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector, transferType: TransferTypeSelector): [FilecoinTransfers!]
}

"Block"
type FilecoinBlock {
    any(of: FilecoinBlocksMeasureable!): String
    blockSig: NameWithId
    blsAggregate: NameWithId
    count(blockHash: HashSelector, blockIndex: IntegerSelector, date: DateSelector, height: BlockSelector, miner: [AddressSelector!], time: DateTimeSelector, uniq: FilecoinBlockUniq): Int
    countBigInt(blockHash: HashSelector, blockIndex: IntegerSelector, date: DateSelector, height: BlockSelector, miner: [AddressSelector!], time: DateTimeSelector, uniq: FilecoinBlockUniq): BigInt
    "Calendar date"
    date: Date
    electionProof: String
    forkSignalling: BigInt
    "Block hash"
    hash(blockHash: [HashSelector!]): String!
    "Block round in blockchain"
    height(height: BlockSelector): Int!
    "Block index on height"
    index(blockIndex: IntegerSelector): Int
    maximum(get: FilecoinBlocksMeasureable, of: FilecoinBlocksMeasureable!): String
    messageCount(blockHash: HashSelector, blockIndex: IntegerSelector, date: DateSelector, height: BlockSelector, miner: [AddressSelector!], time: DateTimeSelector): Int
    messageCountbigint(blockHash: HashSelector, blockIndex: IntegerSelector, date: DateSelector, height: BlockSelector, miner: [AddressSelector!], time: DateTimeSelector): BigInt
    messages: String
    "Miner"
    miner(miner: AddressSelector): Address
    minerTips(blockHash: HashSelector, blockIndex: IntegerSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, miner: [AddressSelector!], time: DateTimeSelector): Float
    minimum(get: FilecoinBlocksMeasureable, of: FilecoinBlocksMeasureable!): String
    parentMessageReceipts: String
    parentStateRoot: String
    parentWeight: BigInt
    reward(blockHash: HashSelector, blockIndex: IntegerSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, miner: [AddressSelector!], time: DateTimeSelector): Float
    ticket: String
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    totalReward(blockHash: HashSelector, blockIndex: IntegerSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, miner: [AddressSelector!], time: DateTimeSelector): Float
    winCount(blockHash: HashSelector, blockIndex: IntegerSelector, date: DateSelector, height: BlockSelector, miner: [AddressSelector!], time: DateTimeSelector): Int
    winCountbigint(blockHash: HashSelector, blockIndex: IntegerSelector, date: DateSelector, height: BlockSelector, miner: [AddressSelector!], time: DateTimeSelector): BigInt
    wincount: Int
}

"Calls in Filecoin blockchain"
type FilecoinCalls {
    amount(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, messageMethod: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): Float
    any(of: FilecoinCallsMeasureable!): String
    "Block where transfer Message is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Call hash"
    callHash: String
    "Call hash"
    callPath: String
    count(amount: AmountSelector, date: DateSelector, hash: HashSelector, height: BlockSelector, messageMethod: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector, uniq: FilecoinMessagesUniq): Int
    countBigInt(amount: AmountSelector, date: DateSelector, hash: HashSelector, height: BlockSelector, messageMethod: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector, uniq: FilecoinMessagesUniq): BigInt
    "Calendar date"
    date: Date
    exitCode: BigInt
    gas(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Int
    gasFeeCap: BigInt
    gasLimit: BigInt
    gasPremium: Float
    "Message hash"
    hash(hash: HashSelector): String
    maximum(get: FilecoinCallsMeasureable, of: FilecoinCallsMeasureable!): String
    "Message Method"
    messageMethod(messageMethod: IntegerSelector): NameWithId
    "Method"
    method(method: IntegerSelector): NameWithId
    minedBlock: FilecoinMinedBlock
    minimum(get: FilecoinCallsMeasureable, of: FilecoinCallsMeasureable!): String
    nonce: BigInt
    "Message receiver"
    receiver(receiver: AddressSelector): AddressWithAccount
    returnValue: String
    "Message sender"
    sender(sender: AddressSelector): AddressWithAccount
    "Success"
    success(success: Boolean): Boolean
}

"Coinpath"
type FilecoinCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Message of transfer happened"
    message: TransactionHashValue
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: Address
    "Sender address"
    sender: Address
}

"Messages in Filecoin blockchain"
type FilecoinMessages {
    amount(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Float
    any(of: FilecoinMessagesMeasureable!): String
    baseFeeBurn(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Float
    "Block where transfer Message is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    burned(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Float
    count(amount: AmountSelector, date: DateSelector, hash: HashSelector, height: BlockSelector, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, uniq: FilecoinMessagesUniq): Int
    countBigInt(amount: AmountSelector, date: DateSelector, hash: HashSelector, height: BlockSelector, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, uniq: FilecoinMessagesUniq): BigInt
    "Calendar date"
    date: Date
    exitCode: BigInt
    gas(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Int
    gasFeeCap: BigInt
    gasLimit: BigInt
    gasPremium: Float
    "Message hash"
    hash(hash: HashSelector): String
    maximum(get: FilecoinMessagesMeasureable, of: FilecoinMessagesMeasureable!): String
    "Method"
    method(method: IntegerSelector): NameWithId
    minedBlock: FilecoinMinedBlock
    minerPenalty(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Float
    minerTip(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Float
    minimum(get: FilecoinMessagesMeasureable, of: FilecoinMessagesMeasureable!): String
    nonce: BigInt
    overEstimationBurn(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Float
    "Message receiver"
    receiver(receiver: AddressSelector): AddressWithAccount
    refund(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Float
    returnValue: String
    "Message sender"
    sender(sender: AddressSelector): AddressWithAccount
    signature: String
    signatureType: String
    "Signed Message hash"
    signedHash: String
    "Success"
    success(success: Boolean): Boolean
    totalCost(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, index: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector): Float
}

"Filecoin Mined Block"
type FilecoinMinedBlock {
    "Hash"
    hash: String
    "Index on height"
    index: Int
    "Miner"
    miner: Address
}

"Transfers in Filecoin blockchain"
type FilecoinTransfers {
    amount(amount: AmountSelector, calculate: AmountAggregateFunction, date: DateSelector, hash: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, messageMethod: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector, transferType: TransferTypeSelector): Float
    any(of: FilecoinTransfersMeasureable!): String
    "Block where transfer Transfer is included"
    block(height: BlockSelector, time: DateTimeSelector): BlockExtended
    "Call hash"
    callHash: String
    "Call hash"
    callPath: String
    count(amount: AmountSelector, date: DateSelector, hash: HashSelector, height: BlockSelector, messageMethod: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector, transferType: TransferTypeSelector, uniq: FilecoinMessagesUniq): Int
    countBigInt(amount: AmountSelector, date: DateSelector, hash: HashSelector, height: BlockSelector, messageMethod: IntegerSelector, method: IntegerSelector, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector, transferType: TransferTypeSelector, uniq: FilecoinMessagesUniq): BigInt
    "Currency of transfer"
    currency: Currency
    "Calendar date"
    date: Date
    "Message hash"
    hash(hash: HashSelector): String
    maximum(get: FilecoinTransfersMeasureable, of: FilecoinTransfersMeasureable!): String
    "Message Method"
    messageMethod(messageMethod: IntegerSelector): NameWithId
    "Method"
    method(method: IntegerSelector): NameWithId
    minimum(get: FilecoinTransfersMeasureable, of: FilecoinTransfersMeasureable!): String
    "Transfer receiver"
    receiver(receiver: AddressSelector): Address
    "Transfer sender"
    sender(sender: AddressSelector): Address
    "Transfer timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "Type of transfer"
    transferType(transferType: TransferTypeSelector): FilecoinTransferType
}

"Hedera Chain"
type Hedera {
    "Blockchain Arguments"
    arguments(any: [HederaArgumentFilter!], date: DateSelector, nodeAccount: StringSelector, options: QueryOptions, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): [HederaArgument!]
    "Blockhain Calls"
    calls(any: [HederaCallFilter!], callInput: HashSelector, callResult: HashSelector, date: DateSelector, nodeAccount: StringSelector, options: QueryOptions, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): [HederaCall!]
    "Money flow using Coinpath technology"
    coinpath(date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [HederaCoinpath!]
    "Blockhain Inputs"
    inputs(amount: [AmountSelector!], any: [HederaInputFilter!], date: DateSelector, entityType: EntityTypeSelector, nodeAccount: StringSelector, options: QueryOptions, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): [HederaInput!]
    "Blockhain Messages"
    messages(any: [HederaMessageFilter!], date: DateSelector, entityType: EntityTypeSelector, nodeAccount: StringSelector, options: QueryOptions, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transactionRunningHash: HashSelector): [HederaMessage!]
    "Blockchain Outputs"
    outputs(any: [HederaOutputFilter!], date: DateSelector, entityType: EntityTypeSelector, nodeAccount: StringSelector, options: QueryOptions, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): [HederaOutput!]
    "Blockchain Transactions"
    transactions(any: [HederaTransactionFilter!], date: DateSelector, entityType: EntityTypeSelector, nodeAccount: StringSelector, options: QueryOptions, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector): [HederaTransaction!]
}

"Arguments in Hedera blockchain"
type HederaArgument {
    any(of: HederaArgumentsMeasureable!): String
    "Argument type"
    argtype: String
    "Argument"
    argument: String
    chargedTxFee: BigInt
    consensusTimestamp: Timestamp
    count(uniq: HederaArgumentsUniq): Int
    countBigInt(uniq: HederaArgumentsUniq): BigInt
    "Calendar date"
    date: Date
    "Currency of transfer"
    feeCurrency: Currency
    initialBalance(calculate: AmountAggregateFunction, date: DateSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): Float
    maxFee(calculate: AmountAggregateFunction, date: DateSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): Float
    maximum(get: HederaArgumentsMeasureable, of: HederaArgumentsMeasureable!): String
    memo: String
    minimum(get: HederaArgumentsMeasureable, of: HederaArgumentsMeasureable!): String
    """

    Used to reference a specific
    account of the node the transaction is being sent to
    """
    nodeAccount: Account
    """

    Used to
    reference a specific account in transactions
    """
    payerAccount: Account
    "Transaction result"
    result(result: HashSelector): TransactionResult
    "Smart contract"
    smartContractEntity: Account
    "Success"
    success(success: Boolean): Boolean
    transactionBytes: String
    transactionFee(calculate: AmountAggregateFunction, date: DateSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): Float
    "Transaction hash where transfer happened"
    transactionHash(transactionHash: HashSelector): String
    transactionValidDurationInSec: Int
    validStart(nanoseconds: BigInt, time: DateTimeSelector): Timestamp
    "Value"
    value: String
}

"Calls in Hedera blockchain"
type HederaCall {
    any(of: HederaCallsMeasureable!): String
    "Call input"
    callInput(callInput: HashSelector): String
    "Call input"
    callResult(callResult: HashSelector): String
    chargedTxFee: BigInt
    consensusTimestamp: Timestamp
    count(uniq: HederaCallsUniq): Int
    countBigInt(uniq: HederaCallsUniq): BigInt
    "Calendar date"
    date: Date
    "Currency of transfer"
    feeCurrency: Currency
    gas(calculate: AmountAggregateFunction, callInput: HashSelector, callResult: HashSelector, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): Int
    initialBalance(calculate: AmountAggregateFunction, date: DateSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): Float
    maxFee(calculate: AmountAggregateFunction, date: DateSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): Float
    maximum(get: HederaCallsMeasureable, of: HederaCallsMeasureable!): String
    memo: String
    minimum(get: HederaCallsMeasureable, of: HederaCallsMeasureable!): String
    """

    Used to reference a specific
    account of the node the transaction is being sent to
    """
    nodeAccount: Account
    """

    Used to
    reference a specific account in transactions
    """
    payerAccount: Account
    "Transaction result"
    result(result: HashSelector): TransactionResult
    "Smart contract"
    smartContractEntity: Account
    "Success"
    success(success: Boolean): Boolean
    transactionBytes: String
    transactionFee(calculate: AmountAggregateFunction, date: DateSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, smartContractEntity: StringSelector, success: Boolean, transactionHash: HashSelector): Float
    "Transaction hash where transfer happened"
    transactionHash(transactionHash: HashSelector): String
    transactionValidDurationInSec: Int
    validStart(nanoseconds: BigInt, time: DateTimeSelector): Timestamp
}

"Coinpath"
type HederaCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: Address
    "Sender address"
    sender: Address
    "Attributes of transaction included in Coinpath result"
    transactions: [CoinpathEntry!]
}

"Inputs in Hedera blockchain"
type HederaInput {
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): Float
    any(of: HederaInputMeasureable!): String
    consensusTimestamp: Timestamp
    count(uniq: HederaInputsUniq): Int
    countBigInt(uniq: HederaInputsUniq): BigInt
    "Currency of transfer"
    currency(currency: HederaCurrencySelector): Currency
    "Calendar date"
    date: Date
    "Entity"
    entity(entityType: EntityTypeSelector): Entity
    "Currency of transfer"
    feeCurrency: Currency
    initialBalance(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): Float
    maxFee(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): Float
    maximum(get: HederaInputMeasureable, of: HederaInputMeasureable!): String
    memo: String
    minimum(get: HederaInputMeasureable, of: HederaInputMeasureable!): String
    """

    Used to reference a specific
    account of the node the transaction is being sent to
    """
    nodeAccount: Account
    """

    Used to
    reference a specific account in transactions
    """
    payerAccount: Account
    "Transaction result"
    result(result: HashSelector): TransactionResult
    "Success"
    success(success: Boolean): Boolean
    "Calendar time"
    time: DateTime
    transactionFee(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): Float
    "Transaction hash where transfer happened"
    transactionHash(transactionHash: HashSelector): String
    transactionValidDurationInSec: Int
    "Transfer Account"
    transferEntity: Account
    validStart(nanoseconds: BigInt, time: DateTimeSelector): Timestamp
}

"Messages in Hedera blockchain"
type HederaMessage {
    any(of: HederaMessageMeasureable!): String
    consensusTimestamp: Timestamp
    count(uniq: HederaMessagesUniq): Int
    countBigInt(uniq: HederaMessagesUniq): BigInt
    "Calendar date"
    date: Date
    "Entity"
    entity(entityType: EntityTypeSelector): Entity
    "Currency of transfer"
    feeCurrency: Currency
    initialBalance(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transactionRunningHash: HashSelector): Float
    maxFee(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transactionRunningHash: HashSelector): Float
    maximum(get: HederaMessageMeasureable, of: HederaMessageMeasureable!): String
    memo: String
    message: String
    minimum(get: HederaMessageMeasureable, of: HederaMessageMeasureable!): String
    """

    Used to reference a specific
    account of the node the transaction is being sent to
    """
    nodeAccount: Account
    """

    Used to
    reference a specific account in transactions
    """
    payerAccount: Account
    "Transaction result"
    result(result: HashSelector): TransactionResult
    "Success"
    success(success: Boolean): Boolean
    "Calendar date time"
    time: DateTime
    "Transaction running hash"
    topicRunningHash(topicRunningHash: StringSelector): String
    "Transaction running hash"
    topicSequenceNumber(topicSequenceNumber: HashSelector): String
    transactionFee(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transactionRunningHash: HashSelector): Float
    "Transaction hash where transfer happened"
    transactionHash(transactionHash: HashSelector): String
    transactionValidDurationInSec: Int
    validStart(nanoseconds: BigInt, time: DateTimeSelector): Timestamp
}

"Outputs in Hedera blockchain"
type HederaOutput {
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): Float
    any(of: HederaOutputMeasureable!): String
    consensusTimestamp: Timestamp
    count(uniq: HederaOutputUniq): Int
    countBigInt(uniq: HederaOutputUniq): BigInt
    "Currency of transfer"
    currency(currency: HederaCurrencySelector): Currency
    "Calendar date"
    date: Date
    "Entity"
    entity(entityType: EntityTypeSelector): Entity
    "Currency of transfer"
    feeCurrency: Currency
    initialBalance(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): Float
    maxFee(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): Float
    maximum(get: HederaOutputMeasureable, of: HederaOutputMeasureable!): String
    memo: String
    minimum(get: HederaOutputMeasureable, of: HederaOutputMeasureable!): String
    """

    Used to reference a specific
    account of the node the transaction is being sent to
    """
    nodeAccount: Account
    """

    Used to
    reference a specific account in transactions
    """
    payerAccount: Account
    "Transaction result"
    result(result: HashSelector): TransactionResult
    "Success"
    success(success: Boolean): Boolean
    "Calendar time"
    time: DateTime
    transactionFee(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector, transferEntity: StringSelector): Float
    "Transaction hash where transfer happened"
    transactionHash(transactionHash: HashSelector): String
    transactionValidDurationInSec: Int
    "Transfer Account"
    transferEntity: Account
    validStart(nanoseconds: BigInt, time: DateTimeSelector): Timestamp
}

"Transactions in Hedera blockchain"
type HederaTransaction {
    any(of: HederaTransactionMeasureable!): String
    consensusTimestamp: Timestamp
    count(uniq: HederaTransactionsUniq): Int
    countBigInt(uniq: HederaTransactionsUniq): BigInt
    "Calendar date"
    date: Date
    "Entity"
    entity(entityType: EntityTypeSelector): Entity
    "Currency of transfer"
    feeCurrency: Currency
    initialBalance(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector): Float
    maxFee(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector): Float
    maximum(get: HederaTransactionMeasureable, of: HederaTransactionMeasureable!): String
    memo: String
    minimum(get: HederaTransactionMeasureable, of: HederaTransactionMeasureable!): String
    """

    Used to reference a specific
    account of the node the transaction is being sent to
    """
    nodeAccount: Account
    """

    Used to
    reference a specific account in transactions
    """
    payerAccount: Account
    "Transaction result"
    result(result: HashSelector): TransactionResult
    "Success"
    success(success: Boolean): Boolean
    "Calendar time"
    time: DateTime
    transactionBytes: String
    transactionFee(calculate: AmountAggregateFunction, date: DateSelector, entityType: EntityTypeSelector, in: BaseCurrencyEnum, nodeAccount: StringSelector, payerAccount: StringSelector, result: HashSelector, success: Boolean, transactionHash: HashSelector): Float
    "Transaction hash where transfer happened"
    transactionHash(transactionHash: HashSelector): String
    "Transaction Type"
    transactionType: String
    transactionValidDurationInSec: Int
    validStart(nanoseconds: BigInt, time: DateTimeSelector): Timestamp
}

"Input Script Type of UTXO transaction input"
type InputScript {
    "Script annotation"
    annotation: String
    "Long script pattern"
    pattern: String!
    "Short script pattern"
    shortPattern: String!
    "Simple script pattern"
    simplePattern: String!
    "Script type"
    type: BitcoinInputScriptType
}

"Libra"
type Libra {
    "Libra Network Blocks"
    blocks(any: [LibraBlockFilter!], date: DateSelector, height: BlockSelector, metadata: StringSelector, options: QueryOptions, proposer: [AddressSelector!], time: DateTimeSelector, version: IntegerSelector): [LibraBlock!]
    "Money flow using Coinpath technology"
    coinpath(currency: [LibraCurrencySelector!], date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [LibraCoinpath!]
    "Libra Network Currency Minting"
    mints(amount: [AmountSelector!], any: [LibraMintFilter!], block: BlockSelector, currency: [LibraCurrencySelector!], date: DateSelector, minter: AddressSelector, options: QueryOptions, time: DateTimeSelector, version: IntegerSelector): [LibraMints!]
    "Libra Network Transactions"
    transactions(any: [LibraTransactionFilter!], date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, options: QueryOptions, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, time: DateTimeSelector, txSender: AddressSelector, version: IntegerSelector): [LibraTransactions!]
    "Libra Network Currency Transfers"
    transfers(amount: [AmountSelector!], any: [LibraTransferFilter!], currency: [LibraCurrencySelector!], date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, options: QueryOptions, receiver: AddressSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, sender: AddressSelector, time: DateTimeSelector, txSender: AddressSelector, version: IntegerSelector): [LibraTransfers!]
}

"Block"
type LibraBlock {
    any(of: LibraBlocksMeasureable!): String
    count(date: DateSelector, height: BlockSelector, metadata: StringSelector, proposer: [AddressSelector!], time: DateTimeSelector, uniq: LibraBlockUniq, version: IntegerSelector): Int
    countBigInt(date: DateSelector, height: BlockSelector, metadata: StringSelector, proposer: [AddressSelector!], time: DateTimeSelector, uniq: LibraBlockUniq, version: IntegerSelector): BigInt
    "Calendar date"
    date: Date
    gasUsed(calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, metadata: StringSelector, proposer: [AddressSelector!], time: DateTimeSelector, version: IntegerSelector): Float
    "Block round in blockchain"
    height(height: BlockSelector): Int!
    "Key"
    key: String
    maximum(get: LibraBlocksMeasureable, of: LibraBlocksMeasureable!): String
    "Metadata"
    metadata(metadata: StringSelector): String
    minimum(get: LibraBlocksMeasureable, of: LibraBlocksMeasureable!): String
    "Proposer"
    proposer(proposer: AddressSelector): Address
    "Sequence number"
    sequenceNumber: Int
    "Status Name"
    statusName: String
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "Version of transaction for this block"
    version(version: IntegerSelector): Int!
    "Version hash of transaction for this block"
    versionHash: String!
    "VM Status"
    vmStatus: Int
}

"Coinpath"
type LibraCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: LibraCoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: LibraCoinpathMeasureable, of: LibraCoinpathMeasureable!): String
    minimum(get: LibraCoinpathMeasureable, of: LibraCoinpathMeasureable!): String
    "Receiver address"
    receiver: Address
    "Sender address"
    sender: Address
    "Transaction of transfer happened"
    transaction: LibraTransactionValue
}

"Mints in Libra blockchain"
type LibraMints {
    amount(amount: [AmountSelector!], block: BlockSelector, calculate: AmountAggregateFunction, currency: [LibraCurrencySelector!], date: DateSelector, minter: AddressSelector, time: DateTimeSelector, version: IntegerSelector): Float
    any(of: LibraMintsMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(amount: [AmountSelector!], block: BlockSelector, currency: [LibraCurrencySelector!], date: DateSelector, minter: AddressSelector, time: DateTimeSelector, uniq: LibraMintsUniq, version: IntegerSelector): Int
    countBigInt(amount: [AmountSelector!], block: BlockSelector, currency: [LibraCurrencySelector!], date: DateSelector, minter: AddressSelector, time: DateTimeSelector, uniq: LibraMintsUniq, version: IntegerSelector): BigInt
    "Currency of transfer"
    currency(currency: [LibraCurrencySelector!]): Currency
    "Calendar date"
    date: Date
    maximum(get: LibraMintsMeasureable, of: LibraMintsMeasureable!): String
    minimum(get: LibraMintsMeasureable, of: LibraMintsMeasureable!): String
    "Minter"
    minter(sender: AddressSelector): Address
    "Sequence number"
    sequenceNumber: Int
    "Status Name"
    statusName: String
    "Success"
    success(success: Boolean): Boolean
    "Mint timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "Version of blockchain for this transaction"
    version(version: IntegerSelector): Int!
    "Version hash of blockchain for this transaction"
    versionHash: String!
    "VM Status"
    vmStatus: Int
}

"Blockchain transaction with value"
type LibraTransactionValue {
    "Transaction value"
    value: Float!
    "Transaction version"
    version: Int!
}

"Transactions in Libra blockchain"
type LibraTransactions {
    any(of: LibraTransactionsMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, time: DateTimeSelector, txSender: AddressSelector, uniq: LibraTransactionsUniq, version: IntegerSelector): Int
    countBigInt(date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, time: DateTimeSelector, txSender: AddressSelector, uniq: LibraTransactionsUniq, version: IntegerSelector): BigInt
    "Calendar date"
    date: Date
    "Expiration Time"
    expirationTime: DateTime
    gas(calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, time: DateTimeSelector, txSender: AddressSelector, version: IntegerSelector): Int
    "Currency of gas"
    gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency
    "Gas unit price"
    gasPrice(calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, time: DateTimeSelector, txSender: AddressSelector, version: IntegerSelector): Float!
    gasValue(calculate: AmountAggregateFunction, date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, time: DateTimeSelector, txSender: AddressSelector, version: IntegerSelector): Float
    "Max gas amount"
    maxGasAmount: Int
    maximum(get: LibraTransactionsMeasureable, of: LibraTransactionsMeasureable!): String
    minimum(get: LibraTransactionsMeasureable, of: LibraTransactionsMeasureable!): String
    "Public key"
    publicKey: String
    "Script Hash"
    scriptHash(scriptHash: StringSelector): String
    "Script Type"
    scriptType: ScriptTypeSelectorSelector
    "Transaction sender"
    sender(txSender: AddressSelector): Address
    "Sequence number"
    sequenceNumber: Int
    "Signature"
    signature: String
    "Signature scheme"
    signatureScheme: String
    "Status Name"
    statusName: String
    "Success"
    success(success: Boolean): Boolean
    "Transaction timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "Version of blockchain for this transaction"
    version(version: IntegerSelector): Int!
    "Version hash of blockchain for this transaction"
    versionHash: String!
    "VM Status"
    vmStatus: Int
}

"Transfers in Libra blockchain"
type LibraTransfers {
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, currency: [LibraCurrencySelector!], date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, receiver: AddressSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, sender: AddressSelector, time: DateTimeSelector, txSender: AddressSelector, version: IntegerSelector): Float
    any(of: LibraTransfersMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    count(amount: [AmountSelector!], currency: [LibraCurrencySelector!], date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, receiver: AddressSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, sender: AddressSelector, time: DateTimeSelector, txSender: AddressSelector, uniq: TransfersUniq, version: IntegerSelector): Int
    countBigInt(amount: [AmountSelector!], currency: [LibraCurrencySelector!], date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, receiver: AddressSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, sender: AddressSelector, time: DateTimeSelector, txSender: AddressSelector, uniq: TransfersUniq, version: IntegerSelector): BigInt
    "Currency of transfer"
    currency(currency: [LibraCurrencySelector!]): Currency
    "Calendar date"
    date: Date
    "Expiration Time"
    expirationTime: DateTime
    gas(amount: [AmountSelector!], calculate: AmountAggregateFunction, currency: [LibraCurrencySelector!], date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, receiver: AddressSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, sender: AddressSelector, time: DateTimeSelector, txSender: AddressSelector, version: IntegerSelector): Int
    "Currency of gas"
    gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency
    "Gas price"
    gasPrice: Float!
    gasValue(amount: [AmountSelector!], calculate: AmountAggregateFunction, currency: [LibraCurrencySelector!], date: DateSelector, gasCurrency: [LibraCurrencySelector!], height: BlockSelector, receiver: AddressSelector, scriptHash: StringSelector, scriptType: ScriptTypeSelectorSelector, sender: AddressSelector, time: DateTimeSelector, txSender: AddressSelector, version: IntegerSelector): Float
    "Max gas amount"
    maxGasAmount: Int
    maximum(get: LibraTransfersMeasureable, of: LibraTransfersMeasureable!): String
    minimum(get: LibraTransfersMeasureable, of: LibraTransfersMeasureable!): String
    "Public key"
    publicKey: String
    "Transfer receiver"
    receiver(receiver: AddressSelector): Address
    "Script Hash"
    scriptHash(scriptHash: StringSelector): String
    "Script Type"
    scriptType: ScriptTypeSelectorSelector
    "Transfer sender"
    sender(sender: AddressSelector): Address
    "Sequence number"
    sequenceNumber: Int
    "Signature"
    signature: String
    "Signature scheme"
    signatureScheme: String
    "Status Name"
    statusName: String
    "Success"
    success(success: Boolean): Boolean
    "Transfer timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "Transaction sender"
    txSender(txSender: AddressSelector): Address
    "Version of blockchain for this transaction"
    version(version: IntegerSelector): Int!
    "Version hash of blockchain for this transaction"
    versionHash: String!
    "VM Status"
    vmStatus: Int
}

"Solana Log"
type Log {
    consumed: BigInt!
    instruction: String!
    logs: String!
    result: String!
    totalGas: BigInt!
}

"Smart contract method"
type Method {
    "Name"
    name: String
    "Signature"
    signature: String
    "Signature Hash"
    signatureHash: String!
}

"Information about miniblock"
type MiniblockElrond {
    "Miniblock hash"
    hash(miniblockHash: HashSelector): String
    "Hash of the receiver block"
    receiverBlockHash(miniblockReceiverBlockHash: HashSelector): String
    "Number of the receiver shard"
    receiverShard(miniblockReceiverShard: IntIdSelector): String
    "Miniblock type"
    type(type: StringSelector): String
}

"Name with an identifier"
type NameWithId {
    "ID"
    id: Int
    "Name"
    name: String
}

"Offchain Data"
type Offchain {
    "Historical COVID data"
    covid: CovidHistory
}

"Output Script Type of UTXO transaction output"
type OutputScript {
    "Script annotation"
    annotation: String
    "Long script pattern"
    pattern: String!
    "Short script pattern"
    short: String!
    "Simple script pattern"
    simplePattern: String!
    "Script type"
    type: BitcoinOutputScriptType
}

"Solana Program"
type Program {
    id: String!
    name: String!
    parsedName: String!
}

"Blockchain Unified GraphQL API"
type Query {
    "Algorand Chains Dataset"
    algorand(network: AlgorandNetwork): Algorand
    "Binance DEX Chain Dataset"
    binance: Binance
    "Bitcoin and other UTXO Chains Dataset"
    bitcoin(network: BitcoinNetwork): Bitcoin
    "Cardano Chain Dataset"
    cardano(network: CardanoNetwork): Cardano
    "Conflux Chains Dataset"
    conflux(network: ConfluxNetwork): Conflux
    "Diem ( former Libra ) Testnet Dataset"
    diem(network: DiemNetwork): Libra
    "Elrond Dataset"
    elrond(network: ElrondNetwork): Elrond
    "EOS Mainnet Dataset"
    eos(network: EosNetwork): Eos
    "Ethereum Mainnet / Classic Chain Datasets"
    ethereum(network: EthereumNetwork): Ethereum
    "Ethereum v2.0 Beacon Chain Datasets"
    ethereum2(network: Ethereum2Network): Ethereum2
    "Filecoin Dataset"
    filecoin(network: FilecoinNetwork): Filecoin
    "Hedera Dataset"
    hedera(network: HederaNetwork): Hedera
    "Offchain data"
    offchain: Offchain
    "Search by query string"
    search(limit: Int, network: Network, offset: Int, string: String!): [Result!]
    "Solana Dataset"
    solana(network: SolanaNetwork): Solana
    "Tron Mainnet Dataset"
    tron(network: TronNetwork): Tron
}

"Solana Receiver"
type Receiver {
    address: String!
    mintAccount: String!
    type: String!
}

"Search result item"
type Result {
    "Blockchain where result is found"
    network: BlockchainNetwork!
    "Subject in blockchain"
    subject: Subject!
}

"Solana Sender"
type Sender {
    address: String!
    mintAccount: String!
    type: String!
}

"Blockchain smart contract"
type SmartContract {
    "String address representation"
    address: String
    "Annotations ( tags ), if exists"
    annotation: String
    "Smart Contract Type"
    contractType: SmartContractType!
    "Smart Contract Protocol Type"
    protocol: String
}

type SmartContractReadonlyAttribute {
    "Value as address if applicable"
    address: EthereumAddressInfo
    "Method name"
    name: String!
    "Method return type"
    type: String!
    "Method return value"
    value: String!
}

"Solana Chain"
type Solana {
    "BlockRewards of Smart Contract Calls and Events"
    blockRewards(any: [SolanaBlockRewardsFilter!], blockHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, parentSlot: IntegerSelector, previousBlockHash: HashSelector, reward: AmountSelector): [SolanaBlockRewards!]
    "Solana Blocks"
    blocks(any: [SolanaBlocksFilter!], blockHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, parentSlot: IntegerSelector, previousBlockHash: HashSelector, rewards: AmountSelector, transactionCount: IntegerSelector): [SolanaBlocks!]
    """

    Each instruction specifies a single program, a subset of the transaction`s accounts
    that should be passed to the program.
    """
    instructions(any: [SolanaInstructionsFilter!], blockHash: HashSelector, callPath: StringSelector, date: DateSelector, external: IntegerSelector, externalParsedActionName: StringSelector, externalParsedProgramName: StringSelector, externalProgramId: StringSelector, fee: IntegerSelector, feePayer: HashSelector, height: BlockSelector, options: QueryOptions, parsedActionName: StringSelector, parsedProgramName: StringSelector, parsedType: StringSelector, previousBlockHash: HashSelector, programId: StringSelector, signature: StringSelector, success: BooleanSelector, time: DateTimeSelector, transactionIndex: IntegerSelector): [SolanaInstructions!]
    "Solana Transactions"
    transactions(any: [SolanaTransactionsFilter!], blockHash: HashSelector, date: DateSelector, fee: IntegerSelector, feePayer: HashSelector, height: BlockSelector, options: QueryOptions, parentSlot: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, signature: HashSelector, signer: HashSelector, success: BooleanSelector, transactionFee: AmountSelector, transactionIndex: IntegerSelector): [SolanaTransactions!]
    "Currency transfers from/to addresses in crypto currencies"
    transfers(any: [SolanaTransfersFilter!], blockHash: HashSelector, callPath: StringSelector, currency: [SolanaCurrencySelector!], date: DateSelector, external: StringSelector, externalParsedActionName: StringSelector, externalParsedProgramName: StringSelector, externalProgramId: StringSelector, feePayer: HashSelector, height: BlockSelector, options: QueryOptions, parsedActionName: StringSelector, parsedProgramName: StringSelector, parsedType: StringSelector, previousBlockHash: HashSelector, programId: StringSelector, receiverAddress: StringSelector, receiverType: StringSelector, recentBlockHash: HashSelector, senderAddress: StringSelector, senderType: StringSelector, signature: HashSelector, success: BooleanSelector, time: DateTimeSelector, transactionIndex: IntegerSelector, transferType: SolanaTransferTypeSelector): [SolanaTransfers!]
}

"BlockRewards in Solana  blockchain"
type SolanaBlockRewards {
    "Account"
    account(account: BlockSelector): String
    amount(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, parentSlot: IntegerSelector, previousBlockHash: HashSelector, reward: AmountSelector): Float
    any(of: SolanaBlockRewardsMeasureable!): String
    "Hash of the the block"
    blockHash(blockHash: HashSelector): String
    count(uniq: SolanaBlockRewardsUniq): Int
    countBigInt(uniq: SolanaBlockRewardsUniq): BigInt
    "Currency of transfer"
    currency: Currency
    "The date this transaction was created"
    date: Date
    "Number of block in the blockchains"
    height(height: BlockSelector): BigInt
    maximum(get: SolanaBlockRewardsMeasureable, of: SolanaBlockRewardsMeasureable!): String
    minimum(get: SolanaBlockRewardsMeasureable, of: SolanaBlockRewardsMeasureable!): String
    "The slot index of this block`s parent"
    parentSlot(parentSlot: IntegerSelector): BigInt
    "Account balances after the transaction was processed"
    postBalance(postBalance: IntegerSelector): BigInt
    "The block hash of this block`s parent"
    previousBlockHash(previousBlockHash: HashSelector): String
    "Type of reward"
    rewardType(rewardType: RewardTypeSelector): String
    "The time this transaction was created"
    time: DateTime
}

"Blocks in Solana  blockchain"
type SolanaBlocks {
    any(of: SolanaBlocksMeasureable!): String
    "Hash of the the block"
    blockHash(blockHash: HashSelector): String
    count(uniq: SolanaBlocksUniq): Int
    countBigInt(uniq: SolanaBlocksUniq): BigInt
    "The date this transaction was created"
    date: Date
    "Number of block in the blockchains"
    height(height: BlockSelector): BigInt
    maximum(get: SolanaBlocksMeasureable, of: SolanaBlocksMeasureable!): String
    minimum(get: SolanaBlocksMeasureable, of: SolanaBlocksMeasureable!): String
    "The slot index of this block`s parent"
    parentSlot(parentSlot: IntegerSelector): BigInt
    "The block hash of this block`s parent"
    previousBlockHash(previousBlockHash: HashSelector): String
    rewards(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, parentSlot: IntegerSelector, previousBlockHash: HashSelector, rewards: AmountSelector, transactionCount: IntegerSelector): Float
    "The time this transaction was created"
    time: DateTime
    "Count of transactions in this block"
    transactionCount(transactionCount: IntegerSelector): Int
}

"Instructions in Solana  blockchain"
type SolanaInstructions {
    "Accounts count"
    accountsCount: Int
    "Action"
    action(parsedActionName: StringSelector, parsedType: StringSelector): Action
    any(of: SolanaInstructionsMeasureable!): String
    "Block where transfer transaction is included"
    block(hash: HashSelector, height: BlockSelector, time: DateTimeSelector): BlockExtended
    "Call Path"
    callPath(callPath: StringSelector): String
    count(uniq: SolanaInstructionsUniq): Int
    countBigInt(uniq: SolanaInstructionsUniq): BigInt
    "The date this transaction was created"
    date: Date
    "External"
    external(external: IntegerSelector): BigInt
    "External Action"
    externalAction(externalParsedActionName: StringSelector): ExternalAction
    "External Program"
    externalProgram(externalParsedProgramName: StringSelector, externalProgramId: StringSelector, externalProgramName: StringSelector): Program
    "Fee Payer"
    feePayer(feePayer: HashSelector): String
    "Parsed Action Name"
    log: Log
    maximum(get: SolanaInstructionsMeasureable, of: SolanaInstructionsMeasureable!): String
    minimum(get: SolanaInstructionsMeasureable, of: SolanaInstructionsMeasureable!): String
    "The block hash of this block`s parent"
    previousBlockHash(previousBlockHash: HashSelector): String
    "Program"
    program(parsedProgramName: StringSelector, programId: StringSelector, programName: StringSelector): Program
    "Transaction Hash"
    signature(signature: HashSelector): String
    "Successed or failed"
    success(success: BooleanSelector): Boolean
    "Transaction Index"
    transactionIndex(transactionIndex: IntegerSelector): BigInt
}

"Transactions in Solana  blockchain"
type SolanaTransactions {
    any(of: SolanaTransactionsMeasureable!): String
    "Block where transfer transaction is included"
    block(hash: HashSelector, height: BlockSelector, time: DateTimeSelector): BlockExtended
    count(uniq: SolanaTransactionsUniq): Int
    countBigInt(uniq: SolanaTransactionsUniq): BigInt
    "The date this transaction was created"
    date: Date
    "Error"
    error(error: StringSelector): String
    "Fee Payer"
    feePayer(feePayer: HashSelector): String
    maximum(get: SolanaTransactionsMeasureable, of: SolanaTransactionsMeasureable!): String
    minimum(get: SolanaTransactionsMeasureable, of: SolanaTransactionsMeasureable!): String
    "The slot index of this block`s parent"
    parentSlot(parentSlot: BlockSelector): BigInt
    "The block hash of this block`s parent"
    previousBlockHash(previousBlockHash: HashSelector): String
    "Recent blockhash prevents duplication and to give transactions lifetimes"
    recentBlockHash(recentBlockHash: HashSelector): String
    "Transaction Hash"
    signature(signature: StringSelector): String
    "Accounts` public keys"
    signer(signer: HashSelector): String
    "Successed or failed"
    success(success: BooleanSelector): Boolean
    transactionFee(blockHash: HashSelector, calculate: AmountAggregateFunction, date: DateSelector, fee: IntegerSelector, feePayer: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, parentSlot: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, signature: HashSelector, signer: HashSelector, success: BooleanSelector, transactionFee: AmountSelector, transactionIndex: IntegerSelector): Float
    "Transaction Index"
    transactionIndex(transactionIndex: IntegerSelector): BigInt
}

"Currency transfers from/to addresses in crypto currencies"
type SolanaTransfers {
    "Action"
    action(parsedActionName: StringSelector, parsedType: StringSelector): Action
    amount(blockHash: HashSelector, calculate: AmountAggregateFunction, callPath: StringSelector, currency: [SolanaCurrencySelector!], date: DateSelector, external: StringSelector, externalParsedActionName: StringSelector, externalParsedProgramName: StringSelector, externalProgramId: StringSelector, feePayer: HashSelector, height: BlockSelector, in: BaseCurrencyEnum, parsedActionName: StringSelector, parsedProgramName: StringSelector, parsedType: StringSelector, previousBlockHash: HashSelector, programId: StringSelector, receiverAddress: StringSelector, receiverType: StringSelector, recentBlockHash: HashSelector, senderAddress: StringSelector, senderType: StringSelector, signature: HashSelector, success: BooleanSelector, time: DateTimeSelector, transactionIndex: IntegerSelector, transferType: SolanaTransferTypeSelector): Float
    any(of: SolanaTransfersMeasureable!): String
    "Block where transfer transaction is included"
    block(hash: HashSelector, height: BlockSelector, time: DateTimeSelector): BlockExtended
    "Call Path"
    callPath(callPath: StringSelector): String
    count(uniq: SolanaTransfersUniq): Int
    countBigInt(uniq: SolanaTransfersUniq): BigInt
    "Currency of transfer"
    currency: Currency
    "The date this transaction was created"
    date: Date
    "Action"
    externalAction(externalParsedActionName: StringSelector): ExternalAction
    "External Parsed"
    externalParsed(externalParsed: IntegerSelector): Int
    "Parsed Type"
    externalParsedType(externalParsedType: StringSelector): String
    "External Program"
    externalProgram(externalParsedProgramName: StringSelector, externalProgramId: StringSelector, externalProgramName: StringSelector): Program
    "Fee Payer"
    feePayer(feePayer: HashSelector): String
    maximum(get: SolanaTransfersMeasureable, of: SolanaTransfersMeasureable!): String
    minimum(get: SolanaTransfersMeasureable, of: SolanaTransfersMeasureable!): String
    "Parsed Action Name"
    parsedActionName(parsedActionName: StringSelector): String
    "The block hash of this block`s parent"
    previousBlockHash(previousBlockHash: HashSelector): String
    "Program"
    program(parsedProgramName: StringSelector, programId: StringSelector, programName: StringSelector): Program
    "Receiver"
    receiver: Receiver
    "Sender"
    sender: Sender
    "Transaction Hash"
    signature(signature: HashSelector): String
    "Successed or failed"
    success(success: BooleanSelector): Boolean
    "Transaction Index"
    transactionIndex(transactionIndex: IntegerSelector): BigInt
    "Transfer Type"
    transferType(transferType: SolanaTransferTypeSelector): String
}

"Time Interval"
type TimeInterval {
    day(count: Int, format: String): String!
    hour(count: Int, format: String): String!
    minute(count: Int, format: String): String!
    month(count: Int, format: String): String!
    second(count: Int, format: String): String!
    year(count: Int, format: String): String!
}

"Timestamp"
type Timestamp {
    "Nanoseconds"
    nanoseconds: BigInt!
    time: ISO8601Date!
}

"Information about transaction"
type TransactionElrond {
    "Shard number of sender"
    data(data: StringSelector): String
    "Shard number of sender"
    dataOperation(dataOperation: StringSelector): String
    fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Transaction hash"
    hash(txHash: HashSelector): String
    "Transaction index"
    index(index: IntegerSelector): Int
    "Transaction nonce"
    nonce(nonce: IntegerSelector): Int
    "Hash of the receiver"
    receiver(txReceiver: HashSelector): Address
    "Shard number of receiver"
    receiverShard(txReceiverShard: IntIdSelector): BigInt
    "Hash of the sender"
    sender(txSender: HashSelector): Address
    "Shard number of sender"
    senderShard(txSenderShard: IntIdSelector): BigInt
    "Shard number of sender"
    signature(signature: HashSelector): String
    "Shard number of sender"
    status(status: StringSelector): String
}

"Blockchain transaction"
type TransactionHash {
    "Hash hex representation"
    hash: String!
}

"Blockchain transaction"
type TransactionHashIndex {
    "Block of the Output Transaction for this input"
    block: Int
    "Hash hex representation"
    hash: String!
    "Transaction index in block, 0-based"
    index: String!
}

"Blockchain transaction with value"
type TransactionHashValue {
    "Hash hex representation"
    hash: String!
    "Transaction value"
    value: Float!
}

"Transaction result"
type TransactionResult {
    "Result ID"
    id: Int!
    "Result name"
    name: String!
}

"Identification of transaction source as client application"
type TransactionSource {
    "ID numeric"
    code: Int!
    "Name"
    name: String!
}

"Tron Chain"
type Tron {
    "Basic information about address ( or smart contract )"
    address(address: [AddressSelectorIn!]!): [TronAddressInfo!]!
    "Blockchain Blocks"
    blocks(any: [TronBlockFilter!], blockHash: HashSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, parentBlockHash: [HashSelector!], time: DateTimeSelector, version: IntegerSelector, witness: AddressSelector): [TronBlocks!]
    "Money flow using Coinpath technology"
    coinpath(currency: TronCurrencySelector, date: DateSelector, depth: IntegerLimitedSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, options: CoinpathOptions, receiver: AddressSelector, sender: AddressSelector, time: DateTimeSelector): [TronCoinpath!]
    "Blockchain Embedded Contracts"
    contracts(any: [TronContractFilter!], contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, height: BlockSelector, options: QueryOptions, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txOwner: AddressSelector): [TronSmartContracts!]
    "Trades on Ethereum DEX Smart Contracts"
    dexTrades(any: [TronDexTradeFilter!], baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], options: QueryOptions, price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): [TronDexTrades!]
    "Smart Contract Calls"
    smartContractCalls(any: [TronSmartContractCallFilter!], date: DateSelector, external: Boolean, height: BlockSelector, options: QueryOptions, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): [TronSmartContractCalls!]
    "Smart Contract Events"
    smartContractEvents(any: [TronSmartContractEventFilter!], date: DateSelector, height: BlockSelector, options: QueryOptions, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): [TronSmartContractEvents!]
    "Blockchain Embedded Contracts"
    trades(amountBuy: [AmountSelector!], amountSell: [AmountSelector!], any: [TronTradeFilter!], buyCurrency: TronCurrencySelector, buyer: AddressSelector, contractType: TronContractTypeSelector, date: DateSelector, exchangeId: IntIdSelector, height: BlockSelector, options: QueryOptions, sellCurrency: TronCurrencySelector, seller: AddressSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector): [TronTrades!]
    "Blockchain Transactions"
    transactions(any: [TronTransactionFilter!], contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, options: QueryOptions, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): [TronTransactions!]
    "Currency Transfers"
    transfers(amount: [AmountSelector!], any: [TronTransferFilter!], contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, options: QueryOptions, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): [TronTransfers!]
}

"Address detailed information for Tron network"
type TronAddressInfo {
    "Address"
    address: String
    "Annotations ( tags ), if exists"
    annotation: String
    "Smart Contract if exists on the address"
    smartContract: TronSmartContractInfo
}

"Blocks in Tron blockchain"
type TronBlocks {
    any(of: TronBlocksMeasureable!): String
    count(blockHash: HashSelector, date: DateSelector, height: BlockSelector, parentBlockHash: [HashSelector!], time: DateTimeSelector, uniq: TronBlocksUniq, version: IntegerSelector, witness: AddressSelector): Int
    countBigInt(blockHash: HashSelector, date: DateSelector, height: BlockSelector, parentBlockHash: [HashSelector!], time: DateTimeSelector, uniq: TronBlocksUniq, version: IntegerSelector, witness: AddressSelector): BigInt
    "Calendar date"
    date: Date
    "Block hash"
    hash(blockHash: [HashSelector!]): String!
    "Block number (height) in blockchain"
    height(height: BlockSelector): Int!
    maximum(get: TronBlocksMeasureable, of: TronBlocksMeasureable!): String
    minimum(get: TronBlocksMeasureable, of: TronBlocksMeasureable!): String
    "Parent block hash"
    parentBlockHash(parentBlockHash: [HashSelector!]): String!
    "Block timestamp"
    timestamp(time: DateTimeSelector): DateTime
    "TX Trie Root Hash"
    txTrieRoot: String!
    "Block version"
    version(version: IntegerSelector): Int
    "Block witness"
    witness(witness: AddressSelector): Address
    "Witness signature"
    witnessSignature: String!
}

"Coinpath"
type TronCoinpath {
    "Summary of transfered value"
    amount(in: BaseCurrencyEnum): Float
    any(of: CoinpathMeasureable!): String
    "Block where transaction is included"
    block: Block
    "Count of transfers"
    count: Int
    "Count of transfers"
    countBigInt: BigInt
    "Currency of transfer"
    currency: Currency
    "1-based hop depth of the graph"
    depth: Int
    maximum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    minimum(get: CoinpathMeasureable, of: CoinpathMeasureable!): String
    "Receiver address"
    receiver: TronAddressInfo
    "Sender address"
    sender: TronAddressInfo
    "Transaction of transfer happened"
    transaction: TransactionHashValue
}

"Tron DEX attributes"
type TronDex {
    "Address for DEX exchange identification"
    address: Address!
    "Full name ( name for known, Protocol for unknown )"
    fullName: String!
    "Full name ( name for known, Protocol / address for unknown )"
    fullNameWithId: String!
    "Name for known exchanges"
    name: String
}

"Trades on DEX smart contracts"
type TronDexTrades {
    "Trader (maker or taker)"
    address(makerOrTaker: [AddressSelector!]): TronAddressInfo
    any(of: TronDexTradesMeasureable!): String
    baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Base currency"
    baseCurrency(baseCurrency: [TronCurrencySelector!]): Currency
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): BlockExtended
    buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Maker buys this currency"
    buyCurrency(buyCurrency: [TronCurrencySelector!]): Currency
    count(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, uniq: TronDexTradesUniq): Int
    countBigInt(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector, uniq: TronDexTradesUniq): BigInt
    "Calendar date"
    date: Date
    energyFee(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, in: BaseCurrencyEnum, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Float
    energyUsageTotal(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Float
    "Identification of admin / manager / factory of smart contract, executing trades"
    exchange(exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!]): TronDex
    fee(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, in: BaseCurrencyEnum, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Float
    internalTransactionsCount(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Int
    internalTransactionsCountbigint(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): BigInt
    logsCount(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Int
    logsCountbigint(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): BigInt
    "Trade 'maker' side"
    maker(maker: [AddressSelector!]): TronAddressInfo
    maximum(get: TronDexTradesMeasureable, of: TronDexTradesMeasureable!): String
    minimum(get: TronDexTradesMeasureable, of: TronDexTradesMeasureable!): String
    netFee(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, in: BaseCurrencyEnum, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Float
    netUsage(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], calculate: AmountAggregateFunction, date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Float
    price(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], calculate: PriceAggregateFunction, date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Float
    "Protocol name of the smart contract"
    protocol(protocol: [StringSelector!]): String
    quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Quote currency"
    quoteCurrency(quoteCurrency: [TronCurrencySelector!]): Currency
    quotePrice(baseCurrency: [TronCurrencySelector!], buyAmount: [AmountSelector!], buyCurrency: [TronCurrencySelector!], calculate: PriceAggregateFunction, date: DateSelector, exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], height: BlockSelector, maker: [AddressSelector!], makerOrTaker: [AddressSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], protocol: [StringSelector!], quoteCurrency: [TronCurrencySelector!], sellAmount: [AmountSelector!], sellCurrency: [TronCurrencySelector!], smartContractAddress: [AddressSelector!], taker: [AddressSelector!], time: DateTimeSelector, tradeAmountUsd: [FloatSelector!], tradeIndex: [StringSelector!], txHash: HashSelector): Float
    sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
    "Maker sells this currency"
    sellCurrency(sellCurrency: [TronCurrencySelector!]): Currency
    "Side of trade ( SELL / BUY )"
    side: TradeSide
    "Smart contract being called"
    smartContract(smartContractAddress: [AddressSelector!]): TronSmartContract
    "Trade 'taker' side"
    taker(taker: [AddressSelector!]): TronAddressInfo
    "Time interval"
    timeInterval: TimeInterval
    tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float
    "Index of trade in transaction, used to separate trades in transaction"
    tradeIndex(tradeIndex: [StringSelector!]): String
    "Transaction of DexTrade"
    transaction(txHash: [HashSelector!]): TronTransactionInfoExtended
}

"Tron smart contract"
type TronSmartContract {
    "Smart Contract Address"
    address: Address!
    "Smart Contract Type"
    contractType: SmartContractType
    "Token implemented in this smart contract"
    currency: Currency
    "Smart Contract Protocol Type"
    protocolType: String
}

"Smart Contract Calls"
type TronSmartContractCalls {
    amount(calculate: AmountAggregateFunction, date: DateSelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    any(of: TronCallsMeasureable!): String
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."
    callDepth: String
    "Counts and other metrics"
    count(date: DateSelector, external: Boolean, height: BlockSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: SmartContractCallsUniq): Int
    "Counts and other metrics"
    countBigInt(date: DateSelector, external: Boolean, height: BlockSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: SmartContractCallsUniq): BigInt
    "Calendar date"
    date: Date
    energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, external: Boolean, height: BlockSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    "External call executed explicitly by caller. Internal calls executed by smart contracts."
    external(external: Boolean): Boolean
    fee(calculate: AmountAggregateFunction, date: DateSelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    maximum(get: TronCallsMeasureable, of: TronCallsMeasureable!): String
    minimum(get: TronCallsMeasureable, of: TronCallsMeasureable!): String
    netUsage(calculate: AmountAggregateFunction, date: DateSelector, external: Boolean, height: BlockSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    "Smart contract being called"
    smartContract(smartContractAddress: AddressSelector): TronSmartContract
    "Contract method invoked"
    smartContractMethod(smartContractMethod: MethodSelector): Method
    "True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."
    success(success: [Boolean!]): Boolean
    "Action from address"
    txFrom(txFrom: AddressSelector): Address
    "Transaction hash where transfer happened"
    txHash(txHash: HashSelector): String
    "Action to address"
    txTo(txTo: AddressSelector): Address
}

"Smart Contract Events"
type TronSmartContractEvents {
    any(of: TronEventsMeasureable!): String
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Counts and other metrics"
    count(date: DateSelector, height: BlockSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: SmartContractCallsUniq): Int
    "Counts and other metrics"
    countBigInt(date: DateSelector, height: BlockSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: SmartContractCallsUniq): BigInt
    "Calendar date"
    date: Date
    maximum(get: TronEventsMeasureable, of: TronEventsMeasureable!): String
    minimum(get: TronEventsMeasureable, of: TronEventsMeasureable!): String
    "Smart contract being Evented"
    smartContract(smartContractAddress: AddressSelector): TronSmartContract
    "Contract method invoked"
    smartContractEvent(smartContractEvent: EventSelector): Event
    "Action from address"
    txFrom(txFrom: AddressSelector): Address
    "Transaction hash where transfer happened"
    txHash(txHash: HashSelector): String
    "Action to address"
    txTo(txTo: AddressSelector): Address
}

"Blockchain smart contract"
type TronSmartContractInfo {
    "Smart Contract Type"
    contractType: SmartContractType
    "Token implemented in this smart contract"
    currency: Currency
    "Smart Contract Protocol Type"
    protocolType: String
}

"Contracts"
type TronSmartContracts {
    amount(calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txOwner: AddressSelector): Float
    any(of: TronContractsMeasureable!): String
    "Block in the blockchain"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Contract type"
    contractType(contractType: TronContractTypeSelector): TronContractType
    "Counts and other metrics"
    count(contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, height: BlockSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txOwner: AddressSelector, uniq: SmartContractCallsUniq): Int
    "Counts and other metrics"
    countBigInt(contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, height: BlockSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txOwner: AddressSelector, uniq: SmartContractCallsUniq): BigInt
    "Currency of transfer"
    currency(currency: TronCurrencySelector): Currency
    "Calendar date"
    date: Date
    energyUsageTotal(calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, height: BlockSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txOwner: AddressSelector): Float
    fee(calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txOwner: AddressSelector): Float
    maximum(get: TronContractsMeasureable, of: TronContractsMeasureable!): String
    minimum(get: TronContractsMeasureable, of: TronContractsMeasureable!): String
    netUsage(calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, height: BlockSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector, txOwner: AddressSelector): Float
    "True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."
    success(success: [Boolean!]): Boolean
    "Transaction hash where transfer happened"
    txHash(txHash: HashSelector): String
    "Transactio owner from address"
    txOwner(txOwner: AddressSelector): Address
}

"Currency Trades from/to addresses in crypto currencies"
type TronTrades {
    amountBuy(amountBuy: [AmountSelector!], amountSell: [AmountSelector!], buyCurrency: TronCurrencySelector, buyer: AddressSelector, calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, date: DateSelector, exchangeId: IntIdSelector, height: BlockSelector, in: BaseCurrencyEnum, sellCurrency: TronCurrencySelector, seller: AddressSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector): Float
    amountSell(amountBuy: [AmountSelector!], amountSell: [AmountSelector!], buyCurrency: TronCurrencySelector, buyer: AddressSelector, calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, date: DateSelector, exchangeId: IntIdSelector, height: BlockSelector, in: BaseCurrencyEnum, sellCurrency: TronCurrencySelector, seller: AddressSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector): Float
    any(of: TronTradesMeasureable!): String
    "Block where Trade transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Buy Currency of Trade"
    buyCurrency(buyCurrency: TronCurrencySelector): Currency
    "Trade buyer"
    buyer(buyer: AddressSelector): Address
    "Contract type"
    contractType(contractType: TronContractTypeSelector): TronContractType
    count(amountBuy: [AmountSelector!], amountSell: [AmountSelector!], buyCurrency: TronCurrencySelector, buyer: AddressSelector, contractType: TronContractTypeSelector, date: DateSelector, exchangeId: IntIdSelector, height: BlockSelector, sellCurrency: TronCurrencySelector, seller: AddressSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector, uniq: TronTradesUniq): Int
    countBigInt(amountBuy: [AmountSelector!], amountSell: [AmountSelector!], buyCurrency: TronCurrencySelector, buyer: AddressSelector, contractType: TronContractTypeSelector, date: DateSelector, exchangeId: IntIdSelector, height: BlockSelector, sellCurrency: TronCurrencySelector, seller: AddressSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector, uniq: TronTradesUniq): BigInt
    "Calendar date"
    date: Date
    energyUsageTotal(amountBuy: [AmountSelector!], amountSell: [AmountSelector!], buyCurrency: TronCurrencySelector, buyer: AddressSelector, calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, date: DateSelector, exchangeId: IntIdSelector, height: BlockSelector, sellCurrency: TronCurrencySelector, seller: AddressSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector): Float
    "exchange_id"
    exchangeId(exchangeId: IntIdSelector): Int
    fee(amountBuy: [AmountSelector!], amountSell: [AmountSelector!], buyCurrency: TronCurrencySelector, buyer: AddressSelector, calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, date: DateSelector, exchangeId: IntIdSelector, height: BlockSelector, in: BaseCurrencyEnum, sellCurrency: TronCurrencySelector, seller: AddressSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector): Float
    maximum(get: TronTradesMeasureable, of: TronTradesMeasureable!): String
    minimum(get: TronTradesMeasureable, of: TronTradesMeasureable!): String
    netUsage(amountBuy: [AmountSelector!], amountSell: [AmountSelector!], buyCurrency: TronCurrencySelector, buyer: AddressSelector, calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, date: DateSelector, exchangeId: IntIdSelector, height: BlockSelector, sellCurrency: TronCurrencySelector, seller: AddressSelector, success: Boolean, time: DateTimeSelector, txHash: HashSelector): Float
    "Sell Currency of Trade"
    sellCurrency(sellCurrency: TronCurrencySelector): Currency
    "Trade seller"
    seller(seller: AddressSelector): Address
    "Transfer succeeded"
    success(success: Boolean): Boolean
    "Transaction hash where Trade happened"
    txHash(txHash: HashSelector): String
}

"Blockchain Transaction Extended info"
type TronTransactionInfoExtended {
    "Contract Address"
    contractAddress: Address
    "Expiration"
    expiration: Int!
    "Fee Limit"
    feeLimit: Int!
    "Hash hex representation"
    hash: String!
    "Transaction index in block, 0 based"
    index: Int
    "Ref block Hash hex representation"
    refBlockHash: String!
    "Result message"
    result: String
    "Signatures"
    signatures: String!
    "Success"
    success: Boolean
}

"Transactions in Tron blockchain"
type TronTransactions {
    any(of: TronTransactionsMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Contract Address"
    contractAddress(contractAddress: AddressSelector): Address
    count(contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector, uniq: TronTransactionsUniq): Int
    countBigInt(contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector, uniq: TronTransactionsUniq): BigInt
    "Calendar date"
    date: Date
    energyFee(calculate: AmountAggregateFunction, contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Float
    energyUsageTotal(calculate: AmountAggregateFunction, contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Float
    "Expiration"
    expiration: Int!
    fee(calculate: AmountAggregateFunction, contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Float
    "Fee Limit"
    feeLimit: Int!
    "Hash hex representation"
    hash(txHash: [HashSelector!]): String!
    "Transaction index in block, 0 based"
    index(txIndex: [TxIndexSelector!]): Int
    internalTransactionsCount(contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Int
    internalTransactionsCountbigint(contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): BigInt
    logsCount(contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Int
    logsCountbigint(contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): BigInt
    maximum(get: TronTransactionsMeasureable, of: TronTransactionsMeasureable!): String
    minimum(get: TronTransactionsMeasureable, of: TronTransactionsMeasureable!): String
    netFee(calculate: AmountAggregateFunction, contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, in: BaseCurrencyEnum, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Float
    netUsage(calculate: AmountAggregateFunction, contractAddress: AddressSelector, date: DateSelector, height: BlockSelector, refBlockHash: [HashSelector!], success: Boolean, time: DateTimeSelector, txHash: HashSelector, txIndex: TxIndexSelector): Float
    "Ref block Hash hex representation"
    refBlockHash(refBlockHash: [HashSelector!]): String!
    "Result message"
    result: String
    "Signatures"
    signatures: String!
    "Success"
    success(success: Boolean): Boolean
}

"Currency transfers from/to addresses in crypto currencies"
type TronTransfers {
    amount(amount: [AmountSelector!], calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    any(of: TronTransfersMeasureable!): String
    "Block where transfer transaction is included"
    block(height: BlockSelector, time: DateTimeSelector): Block
    "Contract type"
    contractType(contractType: TronContractTypeSelector): TronContractType
    count(amount: [AmountSelector!], contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: TransfersUniq): Int
    countBigInt(amount: [AmountSelector!], contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector, uniq: TransfersUniq): BigInt
    "Currency of transfer"
    currency(currency: TronCurrencySelector): Currency
    "Calendar date"
    date: Date
    energyUsageTotal(amount: [AmountSelector!], calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    "Entity identifier ( for ERC-721 NFT tokens )"
    entityId(entityId: EntitySelector): String
    "External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts."
    external(external: Boolean): Boolean
    fee(amount: [AmountSelector!], calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, in: BaseCurrencyEnum, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    maximum(get: TronTransfersMeasureable, of: TronTransfersMeasureable!): String
    minimum(get: TronTransfersMeasureable, of: TronTransfersMeasureable!): String
    netUsage(amount: [AmountSelector!], calculate: AmountAggregateFunction, contractType: TronContractTypeSelector, currency: TronCurrencySelector, date: DateSelector, entityId: EntitySelector, external: Boolean, height: BlockSelector, receiver: AddressSelector, sender: AddressSelector, success: Boolean, time: DateTimeSelector, txFrom: AddressSelector, txHash: HashSelector, txTo: AddressSelector): Float
    "Transfer receiver"
    receiver(receiver: AddressSelector): Address
    "Transfer sender"
    sender(sender: AddressSelector): Address
    "Transfer succeeded"
    success(success: Boolean): Boolean
    "Action from address"
    txFrom(txFrom: AddressSelector): Address
    "Transaction hash where transfer happened"
    txHash(txHash: HashSelector): String
    "Action to address"
    txTo(txTo: AddressSelector): Address
}

enum AlgorandArgumentsMeasureable {
    "Argument index"
    argument_index
    "Argument value"
    argument_value
    "Block"
    block
    "Date"
    date
    "Smart Contract"
    smart_contract
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction Sender"
    tx_sender
    "Transaction type"
    tx_type
}

enum AlgorandBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Block Reward"
    block_reward
    "Date"
    date
    "Next protocol approvals"
    next_protocol_approvals
    "Block Proposer"
    proposer
    "Time"
    time
}

enum AlgorandBlocksUniq {
    "Unique date count"
    dates
    "Unique proposer count"
    proposers
}

enum AlgorandCallsMeasureable {
    "Block"
    block
    "Date"
    date
    "Smart Contract"
    smart_contract
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction Sender"
    tx_sender
    "Transaction type"
    tx_type
}

enum AlgorandNetwork {
    "Algorand Mainnet (ALGO)"
    algorand
    "Algorand Betanet"
    algorand_betanet
    "Algorand Testnet"
    algorand_testnet
}

enum AlgorandTransactionsMeasureable {
    "Block"
    block
    "Date"
    date
    "Fee value"
    fee
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction Sender"
    tx_sender
}

enum AlgorandTransactionsUniq {
    "Unique blocks"
    blocks
    "Unique currencies"
    currencies
    "Unique date count"
    dates
    "Unique TX senders count"
    senders
}

enum AlgorandTransferType {
    "Close"
    close
    "Create Asset"
    create
    "Asset Freeze"
    freeze
    "Genesis Block"
    genesis
    "Reward"
    reward
    "Send"
    send
    "Asset Unfreeze"
    unfreeze
}

enum AlgorandTransfersMeasureable {
    "Amount"
    amount
    "Currency Asset ID"
    asset_id
    "Block"
    block
    "Currency symbol"
    currency_symbol
    "Date"
    date
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "Transfer type"
    transfer_type
    "Transaction hash"
    tx_hash
    "TX Sender"
    tx_sender
    "Transaction type"
    tx_type
}

enum AlgorandTxSubType {
    "Close"
    close
    "Asset Configuration"
    configure
    "Create"
    create
    "Asset Freeze"
    freeze
    "Key Reg"
    keyreg
    "None"
    none
    "Send"
    send
    "Asset Unfreeze"
    unfreeze
}

enum AlgorandTxType {
    "Asset Configuration"
    acfg
    "Asset Freeze or Unfreeze"
    afrz
    "Application Call"
    appl
    "Asset Transfer"
    axfer
    "Genesis Block"
    genesis
    "Key Reg"
    keyreg
    "Pay"
    pay
}

enum AmountAggregateFunction {
    "Any value"
    any
    "Last value"
    anyLast
    "Average"
    average
    "Maximum"
    maximum
    "Median"
    median
    "Minimum"
    minimum
    "Sum (total)"
    sum
    "Unique estimate fast"
    unique
    "Unique exact"
    uniqueExact
}

enum BaseCurrencyEnum {
    "Bitcoin"
    BTC
    "Ethereum"
    ETH
    "Dollar"
    USD
    "Tether USDT"
    USDT
}

enum BinanceBlockUniq {
    "Unique date count"
    dates
    "Validator fee addresses"
    validator_fee_addresses
    "Validator operators"
    validator_operator_addresses
}

enum BinanceBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Date"
    date
    "Time"
    time
    "Validator moniker"
    validator_moniker
}

enum BinanceOrderSide {
    "Buy Side"
    buy
    "Sell Side"
    sell
}

enum BinanceOrderStatus {
    "Ack"
    Ack
    "Canceled"
    Canceled
    "Expired"
    Expired
    "Failed Blocking"
    FailedBlocking
    "Fully Fill"
    FullyFill
    "Ioc Expire"
    IocExpire
    "Ioc No Fill"
    IocNoFill
    "Partial Fill"
    PartialFill
}

enum BinanceOrderTimeInForce {
    "Good Till Expiry"
    GTE
    "Immediate Or Cancel"
    IOC
}

enum BinanceOrderType {
    "Limit Order"
    LimitOrder
}

enum BinanceOrdersMeasureable {
    "Base Amount"
    base_amount
    "Base currency"
    base_currency
    "Block"
    block
    "Date"
    date
    "Order ID"
    order_id
    "Order owner"
    order_owner
    "Order side"
    order_side
    "Order status"
    order_status
    "Price"
    price
    "Quote Amount"
    quote_amount
    "Quote currency"
    quote_currency
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum BinanceOrdersUniq {
    "Unique base currencies"
    base_currencies
    "Unique blocks"
    blocks
    "Unique date count"
    dates
    "Unique order ID count"
    orders
    "Unique order owners"
    owners
    "Unique quote currencies"
    quote_currencies
    "Unique Transactions"
    txs
}

enum BinanceTradesMeasureable {
    "Base Amount"
    base_amount
    "Base currency"
    base_currency
    "Block"
    block
    "Buy Order ID"
    buy_order_id
    "Buyer"
    buyer
    "Date"
    date
    "Price"
    price
    "Quote Amount"
    quote_amount
    "Quote currency"
    quote_currency
    "Sell Order ID"
    sell_order_id
    "Seller"
    seller
    "Time"
    time
    "Trade ID"
    trade_id
    "Transaction hash"
    tx_hash
}

enum BinanceTradesUniq {
    "Unique base currencies"
    base_currencies
    "Unique blocks"
    blocks
    "Buy Orders"
    buy_orders
    "Unique buyers count"
    buyers
    "Unique date count"
    dates
    "Unique quote currencies"
    quote_currencies
    "Sell Orders"
    sell_orders
    "Unique sellers count"
    sellers
    "Trades"
    trades
    "Unique Transactions"
    txs
}

enum BinanceTransactionType {
    "Bind"
    BIND
    "Submit evidence"
    BSC_SUBMIT_EVIDENCE
    "Burn"
    BURN
    "Cancel Order"
    CANCEL_ORDER
    "Cross chain claim"
    CLAIM
    "Hash Timer Locked Claim"
    CLAIM_HTL
    "Create sidechain validator"
    CREATE_SIDECHAIN_VALIDATOR
    "Deposit"
    DEPOSIT
    "Hash Timer Locked Deposit"
    DEPOSIT_HTL
    "Edit sidechain validator"
    EDIT_SIDECHAIN_VALIDATOR
    "Freeze Token"
    FREEZE_TOKEN
    "Hash Timer Locked Transfer"
    HTL_TRANSFER
    "Issue"
    ISSUE
    "Listing"
    LISTING
    "Mini Token Issue"
    MINI_TOKEN_ISSUE
    "Mini Token Listing"
    MINI_TOKEN_LIST
    "Mini Token Set URI"
    MINI_TOKEN_SET_URI
    "Mint"
    MINT
    "New Order"
    NEW_ORDER
    "Hash Timer Locked  Refund"
    REFUND_HTL
    "Delegate for sidechain"
    SIDECHAIN_DELEGATE
    "ReDelegate for sidechain"
    SIDECHAIN_REDELEGATE
    "Unbond from sidechain"
    SIDECHAIN_UNBOND
    "Unjail from sidechain"
    SIDECHAIN_UNJAIL
    "Side chain deposit"
    SIDE_DEPOSIT
    "Side chain submit poroposal"
    SIDE_SUBMIT_PROPOSAL
    "Side chain vote"
    SIDE_VOTE
    "Submit Proposal"
    SUBMIT_PROPOSAL
    "Set Account Flag"
    SetAccountFlag
    "Tiny Token Issue"
    TINY_TOKEN_ISSUE
    "Tiny Token Listing"
    TINY_TOKEN_LIST
    "Tiny Token Set URI"
    TINY_TOKEN_SET_URI
    "Transfer"
    TRANSFER
    "Cross chain transfer"
    TRANSFER_OUT
    "Time Lock"
    TimeLock
    "Time Relock"
    TimeRelock
    "Time Unlock"
    TimeUnlock
    "UnBind"
    UNBIND
    "Unfreeze Token"
    UNFREEZE_TOKEN
    "Vote"
    VOTE
}

enum BinanceTransactionsMeasureable {
    "Block"
    block
    "Currency"
    currency_symbol
    "Date"
    date
    "Time"
    time
    "Transaction Code"
    transaction_code
    "Transaction Memo"
    transaction_memo
    "Transaction Source Code"
    transaction_source_code
    "Transaction Source Name"
    transaction_source_name
    "Transaction Type"
    transaction_type
    "Transaction hash"
    tx_hash
}

enum BinanceTransactionsUniq {
    "Unique blocks"
    blocks
    "Unique date count"
    dates
    "Unique transaction source count"
    transaction_sources
}

enum BinanceTransferType {
    "Bind"
    BIND
    "Reward for block"
    BLOCK_REWARD
    "Submit evidence"
    BSC_SUBMIT_EVIDENCE
    "Burning amount"
    BURN
    "Cross chain claim"
    CLAIM
    "Claiming Hash Timer Locked Transfer"
    CLAIM_HTL
    "Create sidechain validator"
    CREATE_SIDECHAIN_VALIDATOR
    "Deposit for Hash Timer Locked Transfer"
    DEPOSIT_HTL
    "Fee for DEX orders"
    DEX_FEE
    "Edit sidechain validator"
    EDIT_SIDECHAIN_VALIDATOR
    "Genesis declaration"
    GENESIS_DELEGATION
    "Genesis supply declaration"
    GENESIS_SUPPLY
    "Hash Timer Locked Transfer"
    HTL_TRANSFER
    "Issue token"
    ISSUE
    "Mini Token Issue"
    MINI_TOKEN_ISSUE
    "Mint token"
    MINT
    "Delegate for sidechain"
    SIDECHAIN_DELEGATE
    "ReDelegate for sidechain"
    SIDECHAIN_REDELEGATE
    "Unbond from sidechain"
    SIDECHAIN_UNBOND
    "Side chain deposit"
    SIDE_DEPOSIT
    "Side chain submit poroposal"
    SIDE_SUBMIT_PROPOSAL
    "Side chain vote"
    SIDE_VOTE
    "Tiny Token Issue"
    TINY_TOKEN_ISSUE
    "Trade buy side"
    TRADE_BUY
    "Trade sell side"
    TRADE_SELL
    "Transfer"
    TRANSFER
    "Cross chain transfer"
    TRANSFER_OUT
    "Transaction fee"
    TX_FEE
    "UnBind"
    UNBIND
}

enum BinanceTransfersMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Currency symbol"
    currency_symbol
    "Date"
    date
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum BitcoinBlockUniq {
    "Unique date count"
    dates
}

enum BitcoinBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Date"
    date
    "Time"
    time
    "Tx Count"
    transaction_count
}

enum BitcoinCoinpathMethod {
    "Tracking money flow by amounts, ignoring coins (default)"
    moneyflow
    "Tracking coins by UTXO transactions"
    utxo
}

enum BitcoinInputScriptType {
    "Input Script Coinbase Script"
    coinbase
    "Input Script Signature"
    scriptSig
    "Input Script TX Witness Script"
    txinwitness
}

enum BitcoinInputUniq {
    "Unique addresses count"
    addresses
    "Unique block count"
    blocks
    "Unique date count"
    dates
    "Unique transactions count"
    transactions
}

enum BitcoinInputsMeasureable {
    "Address"
    address
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Input index"
    input_index
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction index"
    tx_index
}

enum BitcoinNetwork {
    "Bitcoin Cash ( BCH )"
    bitcash
    "Bitcoin ( BTC )"
    bitcoin
    "Bitcoin SV ( BSV )"
    bitcoinsv
    "Dash ( DASH )"
    dash
    "Dogecoin ( DOGE )"
    dogecoin
    "Litecoin ( LTC )"
    litecoin
    "ZCash ( ZCASH )"
    zcash
}

enum BitcoinOmniTransactionsMeasureablse {
    "Block"
    block
    "Date"
    date
    "Time"
    time
    "Transactions hash"
    tx_hash
    "Transactions index"
    tx_index
}

enum BitcoinOmniTransactionsUniq {
    "Unique block count"
    blocks
    "Unique date count"
    dates
    "Unique transaction sender"
    tx_sender
}

enum BitcoinOmniTransfersMeasureablse {
    "Block"
    block
    "Date"
    date
    "Time"
    time
    "Transactions hash"
    tx_hash
    "Transactions index"
    tx_index
}

enum BitcoinOmniTransfersUniq {
    "Unique block count"
    blocks
    "Unique date count"
    dates
    "Unique transaction sender"
    tx_sender
}

enum BitcoinOutputDirection {
    "Change return"
    change
    "Fee"
    fee
    "Genesis"
    genesis
    "Likely Change return"
    likely_change
    "Likely Not a change return"
    likely_not_change
    "Mining"
    mining
    "Minting"
    minting
    "Not a change return"
    not_change
    "Not defined"
    unknown
}

enum BitcoinOutputScriptType {
    "Output Multisignature Wallet"
    multisig
    "Non standard output script"
    nonstandard
    "Output nulldata"
    nulldata
    "Output PubKey"
    pubkey
    "Output PubKey Hash"
    pubkeyhash
    "Output Script Hash"
    scripthash
    "Output Witness Other"
    witness_unknown
    "Output Witness Key Hash"
    witness_v0_keyhash
    "Output Witness Script Hash"
    witness_v0_scripthash
}

enum BitcoinOutputUniq {
    "Unique input addresses count"
    addresses
    "Unique block count"
    blocks
    "Unique date count"
    dates
    "Unique transactions count"
    transactions
}

enum BitcoinOutputsMeasureable {
    "Address"
    address
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Output index"
    output_index
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction index"
    tx_index
}

enum BitcoinTransactionUniq {
    "Unique block count"
    blocks
    "Unique date count"
    dates
}

enum BitcoinTransactionsMeasureable {
    "Block"
    block
    "Date"
    date
    "Input count"
    input_count
    "Transaction input value"
    input_value
    "Output count"
    output_count
    "Transaction output value"
    output_value
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction index"
    tx_index
    "Transaction size"
    tx_size
}

enum CardanoBlockUniq {
    "Unique date count"
    dates
    "Unique epoch"
    epoch
    "Unique slot"
    slot
    "Unique slot leader"
    slot_leader
    "Unique version"
    version
}

enum CardanoBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Date"
    date
    "Time"
    time
    "Tx Count"
    transaction_count
}

enum CardanoCoinpathMethod {
    "Tracking money flow by amounts, ignoring coins (default)"
    moneyflow
    "Tracking coins by UTXO transactions"
    utxo
}

enum CardanoInputSource {
    "Input"
    input
    "Withdrawal"
    withdrawal
}

enum CardanoInputUniq {
    "Unique addresses count"
    addresses
    "Unique block count"
    blocks
    "Unique currencies count"
    currencies
    "Unique date count"
    dates
    "Unique transactions count"
    transactions
}

enum CardanoInputsMeasureable {
    "Address"
    address
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Input index"
    input_index
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction index"
    tx_index
}

enum CardanoMintUniq {
    "Unique block count"
    blocks
    "Unique currencies count"
    currencies
    "Unique date count"
    dates
    "Unique transactions count"
    transactions
}

enum CardanoMintsMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction index"
    tx_index
}

enum CardanoNetwork {
    "Cardano ( ADA )"
    cardano
}

enum CardanoOutputDirection {
    "Change return"
    change
    "Fee"
    fee
    "Genesis"
    genesis
    "Likely Change return"
    likely_change
    "Likely Not a change return"
    likely_not_change
    "Mining"
    mining
    "Minting"
    minting
    "Not a change return"
    not_change
    "Not defined"
    unknown
}

enum CardanoOutputUniq {
    "Unique input addresses count"
    addresses
    "Unique block count"
    blocks
    "Unique currencies count"
    currencies
    "Unique date count"
    dates
    "Unique transactions count"
    transactions
}

enum CardanoOutputsMeasureable {
    "Address"
    address
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Output index"
    output_index
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction index"
    tx_index
}

enum CardanoTransactionUniq {
    "Unique block count"
    blocks
    "Unique date count"
    dates
}

enum CardanoTransactionsMeasureable {
    "Block"
    block
    "Date"
    date
    "Transaction deposit value"
    deposit_value
    "Input count"
    input_count
    "Transaction input value"
    input_value
    "Transaction mint count"
    mint_count
    "Output count"
    output_count
    "Transaction output value"
    output_value
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction index"
    tx_index
    "Transaction size"
    tx_size
    "Transaction withdrawal count"
    withdrawal_count
    "Transaction withdrawal value"
    withdrawal_value
}

enum CoinpathMeasureable {
    "Block"
    block
    "Depth"
    depth
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum ConfluxBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Date"
    date
    "Block Miner"
    miner
    "Block Referee Count"
    referee_count
    "Time"
    time
    "Block TX Count"
    transaction_count
}

enum ConfluxNetwork {
    "Conflux Oceanus"
    conflux_oceanus
    "Conflux Tethys"
    conflux_tethys
}

enum ConfluxTransactionsMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Gas used"
    gas
    "Gas price"
    gas_price
    "Gas value"
    gas_value
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction Sender"
    tx_sender
}

enum Continent {
    "Africa"
    Africa
    "Antarctica"
    Antarctica
    "Asia"
    Asia
    "Europe"
    Europe
    "North America"
    North_America
    "Oceania"
    Oceania
    "South America"
    South_America
}

enum CountryCode {
    "Andorra"
    AD
    "United Arab Emirates"
    AE
    "Afghanistan"
    AF
    "Antigua and Barbuda"
    AG
    "Anguilla"
    AI
    "Albania"
    AL
    "Armenia"
    AM
    "Netherlands Antilles"
    AN
    "Angola"
    AO
    "Antarctica"
    AQ
    "Argentina"
    AR
    "American Samoa"
    AS
    "Austria"
    AT
    "Australia"
    AU
    "Aruba"
    AW
    "Azerbaijan"
    AZ
    "Bosnia and Herzegovina"
    BA
    "Barbados"
    BB
    "Bangladesh"
    BD
    "Belgium"
    BE
    "Burkina Faso"
    BF
    "Bulgaria"
    BG
    "Bahrain"
    BH
    "Burundi"
    BI
    "Benin"
    BJ
    "Saint Barthelemy"
    BL
    "Bermuda"
    BM
    "Brunei"
    BN
    "Bolivia"
    BO
    "Brazil"
    BR
    "Bahamas"
    BS
    "Bhutan"
    BT
    "Botswana"
    BW
    "Belarus"
    BY
    "Belize"
    BZ
    "Canada"
    CA
    "Cocos Islands"
    CC
    "Democratic Republic of the Congo"
    CD
    "Central African Republic"
    CF
    "Republic of the Congo"
    CG
    "Switzerland"
    CH
    "Ivory Coast"
    CI
    "Cook Islands"
    CK
    "Chile"
    CL
    "Cameroon"
    CM
    "China"
    CN
    "Colombia"
    CO
    "Costa Rica"
    CR
    "Cuba"
    CU
    "Cape Verde"
    CV
    "Curacao"
    CW
    "Christmas Island"
    CX
    "Cyprus"
    CY
    "Czech Republic"
    CZ
    "Germany"
    DE
    "Djibouti"
    DJ
    "Denmark"
    DK
    "Dominica"
    DM
    "Dominican Republic"
    DO
    "Algeria"
    DZ
    "Ecuador"
    EC
    "Estonia"
    EE
    "Egypt"
    EG
    "Western Sahara"
    EH
    "Eritrea"
    ER
    "Spain"
    ES
    "Ethiopia"
    ET
    "Finland"
    FI
    "Fiji"
    FJ
    "Falkland Islands"
    FK
    "Micronesia"
    FM
    "Faroe Islands"
    FO
    "France"
    FR
    "Gabon"
    GA
    "United Kingdom"
    GB
    "Grenada"
    GD
    "Georgia"
    GE
    "Guernsey"
    GG
    "Ghana"
    GH
    "Gibraltar"
    GI
    "Greenland"
    GL
    "Gambia"
    GM
    "Guinea"
    GN
    "Equatorial Guinea"
    GQ
    "Greece"
    GR
    "Guatemala"
    GT
    "Guam"
    GU
    "Guinea-Bissau"
    GW
    "Guyana"
    GY
    "Hong Kong"
    HK
    "Honduras"
    HN
    "Croatia"
    HR
    "Haiti"
    HT
    "Hungary"
    HU
    "Indonesia"
    ID
    "Ireland"
    IE
    "Israel"
    IL
    "Isle of Man"
    IM
    "India"
    IN
    "British Indian Ocean Territory"
    IO
    "Iraq"
    IQ
    "Iran"
    IR
    "Iceland"
    IS
    "Italy"
    IT
    "Jersey"
    JE
    "Jamaica"
    JM
    "Jordan"
    JO
    "Japan"
    JP
    "Kenya"
    KE
    "Kyrgyzstan"
    KG
    "Cambodia"
    KH
    "Kiribati"
    KI
    "Comoros"
    KM
    "Saint Kitts and Nevis"
    KN
    "North Korea"
    KP
    "South Korea"
    KR
    "Kuwait"
    KW
    "Cayman Islands"
    KY
    "Kazakhstan"
    KZ
    "Laos"
    LA
    "Lebanon"
    LB
    "Saint Lucia"
    LC
    "Liechtenstein"
    LI
    "Sri Lanka"
    LK
    "Liberia"
    LR
    "Lesotho"
    LS
    "Lithuania"
    LT
    "Luxembourg"
    LU
    "Latvia"
    LV
    "Libya"
    LY
    "Morocco"
    MA
    "Monaco"
    MC
    "Moldova"
    MD
    "Montenegro"
    ME
    "Saint Martin"
    MF
    "Madagascar"
    MG
    "Marshall Islands"
    MH
    "Macedonia"
    MK
    "Mali"
    ML
    "Myanmar"
    MM
    "Mongolia"
    MN
    "Macau"
    MO
    "Northern Mariana Islands"
    MP
    "Mauritania"
    MR
    "Montserrat"
    MS
    "Malta"
    MT
    "Mauritius"
    MU
    "Maldives"
    MV
    "Malawi"
    MW
    "Mexico"
    MX
    "Malaysia"
    MY
    "Mozambique"
    MZ
    "Namibia"
    NA
    "New Caledonia"
    NC
    "Niger"
    NE
    "Nigeria"
    NG
    "Nicaragua"
    NI
    "Netherlands"
    NL
    "Norway"
    NO
    "Nepal"
    NP
    "Nauru"
    NR
    "Niue"
    NU
    "New Zealand"
    NZ
    "Oman"
    OM
    "Panama"
    PA
    "Peru"
    PE
    "French Polynesia"
    PF
    "Papua New Guinea"
    PG
    "Philippines"
    PH
    "Pakistan"
    PK
    "Poland"
    PL
    "Saint Pierre and Miquelon"
    PM
    "Pitcairn"
    PN
    "Puerto Rico"
    PR
    "Palestine"
    PS
    "Portugal"
    PT
    "Palau"
    PW
    "Paraguay"
    PY
    "Qatar"
    QA
    "Reunion"
    RE
    "Romania"
    RO
    "Serbia"
    RS
    "Russia"
    RU
    "Rwanda"
    RW
    "Saudi Arabia"
    SA
    "Solomon Islands"
    SB
    "Seychelles"
    SC
    "Sudan"
    SD
    "Sweden"
    SE
    "Singapore"
    SG
    "Saint Helena"
    SH
    "Slovenia"
    SI
    "Svalbard and Jan Mayen"
    SJ
    "Slovakia"
    SK
    "Sierra Leone"
    SL
    "San Marino"
    SM
    "Senegal"
    SN
    "Somalia"
    SO
    "Suriname"
    SR
    "South Sudan"
    SS
    "Sao Tome and Principe"
    ST
    "El Salvador"
    SV
    "Sint Maarten"
    SX
    "Syria"
    SY
    "Swaziland"
    SZ
    "Turks and Caicos Islands"
    TC
    "Chad"
    TD
    "Togo"
    TG
    "Thailand"
    TH
    "Tajikistan"
    TJ
    "Tokelau"
    TK
    "East Timor"
    TL
    "Turkmenistan"
    TM
    "Tunisia"
    TN
    "Tonga"
    TO
    "Turkey"
    TR
    "Trinidad and Tobago"
    TT
    "Tuvalu"
    TV
    "Taiwan"
    TW
    "Tanzania"
    TZ
    "Ukraine"
    UA
    "Uganda"
    UG
    "United States"
    US
    "Uruguay"
    UY
    "Uzbekistan"
    UZ
    "Vatican"
    VA
    "Saint Vincent and the Grenadines"
    VC
    "Venezuela"
    VE
    "British Virgin Islands"
    VG
    "U.S. Virgin Islands"
    VI
    "Vietnam"
    VN
    "Vanuatu"
    VU
    "Wallis and Futuna"
    WF
    "Samoa"
    WS
    "Kosovo"
    XK
    "Yemen"
    YE
    "Mayotte"
    YT
    "South Africa"
    ZA
    "Zambia"
    ZM
    "Zimbabwe"
    ZW
}

enum DateInterval {
    "Day"
    day
    "Month"
    month
    "Week"
    week
    "Year"
    year
}

enum DiemNetwork {
    "Diem Testnet"
    diem_testnet
    "Libra Testnet"
    libra_testnet
}

enum ElrondArgumentUniq {
    "Unique number of arguments"
    argument_index
    "Unique Number of block in the blockchains"
    block_height
    "Unique date count"
    dates
    "Unique Transaction Hash"
    signature
    "Unique time"
    times
}

enum ElrondArgumentsMeasureable {
    "Argument Index"
    argument_index
    "Argument Value"
    argument_value
    "Hash of the the block"
    block_hash
    "Smart Contract call path"
    call_depth
    "Data"
    data
    "Date"
    date
    "Gas Limit"
    gas_limit
    "Gas Price"
    gas_price
    "Gas Used"
    gas_used
    "Number of block in the blockhains"
    height
    "Hash of the miniblock"
    miniblock_hash
    "Hash of the miniblocks receiver block"
    miniblock_receiver_block_hash
    "Miniblock receiver shard"
    miniblock_receiver_shard
    "The block hash of this block`s parent"
    previous_block_hash
    "Smart Contract Address"
    smart_contract_address
    "Time"
    time
    "The block hash of this block`s parent"
    transaction_count
    "Transaction hash"
    tx_hash
    "Receiver hash"
    tx_receiver
    "Shard number of the receiver"
    tx_receiver_shard
    "Sender hash"
    tx_sender
    "Shard number of the sender"
    tx_sender_shard
    "Transaction Signature"
    tx_signature
    "Value"
    tx_value
    "Type of miniblock"
    type
}

enum ElrondBlockUniq {
    "Unique date count"
    dates
    "Unique Number of block in the blockchains"
    height
    "Unique time"
    times
}

enum ElrondBlockValidatorUniq {
    "Unique date count"
    dates
    "Unique Number of block in the blockchains"
    height
    "Unique time"
    times
    "Unique number of validators"
    validators
}

enum ElrondBlockValidatorsMeasureable {
    "Date"
    date
    "Block epoch"
    epoch
    "Hash of the the block"
    hash
    "Number of block in the blockhains"
    height
    "Block nonce"
    nonce
    "The block hash of this block`s parent"
    previous_block_hash
    "Block proposer"
    proposer
    "Block public key bitmap"
    public_key_bitmap
    "Block round"
    round
    "Shard number of block"
    shard
    "Block size"
    size
    "Block size txs"
    size_txs
    "State root hash"
    state_root_hash
    "Time"
    time
    "Count of transactions in this block"
    transaction_count
    "Hash of the validator"
    validator
}

enum ElrondBlocksMeasureable {
    "Date"
    date
    "Block epoch"
    epoch
    "Hash of the the block"
    hash
    "Number of block in the blockhains"
    height
    "Block nonce"
    nonce
    "The block hash of this block`s parent"
    previous_block_hash
    "Block proposer"
    proposer
    "Block public key bitmap"
    public_key_bitmap
    "Block round"
    round
    "Shard number of block"
    shard
    "Block size"
    size
    "Block size txs"
    size_txs
    "State root hash"
    state_root_hash
    "Time"
    time
    "Count of transactions in this block"
    transaction_count
}

enum ElrondCallResultUniq {
    "Unique date count"
    dates
    "Unique Number of block in the blockchains"
    height
    "Unique Number of call results"
    index
    "Unique time"
    times
}

enum ElrondCallResultsMeasureable {
    "Hash of the the block"
    block_hash
    "Data of the call result"
    call_result_data
    "Hash of the call result"
    call_result_hash
    "Index of the call result"
    call_result_index
    "Receiver of the call result"
    call_result_receiver
    "Sender of the call result"
    call_result_sender
    "Data"
    data
    "Date"
    date
    "Gas Limit"
    gas_limit
    "Gas Price"
    gas_price
    "Gas Used"
    gas_used
    "Number of block in the blockhains"
    height
    "Hash of the miniblock"
    miniblock_hash
    "Hash of the miniblocks receiver block"
    miniblock_receiver_block_hash
    "Miniblock receiver shard"
    miniblock_receiver_shard
    "The block hash of this block`s parent"
    previous_block_hash
    "Previous transaction hash of the call result"
    previous_tx_hash
    "Time"
    time
    "The block hash of this block`s parent"
    transaction_count
    "Transaction hash"
    tx_hash
    "Receiver hash"
    tx_receiver
    "Shard number of the receiver"
    tx_receiver_shard
    "Sender hash"
    tx_sender
    "Shard number of the sender"
    tx_sender_shard
    "Value"
    tx_value
    "Type of miniblock"
    type
}

enum ElrondCallsMeasureable {
    "Hash of the the block"
    block_hash
    "Call depth"
    call_depth
    "Data"
    data
    "Date"
    date
    "Gas Limit"
    gas_limit
    "Gas Price"
    gas_price
    "Gas Used"
    gas_used
    "Number of block in the blockhains"
    height
    "Hash of the miniblock"
    miniblock_hash
    "Hash of the miniblocks receiver block"
    miniblock_receiver_block_hash
    "Miniblock receiver shard"
    miniblock_receiver_shard
    "The block hash of this block`s parent"
    previous_block_hash
    "Smart Contract Method Signature"
    signature
    "Smart Contract Method Signature Hash"
    signature_hash
    "Smart Contract Method Name"
    signature_name
    "Smart Contract"
    smart_contract
    "Time"
    time
    "The block hash of this block`s parent"
    transaction_count
    "Transaction hash"
    tx_hash
    "Receiver hash"
    tx_receiver
    "Shard number of the receiver"
    tx_receiver_shard
    "Sender hash"
    tx_sender
    "Shard number of the sender"
    tx_sender_shard
    "Value"
    tx_value
    "Type of miniblock"
    type
}

enum ElrondCallsUni {
    "Unique date count"
    dates
    "Unique Number of block in the blockchains"
    height
    "Unique Number of smart contract methods"
    smart_contract_methods
    "Unique Number of smart contract"
    smart_contracts
    "Unique time"
    times
}

enum ElrondCoinpathMeasureable {
    "Block"
    block
    "Depth"
    depth
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "Version"
    tx_hash
}

enum ElrondMiniblockUniq {
    "Unique date count"
    dates
    "Unique Number of block in the blockchains"
    height
    "Unique time"
    times
}

enum ElrondMiniblocksMeasureable {
    "Hash of the the block"
    block_hash
    "Date"
    date
    "Hash of the miniblock"
    hash
    "Number of block in the blockhains"
    height
    "The block hash of this block`s parent"
    previous_block_hash
    "Hash of the miniblocks receiver block"
    receiver_block_hash
    "Miniblock receiver shard"
    receiver_shard
    "Time"
    time
    "Count of transactions"
    transaction_count
    "Type of miniblock"
    type
}

enum ElrondNetwork {
    "Elrond mainnet"
    elrond
}

enum ElrondNotarizedBlockUniq {
    "Unique date count"
    dates
    "Unique Number of block in the blockchains"
    height
    "Unique hash of notarized block"
    notarized_block_hash
    "Unique time"
    times
}

enum ElrondNotarizedBlocksMeasureable {
    "Date"
    date
    "Block epoch"
    epoch
    "Hash of the the block"
    hash
    "Number of block in the blockhains"
    height
    "Block nonce"
    nonce
    "Notarized block hash"
    notarized_block_hash
    "The block hash of this block`s parent"
    previous_block_hash
    "Block proposer"
    proposer
    "Block public key bitmap"
    public_key_bitmap
    "Block round"
    round
    "Shard number of block"
    shard
    "Block size"
    size
    "Block size txs"
    size_txs
    "State root hash"
    state_root_hash
    "Time"
    time
    "Count of transactions in this block"
    transaction_count
}

enum ElrondTransactionUniq {
    "Unique date count"
    dates
    "Unique Number of block in the blockchains"
    height
    "Unique time"
    times
}

enum ElrondTransactionsMeasureable {
    "Hash of the the block"
    block_hash
    "Data"
    data
    "Date"
    date
    "Gas Limit"
    gas_limit
    "Gas Price"
    gas_price
    "Gas Used"
    gas_used
    "Transaction hash"
    hash
    "Number of block in the blockhains"
    height
    "Hash of the miniblock"
    miniblock_hash
    "Hash of the miniblocks receiver block"
    miniblock_receiver_block_hash
    "Miniblock receiver shard"
    miniblock_receiver_shard
    "The block hash of this block`s parent"
    previous_block_hash
    "Time"
    time
    "The block hash of this block`s parent"
    transaction_count
    "Receiver hash"
    tx_receiver
    "Shard number of the receiver"
    tx_receiver_shard
    "Sender hash"
    tx_sender
    "Shard number of the sender"
    tx_sender_shard
    "Type of miniblock"
    type
    "Value"
    value
}

enum ElrondTransferUniq {
    "Unique Number of block in the blockchains"
    block_height
    "Unique date count"
    dates
    "Unique Transaction Hash"
    signature
    "Unique time"
    times
}

enum ElrondTransfersMeasureable {
    "Transfer Amount"
    amount
    "Hash of the the block"
    block_hash
    "Data"
    data
    "Date"
    date
    "Gas Limit"
    gas_limit
    "Gas Price"
    gas_price
    "Gas Used"
    gas_used
    "Number of block in the blockhains"
    height
    "Hash of the miniblock"
    miniblock_hash
    "Hash of the miniblocks receiver block"
    miniblock_receiver_block_hash
    "Miniblock receiver shard"
    miniblock_receiver_shard
    "The block hash of this block`s parent"
    previous_block_hash
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "The block hash of this block`s parent"
    transaction_count
    "Transaction hash"
    tx_hash
    "Receiver hash"
    tx_receiver
    "Shard number of the receiver"
    tx_receiver_shard
    "Sender hash"
    tx_sender
    "Shard number of the sender"
    tx_sender_shard
    "Value"
    tx_value
    "Type of miniblock"
    type
}

enum EntityTypeEnum {
    "account"
    account
    "contract"
    contract
    "file"
    file
    "schedule"
    schedule
    "token"
    token
    "topic"
    topic
}

enum EosBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Date"
    date
    "Block Proposer"
    proposer
    "Time"
    time
}

enum EosBlocksUniq {
    "Unique date count"
    dates
    "Unique proposer count"
    proposers
}

enum EosCallsMeasureable {
    "Block"
    block
    "Call depth"
    call_depth
    "Date"
    date
    "Smart Contract Method Signature"
    signature
    "Smart Contract Method Signature Hash"
    signature_hash
    "Smart Contract Method Name"
    signature_name
    "Smart Contract"
    smart_contract
    "Time"
    time
    "Action From"
    tx_from
    "Transaction hash"
    tx_hash
    "Sender"
    tx_sender
    "Action To"
    tx_to
}

enum EosNetwork {
    "EOS mainnet"
    eos
}

enum EosTransactionsMeasureable {
    "Block"
    block
    "CPU Usage"
    cpu_usage_us
    "Date"
    date
    "Net Usage"
    net_usage_words
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum EosTransactionsUniq {
    "Unique blocks"
    blocks
    "Unique date count"
    dates
}

enum EosTransfersMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Token address"
    currency_address
    "Currency symbol"
    currency_symbol
    "Date"
    date
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum Ethereum2AttestationsMeasureable {
    "Block"
    block
    "Block Proposer"
    block_proposer
    "Block hash"
    block_root_hash
    "Committee Index"
    committee
    "Date"
    date
    "Time"
    time
    "Validator index"
    validator
}

enum Ethereum2AttestationsUniq {
    "Unique attestation epochs"
    attestation_epochs
    "Unique attestation slots"
    attestation_slots
    "Unique attestations"
    attestations
    "Unique block proposers"
    block_proposers
    "Unique blocks"
    blocks
    "Unique commitees"
    committees
    "Unique date count"
    dates
    "Unique validators"
    validators
}

enum Ethereum2AttesterSlashingMeasureable {
    "Block"
    block
    "Block Proposer"
    block_proposer
    "Block hash"
    block_root_hash
    "Date"
    date
    "Time"
    time
    "Validator index"
    validator
}

enum Ethereum2AttesterSlashingsUniq {
    "Unique slashing epochs"
    attestation_epochs
    "Unique slashing slots"
    attestation_slots
    "Unique block proposers"
    block_proposers
    "Unique blocks"
    blocks
    "Unique date count"
    dates
    "Unique validators"
    validators
}

enum Ethereum2BlocksMeasureable {
    "Block"
    block
    "Block Miner"
    block_proposer
    "Block hash"
    block_root_hash
    "Date"
    date
    "Time"
    time
}

enum Ethereum2BlocksUniq {
    "Unique proposers"
    block_proposers
    "Unique date count"
    dates
}

enum Ethereum2DepositsMeasureable {
    "Block"
    block
    "Block Proposer"
    block_proposer
    "Block hash"
    block_root_hash
    "Date"
    date
    "Time"
    time
    "Validator index"
    validator
}

enum Ethereum2DepositsUniq {
    "Unique block proposers"
    block_proposers
    "Unique blocks"
    blocks
    "Unique date count"
    dates
    "Unique validators"
    validators
}

enum Ethereum2Network {
    "Beacon Chain Ethereum 2.0"
    eth2
    "Medalla Ethereum 2.0 Beacon Testnet"
    medalla
}

enum Ethereum2ProposerSlashingMeasureable {
    "Block"
    block
    "Block Proposer"
    block_proposer
    "Block hash"
    block_root_hash
    "Date"
    date
    "Slashed Proposer"
    proposer
    "Time"
    time
}

enum Ethereum2ProposerSlashingsUniq {
    "Unique block proposers"
    block_proposers
    "Unique blocks"
    blocks
    "Unique date count"
    dates
    "Unique slashing epochs"
    slashing_epochs
    "Unique slashing proposers"
    slashing_proposers
    "Unique slashing slots"
    slashing_slots
}

enum Ethereum2VoluntaryExitsMeasureable {
    "Block"
    block
    "Block Proposer"
    block_proposer
    "Block hash"
    block_root_hash
    "Date"
    date
    "Time"
    time
    "Validator index"
    validator
}

enum Ethereum2VoluntaryExitsUniq {
    "Unique block proposers"
    block_proposers
    "Unique blocks"
    blocks
    "Unique date count"
    dates
    "Unique validators"
    validators
}

enum EthereumArgumentsConvertable {
    "Token name"
    token_name
    "Token symbol"
    token_symbol
}

enum EthereumArgumentsMeasureable {
    "Argument"
    argument
    "Argument index"
    argument_index
    "Argument type"
    argument_type
    "Argument value"
    argument_value
    "Block"
    block
    "Call depth"
    call_depth
    "Caller"
    caller
    "Date"
    date
    "Smart Contract Method Signature"
    signature
    "Smart Contract Method Signature Hash"
    signature_hash
    "Smart Contract Method Name"
    signature_name
    "Smart Contract Method Signature"
    signature_type
    "Smart Contract"
    smart_contract
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum EthereumBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Block Reward"
    block_reward
    "Date"
    date
    "Block Miner"
    miner
    "Time"
    time
}

enum EthereumBlocksUniq {
    "Unique date count"
    dates
    "Unique miner count"
    miners
}

enum EthereumCallsMeasureable {
    "Block"
    block
    "Call depth"
    call_depth
    "Caller"
    caller
    "Date"
    date
    "Smart Contract Method Signature"
    signature
    "Smart Contract Method Signature Hash"
    signature_hash
    "Smart Contract Method Name"
    signature_name
    "Smart Contract"
    smart_contract
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum EthereumDexTradesMeasureable {
    "Block"
    block
    "Buy Amount"
    buy_amount
    "Buy Token address"
    buy_currency_address
    "Buy Currency symbol"
    buy_currency_symbol
    "Date"
    date
    "Maker"
    maker
    "Price"
    price
    "Quote Price"
    quote_price
    "Sell Amount"
    sell_amount
    "Sell Token address"
    sell_currency_address
    "Sell Currency symbol"
    sell_currency_symbol
    "Taker"
    taker
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum EthereumDexTradesUniq {
    "Unique makers & takers count"
    address
    "Base currencies count"
    base_currency
    "Unique blocks"
    blocks
    "Buy currencies count"
    buy_currency
    "Unique date count"
    dates
    "Unique makers count"
    makers
    "Unique protocols count"
    protocols
    "Quote currencies count"
    quote_currency
    "Sell currencies count"
    sell_currency
    "Unique TX senders count"
    senders
    "Unique smart contract count"
    smart_contracts
    "Unique makers count"
    takers
    "Unique transactions count"
    txs
}

enum EthereumEventsMeasureable {
    "Block"
    block
    "Date"
    date
    "Smart Contract Event Signature"
    signature
    "Smart Contract Event Signature Hash"
    signature_hash
    "Smart Contract Event Name"
    signature_name
    "Smart Contract"
    smart_contract
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum EthereumNetwork {
    "Binance Smart Chain Mainnet"
    bsc
    "Binance Smart Chain Testnet"
    bsc_testnet
    "Celo Alfajores Testnet"
    celo_alfajores
    "Celo Baklava Testnet"
    celo_baklava
    "Celo RC1"
    celo_rc1
    "Ethereum Classic"
    ethclassic
    "Ethereum Classic ( no reorg from block 10904146)"
    ethclassic_reorg
    "Ethereum Mainnet"
    ethereum
    "Goerli Ethereum Testnet"
    goerli
    "Klaytn Mainnet"
    klaytn
    "Matic (Polygon) Mainnet"
    matic
    "Velas Mainnet"
    velas
    "Velas Testnet"
    velas_testnet
}

enum EthereumTransactionsMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Gas used"
    gas
    "Gas price"
    gas_price
    "Gas value"
    gas_value
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction Sender"
    tx_sender
}

enum EthereumTransactionsUniq {
    "Unique blocks"
    blocks
    "Unique date count"
    dates
    "Unique TX receivers count"
    receivers
    "Unique TX senders count"
    senders
}

enum EthereumTransfersMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Token address"
    currency_address
    "Currency symbol"
    currency_symbol
    "Date"
    date
    "Entity ID"
    entity_id
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum FilecoinBlockUniq {
    "Unique block count"
    blocks
    "Unique date count"
    dates
    "Unique block height count"
    heights
    "Miner"
    miners
}

enum FilecoinBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Date"
    date
    "Block Miner"
    miner
    "Time"
    time
}

enum FilecoinCallsMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Gas used"
    gas
    "Gas limit"
    gas_limit
    "Gas value"
    gas_value
    "Message hash"
    message_hash
    "Time"
    time
}

enum FilecoinMessagesMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Date"
    date
    "Gas used"
    gas
    "Gas limit"
    gas_limit
    "Gas value"
    gas_value
    "Message hash"
    message_hash
    "Time"
    time
}

enum FilecoinMessagesUniq {
    "Unique block heights"
    blocks
    "Unique date count"
    dates
    "Unique Message receivers"
    receivers
    "Unique Message senders"
    senders
}

enum FilecoinNetwork {
    "Filecoin Mainnet"
    filecoin
}

enum FilecoinTransferType {
    "Burn"
    burn
    "Genesis"
    genesis
    "Miner Tip"
    miner
    "Rebalance"
    rebalance
    "Reward"
    reward
    "Send (transfer)"
    send
}

enum FilecoinTransfersMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Date"
    date
    "Gas used"
    gas
    "Gas limit"
    gas_limit
    "Gas value"
    gas_value
    "Time"
    time
    "Transfer hash"
    tx_hash
    "Value"
    value
}

enum FlowDirection {
    "Inbound transfers"
    inbound
    "Outbound transfers"
    outbound
}

enum HederaArgumentsMeasureable {
    "Date"
    date
    "Max Fee"
    max_fee
    "Time"
    time
    "Charged Fee"
    transaction_fee
    "Transaction Hash"
    transaction_hash
    "Valid duration"
    valid_duration
    "Valid start"
    valid_start
}

enum HederaArgumentsUniq {
    "Unique consensus time"
    consensus_times
    "Unique date count"
    dates
    "Unique initial balance"
    initial_balance
    "Unique node account"
    node_account
    "Unique payer account"
    payer_account
    "Unique node account"
    smart_contract_entity
    "Unique time"
    times
}

enum HederaCallsMeasureable {
    "Date"
    date
    "Max Fee"
    max_fee
    "Time"
    time
    "Charged Fee"
    transaction_fee
    "Transaction Hash"
    transaction_hash
    "Valid duration"
    valid_duration
    "Valid start"
    valid_start
}

enum HederaCallsUniq {
    "Unique consensus time"
    consensus_times
    "Unique date count"
    dates
    "Unique initial balance"
    initial_balance
    "Unique node account"
    node_account
    "Unique payer account"
    payer_account
    "Unique node account"
    smart_contract_entity
    "Unique time"
    times
}

enum HederaInputMeasureable {
    "Amount"
    amount
    "Date"
    date
    "Max Fee"
    max_fee
    "Time"
    time
    "Charged Fee"
    transaction_fee
    "Transaction Hash"
    transaction_hash
    "Valid duration"
    valid_duration
    "Valid start"
    valid_start
}

enum HederaInputsUniq {
    "Unique consensus time"
    consensus_times
    "Unique date count"
    dates
    "Unique entity id"
    entity_id
    "Unique entity type"
    entity_type
    "Unique initial balance"
    initial_balance
    "Unique node account"
    node_account
    "Unique payer account"
    payer_account
    "Unique time"
    times
}

enum HederaMessageMeasureable {
    "Date"
    date
    "Max Fee"
    max_fee
    "Time"
    time
    "Charged Fee"
    transaction_fee
    "Transaction Hash"
    transaction_hash
    "Valid duration"
    valid_duration
    "Valid start"
    valid_start
}

enum HederaMessagesUniq {
    "Unique consensus time"
    consensus_times
    "Unique date count"
    dates
    "Unique entity id"
    entity_id
    "Unique entity type"
    entity_type
    "Unique initial balance"
    initial_balance
    "Unique node account"
    node_account
    "Unique payer account"
    payer_account
    "Unique time"
    times
}

enum HederaNetwork {
    "The Hedera mainnet"
    hedera
    "The Hedera testnets"
    hedera_testnets
}

enum HederaOutputMeasureable {
    "Amount"
    amount
    "Date"
    date
    "Max Fee"
    max_fee
    "Time"
    time
    "Charged Fee"
    transaction_fee
    "Transaction Hash"
    transaction_hash
    "Valid duration"
    valid_duration
    "Valid start"
    valid_start
}

enum HederaOutputUniq {
    "Unique consensus time"
    consensus_times
    "Unique date count"
    dates
    "Unique entity id"
    entity_id
    "Unique entity type"
    entity_type
    "Unique initial balance"
    initial_balance
    "Unique node account"
    node_account
    "Unique payer account"
    payer_account
    "Unique time"
    times
    "Unique Transfer entity"
    transfer_entity
}

enum HederaTransactionMeasureable {
    "Date"
    date
    "Max Fee"
    max_fee
    "Time"
    time
    "Charged Fee"
    transaction_fee
    "Transaction Hash"
    transaction_hash
    "Valid duration"
    valid_duration
    "Valid start"
    valid_start
}

enum HederaTransactionsUniq {
    "Unique consensus time"
    consensus_times
    "Unique date count"
    dates
    "Unique entity id"
    entity_id
    "Unique entity type"
    entity_type
    "Unique initial balance"
    initial_balance
    "Unique node account"
    node_account
    "Unique payer account"
    payer_account
    "Unique time"
    times
    "Unique transaction type"
    transaction_type
}

enum LibraBlockUniq {
    "Unique date count"
    dates
    "Proposer"
    proposer
}

enum LibraBlocksMeasureable {
    "Block round"
    block
    "Date"
    date
    "Gas Used"
    gas_used
    "Proposer"
    proposer
    "Time"
    time
    "Version"
    version
}

enum LibraCoinpathMeasureable {
    "Block"
    block
    "Depth"
    depth
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "Version"
    version
}

enum LibraMintsMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Currency symbol"
    currency_symbol
    "Date"
    date
    "Minter"
    minter
    "Time"
    time
    "Version"
    version
    "Mint version hash"
    version_hash
}

enum LibraMintsUniq {
    "Unique blocks"
    blocks
    "Unique currencies"
    currencies
    "Unique date count"
    dates
    "Unique minters"
    minters
    "Unique versions"
    versions
}

enum LibraTransactionsMeasureable {
    "Block"
    block
    "Date"
    date
    "Gas used"
    gas
    "Gas price"
    gas_price
    "Script Hash"
    script_hash
    "Time"
    time
    "Transaction Sender"
    tx_sender
    "Version"
    version
}

enum LibraTransactionsUniq {
    "Unique blocks"
    blocks
    "Unique date count"
    dates
    "Unique transaction script hashes"
    scripts
    "Unique transaction senders"
    senders
    "Unique versions"
    versions
}

enum LibraTransfersMeasureable {
    "Amount"
    amount
    "Currency symbol"
    currency_symbol
    "Date"
    date
    "Gas used"
    gas
    "Gas price"
    gas_price
    "Gas value"
    gas_value
    "Block"
    height
    "Receiver"
    receiver
    "Script Hash"
    script_hash
    "Sender"
    sender
    "Time"
    time
    "Transfer Sender"
    tx_sender
    "Version"
    version
    "Version hash"
    version_hash
}

enum Network {
    "Algorand Mainnet (ALGO)"
    algorand
    "Algorand Betanet"
    algorand_betanet
    "Algorand Testnet"
    algorand_testnet
    "Binance DEX"
    binance
    "Bitcoin Cash ( BCH )"
    bitcash
    "Bitcoin ( BTC )"
    bitcoin
    "Bitcoin SV ( BSV )"
    bitcoinsv
    "Binance Smart Chain Mainnet"
    bsc
    "Binance Smart Chain Testnet"
    bsc_testnet
    "Cardano ( ADA )"
    cardano
    "Celo Alfajores Testnet"
    celo_alfajores
    "Celo Baklava Testnet"
    celo_baklava
    "Celo RC1"
    celo_rc1
    "Conflux Oceanus"
    conflux_oceanus
    "Conflux Tethys"
    conflux_tethys
    "Dash ( DASH )"
    dash
    "Diem Testnet"
    diem_testnet
    "Dogecoin ( DOGE )"
    dogecoin
    "Elrond Mainnet"
    elrond
    "EOS Mainnet"
    eos
    "Beacon Chain Ethereum 2.0"
    eth2
    "Ethereum Classic"
    ethclassic
    "Ethereum Classic ( no reorg from block 10904146)"
    ethclassic_reorg
    "Ethereum Mainnet"
    ethereum
    "Filecoin Mainnet"
    filecoin
    "Goerli Ethereum Testnet"
    goerli
    "Hedera Hashgraph"
    hedera
    "Klaytn Mainnet"
    klaytn
    "Libra Testnet"
    libra_testnet
    "Litecoin ( LTC )"
    litecoin
    "Matic (Polygon) Mainnet"
    matic
    "Medalla Ethereum 2.0 Beacon Testnet"
    medalla
    "Solana Mainnet"
    solana
    "TRON Mainnet"
    tron
    "Velas Mainnet"
    velas
    "Velas Testnet"
    velas_testnet
    "Zcash ( ZEC )"
    zcash
}

enum PriceAggregateFunction {
    "Any value"
    any
    "Last value"
    anyLast
    "Average"
    average
    "Maximum"
    maximum
    "Median"
    median
    "Minimum"
    minimum
    "Aggregated over interval"
    sum
}

enum Protocol {
    "Algorand"
    algorand
    "Binance DEX"
    binance
    "Bitcoin"
    bitcoin
    "Cardano"
    cardano
    "Elrond"
    elrond
    "EOS"
    eos
    "Ethereum"
    ethereum
    "Filecoin"
    filecoin
    "Hedera Hashgraph"
    hedera
    "Libra"
    libra
    "Solana"
    solana
    "Tron"
    tron
}

enum ScriptTypeSelectorSelector {
    "Peer-to-peer"
    peer_to_peer_transaction
    "Unknown Transaction"
    unknown_transaction
}

enum SignatureTypeSelector {
    "Smart contract event"
    Event
    "Smart contract method"
    Function
}

enum SmartContractArgumentsUniq {
    "Unique blocks"
    blocks
    "Unique callers count"
    callers
    "Calls or events"
    calls
    "Unique date count"
    dates
    "Unique transaction senders"
    senders
    "Unique signatures count"
    signatures
    "Unique smart contracts count"
    smart_contracts
    "Unique transactions count"
    txs
    "Unique values"
    values
}

enum SmartContractCallsUniq {
    "Unique blocks"
    blocks
    "Unique callers count"
    callers
    "Calls"
    calls
    "Unique date count"
    dates
    "Unique transaction senders"
    senders
    "Unique smart contract methods count"
    smart_contract_methods
    "Unique smart contracts count"
    smart_contracts
    "Unique transactions count"
    txs
}

enum SmartContractType {
    "Decentralized exchange"
    DEX
    "General Purpose Smart contract"
    Generic
    "Smart contract for token derivatives"
    MarginPositionToken
    "Multi signature wallet"
    Multisig
    "Not A Smart contract"
    None
    "Transaction Execution Approval Language"
    TEAL
    "Token"
    Token
    "Token Sale"
    TokenSale
}

enum SolanaBlockRewardsMeasureable {
    "Account"
    account
    "Number of reward lamports credited or debited by the account"
    amount
    "Hash of the the block"
    block_hash
    "Date"
    date
    "Number of block in the blockhains"
    height
    "The slot index of this block`s parent"
    parent_slot
    "Account balances after the transaction was processed"
    post_balance
    "The block hash of this block`s parent"
    previous_block_hash
    "Time"
    time
}

enum SolanaBlockRewardsUniq {
    "Unique accounts"
    account
    "Unique hash of the the block"
    block_hash
    "Unique currencies"
    currencies
    "Unique date count"
    dates
    "Unique time"
    times
}

enum SolanaBlocksMeasureable {
    "Hash of the the block"
    block_hash
    "Date"
    date
    "Number of block in the blockhains"
    height
    "The slot index of this block`s parent"
    parent_slot
    "The block hash of this block`s parent"
    previous_block_hash
    "Number of reward lamports credited or debited by the account"
    rewards
    "Time"
    time
    "Count of transactions in this block"
    transaction_count
}

enum SolanaBlocksUniq {
    "Unique date count"
    dates
    "Unique Number of block in the blockchains"
    height
    "Unique time"
    times
}

enum SolanaInstructionsMeasureable {
    "Hash of the the block"
    block_hash
    "Date"
    date
    "Transaction Fee"
    fee
    "Number of block in the blockhains"
    height
    "The block hash of this block`s parent"
    previous_block_hash
    "Transaction Hash"
    signature
    "Time"
    time
}

enum SolanaInstructionsUniq {
    "Unique date count"
    dates
    "Number of block in the blockchains"
    height
    "Transaction Hash"
    signature
    "Unique time"
    times
}

enum SolanaNetwork {
    "Solana Mainnat"
    solana
}

enum SolanaRewardType {
    "fee type"
    Fee
    "rent type"
    Rent
    "staking type"
    Staking
    "voing type"
    Voting
}

enum SolanaTransactionsMeasureable {
    "Hash of the the block"
    block_hash
    "Date"
    date
    "Transaction Fee"
    fee
    "Number of block in the blockhains"
    height
    "The slot index of this block`s parent"
    parent_slot
    "The block hash of this block`s parent"
    previous_block_hash
    "Transaction Hash"
    signature
    "Time"
    time
    "Transaction Fee"
    transaction_fee
}

enum SolanaTransactionsUniq {
    "Unique date count"
    dates
    "Number of block in the blockchains"
    height
    "Transaction Hash"
    signature
    "Accounts` public key"
    signer
    "Unique time"
    times
}

enum SolanaTransferType {
    "Burn"
    burn
    "Close Account"
    close_account
    "Create Account"
    create_account
    "Mint"
    mint
    "Nonce Withdraw"
    nonce_withdraw
    "Rent Exemption"
    rent_exemption
    "Self"
    self
    "Stake"
    stake
    "Stake Withdraw"
    stake_withdraw
    "Trade Unknown"
    trade_unknown
    "Transfer"
    transfer
    "Vote"
    vote
}

enum SolanaTransfersMeasureable {
    "Amount Transfers"
    amount
    "Hash of the the block"
    block_hash
    "Date"
    date
    "Transaction Fee"
    fee_payer
    "Number of block in the blockhains"
    height
    "The block hash of this block`s parent"
    previous_block_hash
    "Transaction Hash"
    signature
    "Time"
    time
    "Transfer Type"
    transfer_type
}

enum SolanaTransfersUniq {
    "Unique date count"
    dates
    "Number of block in the blockchains"
    height
    "Transfer To"
    receiver_address
    "Transfer From"
    sender_address
    "Transaction Hash"
    signature
    "Unique time"
    times
}

enum TradeSide {
    "Buy side"
    BUY
    "Sell side"
    SELL
}

enum TransferReasonEnum {
    "Smart Contract Call"
    call_result
    "ESDT Transfer"
    esdt_transfer
    "NFT Transfer"
    nft_transfer
    "Transaction"
    transaction
}

enum TransfersUniq {
    "Unique blocks"
    blocks
    "Unique currencies"
    currencies
    "Unique date count"
    dates
    "Unique receivers count"
    receivers
    "Unique senders count"
    senders
    "Transfers"
    transfers
    "Unique transactions count"
    txs
}

enum TronBlocksMeasureable {
    "Block"
    block
    "Block hash"
    block_hash
    "Date"
    date
    "Time"
    time
    "Block Version"
    version
    "Block Witness address"
    witness
}

enum TronBlocksUniq {
    "Unique date count"
    dates
    "Unique witness count"
    witnesses
}

enum TronCallsMeasureable {
    "Block"
    block
    "Call depth"
    call_depth
    "Date"
    date
    "Smart Contract Method Signature"
    signature
    "Smart Contract Method Signature Hash"
    signature_hash
    "Smart Contract Method Name"
    signature_name
    "Smart Contract"
    smart_contract
    "Time"
    time
    "Action From"
    tx_from
    "Transaction hash"
    tx_hash
    "Action To"
    tx_to
}

enum TronContractType {
    "Account Create"
    AccountCreate
    "Account Permission Update"
    AccountPermissionUpdate
    "Account Update"
    AccountUpdate
    "Asset Issue"
    AssetIssue
    "Clear ABI"
    ClearABI
    "Create Smart"
    CreateSmart
    "Exchange Create"
    ExchangeCreate
    "Exchange Inject"
    ExchangeInject
    "Exchange Transaction"
    ExchangeTransaction
    "Exchange Withdraw"
    ExchangeWithdraw
    "Freeze Balance"
    FreezeBalance
    "Participate Asset Issue"
    ParticipateAssetIssue
    "Proposal Approve"
    ProposalApprove
    "Proposal Create"
    ProposalCreate
    "Proposal Delete"
    ProposalDelete
    "Set Account Id"
    SetAccountId
    "Transfer"
    Transfer
    "Transfer Asset"
    TransferAsset
    "Trigger Smart"
    TriggerSmart
    "Unfreeze Asset"
    UnfreezeAsset
    "Unfreeze Balance"
    UnfreezeBalance
    "Update Asset"
    UpdateAsset
    "Update Brokerage"
    UpdateBrokerage
    "Update Energy Limit"
    UpdateEnergyLimit
    "Update Setting"
    UpdateSetting
    "Vote Witness"
    VoteWitness
    "Withdraw Balance"
    WithdrawBalance
    "Witness Create"
    WitnessCreate
    "Witness Update"
    WitnessUpdate
}

enum TronContractsMeasureable {
    "Block"
    block
    "Contract"
    contract_type
    "Date"
    date
    "Time"
    time
    "Transaction hash"
    tx_hash
    "Transaction owner"
    tx_owner
}

enum TronDexTradesMeasureable {
    "Block"
    block
    "Buy Amount"
    buy_amount
    "Buy Token address"
    buy_currency_address
    "Buy Currency symbol"
    buy_currency_symbol
    "Date"
    date
    "Maker"
    maker
    "Price"
    price
    "Quote Price"
    quote_price
    "Sell Amount"
    sell_amount
    "Sell Token address"
    sell_currency_address
    "Sell Currency symbol"
    sell_currency_symbol
    "Taker"
    taker
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum TronDexTradesUniq {
    "Unique makers & takers count"
    address
    "Base currencies count"
    base_currency
    "Unique blocks"
    blocks
    "Buy currencies count"
    buy_currency
    "Unique date count"
    dates
    "Unique makers count"
    makers
    "Unique protocols count"
    protocols
    "Quote currencies count"
    quote_currency
    "Sell currencies count"
    sell_currency
    "Unique smart contract count"
    smart_contracts
    "Unique makers count"
    takers
    "Unique transactions count"
    txs
}

enum TronEventsMeasureable {
    "Block"
    block
    "Date"
    date
    "Smart Contract Method Signature"
    signature
    "Smart Contract Method Signature Hash"
    signature_hash
    "Smart Contract Method Name"
    signature_name
    "Smart Contract"
    smart_contract
    "Time"
    time
    "Action From"
    tx_from
    "Transaction hash"
    tx_hash
    "Action To"
    tx_to
}

enum TronNetwork {
    "TRON mainnet"
    tron
}

enum TronTradesMeasureable {
    "Amount Sell"
    amount_buy
    "Amount Sell"
    amount_sell
    "Block"
    block
    "Buy Token address"
    buy_currency_address
    "Buy Currency name"
    buy_currency_name
    "Buy Currency symbol"
    buy_currency_symbol
    "Buy Token address"
    buy_token_id
    "Buy Token type"
    buy_token_type
    "Buyer"
    buyer
    "Contract Type"
    contract_type
    "Date"
    date
    "Exchange ID"
    exchange_id
    "Buy Token address"
    sell_currency_address
    "Buy Currency name"
    sell_currency_name
    "Buy Currency symbol"
    sell_currency_symbol
    "Buy Token address"
    sell_token_id
    "Buy Token type"
    sell_token_type
    "Seller"
    seller
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum TronTradesUniq {
    "Unique blocks"
    blocks
    "Buy currencies"
    buy_currencies
    "Buyers count"
    buyers
    "Unique date count"
    dates
    "Exchange IDs"
    exchanges
    "Sell currencies"
    sell_currencies
    "Sellers count"
    sellers
}

enum TronTransactionsMeasureable {
    "Block"
    block
    "Date"
    date
    "Energy Fee"
    energy_fee
    "Fee"
    fee
    "Fee Limit"
    fee_limit
    "Internal transactions count"
    internal_transactions_count
    "Net usage"
    net_usage
    "Time"
    time
    "Transaction hash"
    tx_hash
}

enum TronTransactionsUniq {
    "Unique blocks"
    blocks
    "Unique date count"
    dates
}

enum TronTransfersMeasureable {
    "Amount"
    amount
    "Block"
    block
    "Token address"
    currency_address
    "Currency symbol"
    currency_symbol
    "Date"
    date
    "Receiver"
    receiver
    "Sender"
    sender
    "Time"
    time
    "Token ID"
    token_id
    "Token type"
    token_type
    "Transaction hash"
    tx_hash
}

"Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string."
scalar BigInt

"An ISO 8601-encoded date"
scalar ISO8601Date

"An ISO 8601-encoded datetime"
scalar ISO8601DateTime

"Address selector"
input AddressSelector {
    "In the list of Addresses"
    in: [String!]
    "Equal to Address"
    is: String
    "Not Equal to Address"
    not: String
    "Not in the list of Addresses"
    notIn: [String!]
}

"Address selector"
input AddressSelectorIn {
    "In the list of Addresses"
    in: [String!]
    "Equal to Address"
    is: String
}

input AlgorandArgumentFilter {
    argindex: ArgumentIndexSelector
    argument: [ArgumentSelector!]
    caller: [AddressSelector!]
    date: DateSelector
    height: BlockSelector
    reference: [AddressSelector!]
    smartContractAddress: [AddressSelector!]
    time: DateTimeSelector
    txFrom: [AddressSelector!]
    txHash: HashSelector
    txIndex: TxIndexSelector
    txType: TxTypeSelector
    value: [ArgumentValueSelector!]
}

input AlgorandBlockFilter {
    blockHash: HashSelector
    blockReward: [AmountSelector!]
    currentProtocol: StringIdSelector
    date: DateSelector
    height: BlockSelector
    nextProtocol: StringIdSelector
    proposer: [AddressSelector!]
    time: DateTimeSelector
}

"""

Currency selector in Algorand blockchain.
Currency is selected by asset ID. To select ALGO use ID=0
"""
input AlgorandCurrencySelector {
    "Currency in the list"
    in: [Int!]
    "Currency is"
    is: Int
    "Currency not"
    not: Int
    "Currency not in the list"
    notIn: [Int!]
}

input AlgorandSmartContractCallFilter {
    date: DateSelector
    height: BlockSelector
    smartContractAddress: [AddressSelector!]
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [AddressSelector!]
    txType: TxTypeSelector
}

input AlgorandTransactionFilter {
    date: DateSelector
    height: BlockSelector
    time: DateTimeSelector
    txCurrency: [AlgorandCurrencySelector!]
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [AddressSelector!]
    txSubtype: TxSubtypeSelector
    txType: TxTypeSelector
}

input AlgorandTransferFilter {
    amount: [AmountSelector!]
    currency: [AlgorandCurrencySelector!]
    date: DateSelector
    height: BlockSelector
    receiver: [AddressSelector!]
    sender: [AddressSelector!]
    time: DateTimeSelector
    transferType: AlgorandTransferTypeSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [AddressSelector!]
    txType: TxTypeSelector
}

"Select transfers by type"
input AlgorandTransferTypeSelector {
    "Transfer Type in the list"
    in: [AlgorandTransferType!]
    "Transfer Type is"
    is: AlgorandTransferType
    "Transfer Type not"
    not: AlgorandTransferType
    "Transfer Type not in the list"
    notIn: [AlgorandTransferType!]
}

"Select by amount"
input AmountSelector {
    "Amount in range"
    between: [Float!]
    "Amount greater than"
    gt: Float
    "Amount greater or equal than"
    gteq: Float
    "Amount in the list"
    in: [Float!]
    "Amount is"
    is: Float
    "Amount less than"
    lt: Float
    "Amount less or equal than"
    lteq: Float
    "Amount not"
    not: Float
    "Amount not in the list"
    notIn: [Float!]
}

"Selector of index of argument in call"
input ArgumentIndexSelector {
    "Tx index in the list"
    in: [Int!]
    "Tx index is"
    is: Int
    "Tx index not"
    not: Int
    "Tx index not in the list"
    notIn: [Int!]
}

"Selector of argument for smart contract method or event"
input ArgumentSelector {
    "Argument in the list"
    in: [String!]
    "Argument is"
    is: String
    "Argument not"
    not: String
    "Argument not in the list"
    notIn: [String!]
}

"Selector of argument type for smart contract method or event"
input ArgumentTypeSelector {
    "Argument type in the list"
    in: [String!]
    "Argument type is"
    is: String
    "Argument type not"
    not: String
    "Argument type not in the list"
    notIn: [String!]
}

"Selector of value of argument for smart contract method or event"
input ArgumentValueSelector {
    "Value in the list"
    in: [String!]
    "Value is"
    is: String
    "Value not"
    not: String
    "Value not in the list"
    notIn: [String!]
}

"Binance Address should start with bnb and contain 42 chars."
input BinanceAddressSelector {
    "In the list of Addresses"
    in: String
    "Equal to Address"
    is: String
    "Not Equal to Address"
    not: String
    "Not in the list of Addresses"
    notIn: String
}

input BinanceBlockFilter {
    blockId: StringIdSelector
    date: DateSelector
    height: BlockSelector
    time: DateTimeSelector
    validatorFeeAddr: BinanceAddressSelector
    validatorMoniker: StringIdSelector
    validatorOperahraddress: BinanceAddressSelector
    validatorOperatorAddress: BinanceAddressSelector
}

"""

Binance token selector by tokenId.
Native binance token has BNB symbol.
Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
"""
input BinanceCurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

input BinanceOrderFilter {
    baseAmount: [AmountSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    date: DateSelector
    height: BlockSelector
    orderId: [OrderIdSelector!]
    orderOwner: [BinanceAddressSelector!]
    orderSide: [OrderSideSelector!]
    orderStatus: [OrderStatusSelector!]
    orderTimeInForce: [OrderTimeInForceSelector!]
    orderType: [OrderTypeSelector!]
    price: [AmountSelector!]
    quoteAmount: [AmountSelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    time: DateTimeSelector
    txHash: HashSelector
}

input BinanceTradeFilter {
    baseAmount: [AmountSelector!]
    baseCurrency: [BinanceCurrencySelector!]
    buyOrderId: [OrderIdSelector!]
    buyer: [BinanceAddressSelector!]
    date: DateSelector
    height: BlockSelector
    price: [AmountSelector!]
    quoteAmount: [AmountSelector!]
    quoteCurrency: [BinanceCurrencySelector!]
    sellOrderId: [OrderIdSelector!]
    seller: [BinanceAddressSelector!]
    time: DateTimeSelector
    tradeId: [TradeIdSelector!]
    txHash: HashSelector
}

input BinanceTransactionFilter {
    currency: [BinanceCurrencySelector!]
    date: DateSelector
    deposit: [AmountSelector!]
    height: BlockSelector
    proposalId: StringIdSelector
    time: DateTimeSelector
    transactionCode: IntIdSelector
    transactionSource: IntIdSelector
    transactionType: BinanceTransactionTypeSelector
    txHash: HashSelector
}

"Select by transaction type"
input BinanceTransactionTypeSelector {
    "Transaction Type in the list"
    in: [BinanceTransactionType!]
    "Transaction Type is"
    is: BinanceTransactionType
    "Transaction Type not"
    not: BinanceTransactionType
    "Transaction Type not in the list"
    notIn: [BinanceTransactionType!]
}

input BinanceTransferFilter {
    amount: [AmountSelector!]
    currency: [BinanceCurrencySelector!]
    date: DateSelector
    height: BlockSelector
    orderId: [OrderIdSelector!]
    outputIndex: [OutputIndexSelector!]
    receiver: [BinanceAddressSelector!]
    sender: [BinanceAddressSelector!]
    time: DateTimeSelector
    tradeId: [TradeIdSelector!]
    transferType: [BinanceTransferTypeSelector!]
    txHash: HashSelector
}

"Select transfer type(s)"
input BinanceTransferTypeSelector {
    "Transfer type in the list"
    in: [BinanceTransferType!]
    "Transfer type is"
    is: BinanceTransferType
    "Transfer type not"
    not: BinanceTransferType
    "Transfer type not in the list"
    notIn: [BinanceTransferType!]
}

input BitcoinBlockFilter {
    blockHash: StringIdSelector
    blockSize: IntegerSelector
    blockStrippedSize: IntegerSelector
    blockVersion: IntegerSelector
    blockWeight: IntegerSelector
    date: DateSelector
    difficulty: FloatSelector
    height: BlockSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
}

"Limits, Ordering, Constraints, Coinpath Options"
input BitcoinCoinpathOptions {
    "Ordering field(s) for ascending"
    asc: [String!]
    "Method to use coinpath"
    coinpathMethod: BitcoinCoinpathMethod
    "Raise error if complexity ( currently measured in transaction count ) is higher than this option"
    complexityLimit: Int
    "Ordering field(s) for descending"
    desc: [String!]
    "Flow direction"
    direction: FlowDirection
    "Limit number of results"
    limit: Int
    "Limit number of results by specific field"
    limitBy: LimitByOption
    "Do not expand addresses having count transactions more than this"
    maximumAddressTxCount: Int
    "Maximum total transaction count returned"
    maximumTotalTxCount: Int
    "Do not include transactions below this amount"
    minimumTxAmount: Float
    "Offset of results, starting from 0"
    offset: Int
    "Invalidating cache seed"
    seed: Int
}

input BitcoinInputFilter {
    date: DateSelector
    height: BlockSelector
    inOutputIndex: IntegerSelector
    inOutputTxId: HashSelector
    inputAddress: AddressSelector
    inputIndex: IntegerSelector
    inputScriptType: BitcoinInputScriptTypeSelector
    inputValue: FloatSelector
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: IntegerSelector
}

"Selector of input script type"
input BitcoinInputScriptTypeSelector {
    "In the list of Script Type"
    in: [BitcoinInputScriptType!]
    "Equal to Script Type"
    is: BitcoinInputScriptType
    "Not Equal to Script Type"
    not: BitcoinInputScriptType
    "Not in the list of Script Type"
    notIn: [BitcoinInputScriptType!]
}

input BitcoinOmniTransactionsFilter {
    date: DateSelector
    feeValue: FloatSelector
    height: BlockSelector
    invalidReason: StringSelector
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSender: HashSelector
    type: StringSelector
    typeId: IntegerSelector
    valid: IntegerSelector
    version: IntegerSelector
}

input BitcoinOmniTransfersFilter {
    date: DateSelector
    feeValue: FloatSelector
    height: BlockSelector
    invalidReason: StringSelector
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSender: HashSelector
    type: StringSelector
    typeId: IntegerSelector
    valid: IntegerSelector
    version: IntegerSelector
}

"A guessed direction of output"
input BitcoinOutputDirectionSelector {
    "In the list of direction"
    in: [BitcoinOutputDirection!]
    "Equal to direction"
    is: BitcoinOutputDirection
    "Not Equal to direction"
    not: BitcoinOutputDirection
    "Not in the list of direction"
    notIn: [BitcoinOutputDirection!]
}

input BitcoinOutputFilter {
    date: DateSelector
    height: BlockSelector
    outputAddress: AddressSelector
    outputDirection: BitcoinOutputDirectionSelector
    outputIndex: IntegerSelector
    outputScriptType: BitcoinOutputScriptTypeSelector
    outputValue: FloatSelector
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: IntegerSelector
}

"Selector of output script type"
input BitcoinOutputScriptTypeSelector {
    "In the list of Script Type"
    in: [BitcoinOutputScriptType!]
    "Equal to Script Type"
    is: BitcoinOutputScriptType
    "Not Equal to Script Type"
    not: BitcoinOutputScriptType
    "Not in the list of Script Type"
    notIn: [BitcoinOutputScriptType!]
}

input BitcoinTransactionFilter {
    date: DateSelector
    feeValue: FloatSelector
    height: BlockSelector
    inputAddress: AddressSelectorIn
    inputCount: IntegerSelector
    inputValue: FloatSelector
    minedValue: FloatSelector
    outputAddress: AddressSelectorIn
    outputCount: IntegerSelector
    outputValue: FloatSelector
    time: DateTimeSelector
    txCoinbase: Boolean
    txHash: HashSelector
    txIndex: IntegerSelector
    txLocktime: IntegerSelector
    txSize: IntegerSelector
    txVersion: IntegerSelector
    txVsize: IntegerSelector
    txWeight: IntegerSelector
}

"Select block by height ( sequence number)"
input BlockSelector {
    "Block height in range"
    between: [Int!]
    "Block height greater than"
    gt: Int
    "Block height greater or equal than"
    gteq: Int
    "Block height in the list"
    in: [Int!]
    "Block height is"
    is: Int
    "Block height less than"
    lt: Int
    "Block height less or equal than"
    lteq: Int
    "Block height not"
    not: Int
    "Block height not in the list"
    notIn: [Int!]
}

"Select block by height ( sequence number)"
input BlockSelectorRange {
    "Block height in range"
    between: [Int!]
    "Block height greater or equal than"
    gteq: Int
    "Block height less or equal than"
    lteq: Int
}

"Select by boolean (sequence number)"
input BooleanSelector {
    "Is"
    is: Boolean
    "Is not"
    not: Boolean
}

input CardanoBlockFilter {
    blockHash: StringIdSelector
    blockSize: IntegerSelector
    blockVersion: IntegerSelector
    date: DateSelector
    epoch: IntegerSelector
    height: BlockSelector
    opCert: StringSelector
    slot: IntegerSelector
    slotInEpoch: IntegerSelector
    slotLeaderHash: StringSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
    version: StringSelector
    vrfKey: StringSelector
}

"Limits, Ordering, Constraints, Coinpath Options"
input CardanoCoinpathOptions {
    "Ordering field(s) for ascending"
    asc: [String!]
    "Method to use coinpath"
    coinpathMethod: CardanoCoinpathMethod
    "Raise error if complexity ( currently measured in transaction count ) is higher than this option"
    complexityLimit: Int
    "Ordering field(s) for descending"
    desc: [String!]
    "Flow direction"
    direction: FlowDirection
    "Limit number of results"
    limit: Int
    "Limit number of results by specific field"
    limitBy: LimitByOption
    "Do not expand addresses having count transactions more than this"
    maximumAddressTxCount: Int
    "Maximum total transaction count returned"
    maximumTotalTxCount: Int
    "Do not include transactions below this amount"
    minimumTxAmount: Float
    "Offset of results, starting from 0"
    offset: Int
    "Invalidating cache seed"
    seed: Int
}

"""

Cardano token selector by tokenId.
Native binance token has ADA symbol, pass it as argument.
Otherwise pass asset fingerprint, starting from asset...
"""
input CardanoCurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

input CardanoInputFilter {
    currency: [CardanoCurrencySelector!]
    date: DateSelector
    height: BlockSelector
    inOutputIndex: IntegerSelector
    inOutputTxId: HashSelector
    inputAddress: AddressSelector
    inputIndex: IntegerSelector
    inputValue: FloatSelector
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: IntegerSelector
}

input CardanoMintFilter {
    currency: [CardanoCurrencySelector!]
    date: DateSelector
    height: BlockSelector
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    value: FloatSelector
}

"A guessed direction of output"
input CardanoOutputDirectionSelector {
    "In the list of direction"
    in: [CardanoOutputDirection!]
    "Equal to direction"
    is: CardanoOutputDirection
    "Not Equal to direction"
    not: CardanoOutputDirection
    "Not in the list of direction"
    notIn: [CardanoOutputDirection!]
}

input CardanoOutputFilter {
    currency: [CardanoCurrencySelector!]
    date: DateSelector
    height: BlockSelector
    outputAddress: AddressSelector
    outputDirection: CardanoOutputDirectionSelector
    outputIndex: IntegerSelector
    outputValue: FloatSelector
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: IntegerSelector
}

input CardanoTransactionFilter {
    date: DateSelector
    depositValue: FloatSelector
    feeValue: FloatSelector
    height: BlockSelector
    inputAddress: AddressSelectorIn
    inputCount: IntegerSelector
    inputValue: FloatSelector
    mintCount: IntegerSelector
    outputAddress: AddressSelectorIn
    outputCount: IntegerSelector
    outputValue: FloatSelector
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txSize: IntegerSelector
    withdrawalCount: IntegerSelector
    withdrawalValue: FloatSelector
}

"Limits, Ordering, Constraints, Coinpath Options"
input CoinpathOptions {
    "Ordering field(s) for ascending"
    asc: [String!]
    "Raise error if complexity ( currently measured in transaction count ) is higher than this option"
    complexityLimit: Int
    "Ordering field(s) for descending"
    desc: [String!]
    "Flow direction"
    direction: FlowDirection
    "Limit number of results"
    limit: Int
    "Limit number of results by specific field"
    limitBy: LimitByOption
    "Do not expand addresses having count transactions more than this"
    maximumAddressTxCount: Int
    "Maximum total transaction count returned"
    maximumTotalTxCount: Int
    "Do not include transactions below this amount"
    minimumTxAmount: Float
    "Offset of results, starting from 0"
    offset: Int
    "Invalidating cache seed"
    seed: Int
}

input ConfluxBlockFilter {
    blockHash: HashSelector
    date: DateSelector
    epoch: BlockSelector
    height: BlockSelector
    miner: [EthereumAddressSelector!]
    pivot: Boolean
    refereeCount: [IntegerSelector!]
    referenceBlockHash: HashSelector
    size: [IntegerSelector!]
    time: DateTimeSelector
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
}

input ConfluxTransactionFilter {
    amount: [AmountSelector!]
    blockHash: HashSelector
    date: DateSelector
    gasCurrency: [EthereumCurrencySelector!]
    height: BlockSelector
    success: Boolean
    time: DateTimeSelector
    txCreates: [EthereumAddressSelector!]
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
}

"Continent selector"
input ContinentSelector {
    "Country code in the list"
    in: [Continent!]
    "Country code is"
    is: Continent
    "Country code not"
    not: Continent
    "Country code not in the list"
    notIn: [Continent!]
}

"Country selector by 3 digit ISO code"
input CountrySelector {
    "Country code in the list"
    in: [CountryCode!]
    "Country code is"
    is: CountryCode
    "Country code not"
    not: CountryCode
    "Country code not in the list"
    notIn: [CountryCode!]
}

"Currency selector"
input CurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

"Selecting the date in a range, list or just date"
input DateSelector {
    "After date"
    after: ISO8601DateTime
    "Before date"
    before: ISO8601DateTime
    "Range of dates"
    between: [ISO8601DateTime!]
    "In dates"
    in: [ISO8601DateTime!]
    "Date equals"
    is: ISO8601DateTime
    "Date not equals"
    not: ISO8601DateTime
    "Not in dates"
    notIn: [ISO8601DateTime!]
    "Since date"
    since: ISO8601DateTime
    "Till date"
    till: ISO8601DateTime
}

"Selecting the time in a range, list or just time"
input DateTimeSelector {
    "After time"
    after: ISO8601DateTime
    "Before time"
    before: ISO8601DateTime
    "Range of time"
    between: [ISO8601DateTime!]
    "In times"
    in: [ISO8601DateTime!]
    "Time equals"
    is: ISO8601DateTime
    "Time not equals"
    not: ISO8601DateTime
    "Not in times"
    notIn: [ISO8601DateTime!]
    "Since time"
    since: ISO8601DateTime
    "Till time"
    till: ISO8601DateTime
}

input ElrondArgumentFilter {
    argumentIndex: IntegerSelector
    argumentValue: IntIdSelector
    blockHash: HashSelector
    blockNonce: IntegerSelector
    callDepth: IntegerSelector
    data: StringSelector
    dataOperation: StringSelector
    date: DateSelector
    epoch: IntegerSelector
    height: BlockSelector
    index: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: IntIdSelector
    nonce: IntegerSelector
    previousBlockHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    round: IntegerSelector
    shard: IntIdSelector
    signature: HashSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    smartContractAddress: HashSelector
    stateRootHash: HashSelector
    status: StringSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
    txHash: HashSelector
    txReceiver: HashSelector
    txReceiverShard: IntIdSelector
    txSender: HashSelector
    txSenderShard: IntIdSelector
    type: StringSelector
}

input ElrondBlockFilter {
    date: DateSelector
    epoch: IntegerSelector
    hash: HashSelector
    height: BlockSelector
    nonce: IntegerSelector
    previousBlockHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    round: IntegerSelector
    shard: IntIdSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    stateRootHash: IntegerSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
}

input ElrondBlockValidatorFilter {
    blockHash: HashSelector
    blockNonce: IntegerSelector
    date: DateSelector
    epoch: IntegerSelector
    height: BlockSelector
    previousBlockHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    round: IntegerSelector
    shard: IntIdSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    stateRootHash: HashSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
    validator: HashSelector
}

input ElrondCallFilter {
    blockHash: HashSelector
    blockNonce: IntegerSelector
    callDepth: StringSelector
    data: StringSelector
    dataOperation: StringSelector
    date: DateSelector
    epoch: IntegerSelector
    height: BlockSelector
    index: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: IntIdSelector
    nonce: IntegerSelector
    previousBlockHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    round: IntegerSelector
    shard: IntIdSelector
    signature: HashSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    smartContractAddress: HashSelector
    smartContractMethod: MethodSelector
    stateRootHash: HashSelector
    status: StringSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
    txHash: HashSelector
    txReceiver: HashSelector
    txReceiverShard: IntIdSelector
    txSender: HashSelector
    txSenderShard: IntIdSelector
    type: StringSelector
}

input ElrondCallResultFilter {
    blockHash: HashSelector
    blockNonce: IntegerSelector
    callResultData: StringSelector
    callResultDataOperation: StringSelector
    callResultGasLimit: FloatSelector
    callResultGasPrice: FloatSelector
    callResultHash: HashSelector
    callResultIndex: IntegerSelector
    callResultNonce: IntegerSelector
    callResultReceiver: HashSelector
    callResultRelayedValue: FloatSelector
    callResultSender: HashSelector
    callResultType: StringSelector
    callResultValue: FloatSelector
    data: StringSelector
    dataOperation: StringSelector
    date: DateSelector
    epoch: IntegerSelector
    height: BlockSelector
    index: IntegerSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: IntIdSelector
    nonce: IntegerSelector
    originTxHash: HashSelector
    previousBlockHash: HashSelector
    previousTxHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    relayed: StringSelector
    returnMessage: StringSelector
    round: IntegerSelector
    shard: IntIdSelector
    signature: HashSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    stateRootHash: HashSelector
    status: StringSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
    txHash: HashSelector
    txReceiver: HashSelector
    txReceiverShard: IntIdSelector
    txSender: HashSelector
    txSenderShard: IntIdSelector
    type: StringSelector
}

input ElrondMiniblockFilter {
    blockHash: HashSelector
    blockNonce: IntegerSelector
    date: DateSelector
    epoch: IntegerSelector
    height: BlockSelector
    miniblockHash: HashSelector
    previousBlockHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    receiverBlockHash: HashSelector
    receiverShard: IntIdSelector
    round: IntegerSelector
    shard: IntIdSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    stateRootHash: HashSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
    type: StringSelector
}

input ElrondNotarizedBlockFilter {
    blockHash: HashSelector
    blockNonce: IntegerSelector
    date: DateSelector
    epoch: IntegerSelector
    height: BlockSelector
    notarizedBlockHash: HashSelector
    previousBlockHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    round: IntegerSelector
    shard: IntIdSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    stateRootHash: HashSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
}

input ElrondTransactionFilter {
    blockHash: HashSelector
    blockNonce: IntegerSelector
    data: StringSelector
    dataOperation: StringSelector
    date: DateSelector
    epoch: IntegerSelector
    fee: FloatSelector
    gasLimit: FloatSelector
    gasPrice: FloatSelector
    gasUsed: FloatSelector
    height: BlockSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: IntIdSelector
    previousBlockHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    round: IntegerSelector
    shard: IntIdSelector
    signature: HashSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    stateRootHash: HashSelector
    status: StringSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
    txHash: HashSelector
    txIndex: IntegerSelector
    txNonce: IntegerSelector
    txReceiver: HashSelector
    txReceiverShard: IntIdSelector
    txSender: HashSelector
    txSenderShard: IntIdSelector
    txValue: FloatSelector
    type: StringSelector
}

input ElrondTransferFilter {
    blockHash: HashSelector
    blockNonce: IntegerSelector
    currency: CurrencySelector
    data: StringSelector
    dataOperation: StringSelector
    date: DateSelector
    epoch: IntegerSelector
    height: BlockSelector
    index: IntegerSelector
    metadata: StringSelector
    miniblockHash: HashSelector
    miniblockReceiverBlockHash: HashSelector
    miniblockReceiverShard: IntIdSelector
    nftNonce: IntIdSelector
    nonce: IntegerSelector
    previousBlockHash: HashSelector
    proposer: HashSelector
    publicKeyBitmap: StringSelector
    round: IntegerSelector
    shard: IntIdSelector
    signature: HashSelector
    size: IntegerSelector
    sizeTxs: IntegerSelector
    stateRootHash: HashSelector
    status: StringSelector
    time: DateTimeSelector
    transactionCount: IntegerSelector
    transferReason: TransferReasonSelector
    transferReceiver: AddressSelector
    transferSender: AddressSelector
    txHash: HashSelector
    txReceiver: HashSelector
    txReceiverShard: IntIdSelector
    txSender: HashSelector
    txSenderShard: IntIdSelector
    type: StringSelector
}

"Selector of entity ID for NFT  tokens"
input EntitySelector {
    "EntityID in the list"
    in: [String!]
    "EntityID is"
    is: String
    "EntityID not"
    not: String
    "EntityID not in the list"
    notIn: [String!]
}

"Select by entity type"
input EntityTypeSelector {
    "Type in the list"
    in: [EntityTypeEnum!]
    "Type is"
    is: EntityTypeEnum
    "Type not"
    not: EntityTypeEnum
    "Type not in the list"
    notIn: [EntityTypeEnum!]
}

input EosBlockFilter {
    blockHash: HashSelector
    date: DateSelector
    height: BlockSelector
    proposer: AddressSelector
    time: DateTimeSelector
}

"""

Currency selector in EOS blockchain.
Token identified by address of contract ( eosio.token for main EOS token )
"""
input EosCurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

input EosSmartContractCallFilter {
    date: DateSelector
    external: Boolean
    height: BlockSelector
    scheduled: Boolean
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    success: Boolean
    time: DateTimeSelector
    txFrom: AddressSelector
    txHash: HashSelector
    txTo: AddressSelector
}

input EosTransactionFilter {
    date: DateSelector
    height: BlockSelector
    scheduled: Boolean
    success: Boolean
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
}

input EosTransferFilter {
    amount: [AmountSelector!]
    currency: EosCurrencySelector
    date: DateSelector
    entityId: EntitySelector
    external: Boolean
    height: BlockSelector
    receiver: AddressSelector
    sender: AddressSelector
    success: Boolean
    time: DateTimeSelector
    txFrom: AddressSelector
    txHash: HashSelector
    txTo: AddressSelector
}

input Ethereum2Filter {
    blockProposerIndex: [IntegerSelector!]
    blockRootHash: HashSelector
    date: DateSelector
    height: BlockSelector
    time: DateTimeSelector
}

"""

Address should start from 0x and contain hex digits.
If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelector {
    "In the list of Addresses"
    in: [String!]
    "Equal to Address"
    is: String
    "Not Equal to Address"
    not: String
    "Not in the list of Addresses"
    notIn: [String!]
}

"""

Address should start from 0x and contain hex digits.
If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelectorIn {
    "In the list of Addresses"
    in: [String!]
    "Equal to Address"
    is: String
}

input EthereumArgumentFilter {
    argument: [ArgumentSelector!]
    argumentType: [ArgumentTypeSelector!]
    caller: [EthereumAddressSelector!]
    date: DateSelector
    external: Boolean
    height: BlockSelector
    reference: [EthereumAddressSelector!]
    signatureType: SignatureTypeSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractEvent: EventSelector
    smartContractMethod: MethodSelector
    time: DateTimeSelector
    txFrom: [EthereumAddressSelector!]
    txHash: HashSelector
    value: [ArgumentValueSelector!]
}

input EthereumBlockFilter {
    blockHash: HashSelector
    blockReward: [AmountSelector!]
    date: DateSelector
    height: BlockSelector
    miner: [EthereumAddressSelector!]
    size: [IntegerSelector!]
    time: DateTimeSelector
    transactionCount: [IntegerSelector!]
    uncleCount: [IntegerSelector!]
}

"""

Currency selector in Ethereum blockchain.
Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.
Ethereum Smart contract address should start from 0x and contain 40 hex digits.
If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumCurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

input EthereumDexTradeFilter {
    baseCurrency: [EthereumCurrencySelector!]
    buyAmount: [AmountSelector!]
    buyCurrency: [EthereumCurrencySelector!]
    date: DateSelector
    exchangeAddress: [EthereumAddressSelector!]
    exchangeName: [StringSelector!]
    height: BlockSelector
    maker: [EthereumAddressSelector!]
    makerOrTaker: [EthereumAddressSelector!]
    makerSmartContractType: [SmartContractTypeSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    protocol: [StringSelector!]
    quoteCurrency: [EthereumCurrencySelector!]
    sellAmount: [AmountSelector!]
    sellCurrency: [EthereumCurrencySelector!]
    smartContractAddress: [EthereumAddressSelector!]
    taker: [EthereumAddressSelector!]
    takerSmartContractType: [SmartContractTypeSelector!]
    time: DateTimeSelector
    tradeAmountUsd: [FloatSelector!]
    tradeIndex: [StringSelector!]
    txHash: HashSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
}

input EthereumSmartContractCallFilter {
    caller: [EthereumAddressSelector!]
    date: DateSelector
    external: Boolean
    height: BlockSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractMethod: MethodSelector
    smartContractType: SmartContractTypeSelector
    success: [Boolean!]
    time: DateTimeSelector
    txFrom: [EthereumAddressSelector!]
    txHash: HashSelector
}

input EthereumSmartContractEventFilter {
    date: DateSelector
    height: BlockSelector
    smartContractAddress: [EthereumAddressSelector!]
    smartContractEvent: EventSelector
    smartContractType: SmartContractTypeSelector
    time: DateTimeSelector
    txFrom: [EthereumAddressSelector!]
    txHash: HashSelector
}

input EthereumTransactionFilter {
    amount: [AmountSelector!]
    date: DateSelector
    gasCurrency: [EthereumCurrencySelector!]
    gasValue: [AmountSelector!]
    height: BlockSelector
    success: Boolean
    time: DateTimeSelector
    txCreates: [EthereumAddressSelector!]
    txHash: HashSelector
    txIndex: TxIndexSelector
    txSender: [EthereumAddressSelector!]
    txTo: [EthereumAddressSelector!]
}

input EthereumTransferFilter {
    amount: [AmountSelector!]
    currency: [EthereumCurrencySelector!]
    date: DateSelector
    entityId: EntitySelector
    external: Boolean
    height: BlockSelector
    receiver: [EthereumAddressSelector!]
    sender: [EthereumAddressSelector!]
    success: Boolean
    time: DateTimeSelector
    txFrom: [EthereumAddressSelector!]
    txHash: HashSelector
}

"Smart contract event. In selector you can use the name, signature or hex hash"
input EventSelector {
    "Event signature in the list"
    in: [String!]
    "Event signature is"
    is: String
    "Event signature not"
    not: String
    "Event signature not in the list"
    notIn: [String!]
}

input FilecoinBlockFilter {
    blockHash: HashSelector
    blockIndex: IntegerSelector
    date: DateSelector
    height: BlockSelector
    miner: [AddressSelector!]
    time: DateTimeSelector
}

input FilecoinCallFilter {
    amount: AmountSelector
    date: DateSelector
    hash: HashSelector
    height: BlockSelector
    messageMethod: IntegerSelector
    method: IntegerSelector
    receiver: AddressSelector
    sender: AddressSelector
    time: DateTimeSelector
}

input FilecoinMessageFilter {
    amount: AmountSelector
    date: DateSelector
    hash: HashSelector
    height: BlockSelector
    index: IntegerSelector
    method: IntegerSelector
    receiver: AddressSelector
    sender: AddressSelector
    success: Boolean
    time: DateTimeSelector
}

input FilecoinTransferFilter {
    amount: AmountSelector
    date: DateSelector
    hash: HashSelector
    height: BlockSelector
    messageMethod: IntegerSelector
    method: IntegerSelector
    receiver: AddressSelector
    sender: AddressSelector
    time: DateTimeSelector
    transferType: TransferTypeSelector
}

"Select by number"
input FloatSelector {
    "in range"
    between: [Float!]
    "greater than"
    gt: Float
    "greater or equal than"
    gteq: Float
    "in the list"
    in: [Float!]
    "is"
    is: Float
    "less than"
    lt: Float
    "less or equal than"
    lteq: Float
    "not"
    not: Float
    "not in the list"
    notIn: [Float!]
}

"Select by hash"
input HashSelector {
    "Hash in the list"
    in: [String!]
    "Hash is"
    is: String
    "Hash not"
    not: String
    "Hash not in the list"
    notIn: [String!]
}

input HederaArgumentFilter {
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    result: HashSelector
    smartContractEntity: StringSelector
    success: Boolean
    transactionHash: HashSelector
}

input HederaCallFilter {
    callInput: HashSelector
    callResult: HashSelector
    date: DateSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    result: HashSelector
    smartContractEntity: StringSelector
    success: Boolean
    transactionHash: HashSelector
}

"Currency selector in Hedera blockchain."
input HederaCurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

input HederaInputFilter {
    amount: [AmountSelector!]
    date: DateSelector
    entityType: EntityTypeSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    result: HashSelector
    success: Boolean
    transactionHash: HashSelector
    transferEntity: StringSelector
}

input HederaMessageFilter {
    date: DateSelector
    entityType: EntityTypeSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    result: HashSelector
    success: Boolean
    transactionHash: HashSelector
    transactionRunningHash: HashSelector
}

input HederaOutputFilter {
    date: DateSelector
    entityType: EntityTypeSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    result: HashSelector
    success: Boolean
    transactionHash: HashSelector
    transferEntity: StringSelector
}

input HederaTransactionFilter {
    date: DateSelector
    entityType: EntityTypeSelector
    nodeAccount: StringSelector
    payerAccount: StringSelector
    result: HashSelector
    success: Boolean
    transactionHash: HashSelector
}

"Select by ID"
input IntIdSelector {
    "ID in range"
    between: [Int!]
    "ID greater than"
    gt: Int
    "ID greater or equal than"
    gteq: Int
    "ID in the list"
    in: [Int!]
    "ID is"
    is: Int
    "ID less than"
    lt: Int
    "ID less or equal than"
    lteq: Int
    "ID not"
    not: Int
    "ID not in the list"
    notIn: [Int!]
}

"Select limited upper number"
input IntegerLimitedSelector {
    "in range"
    between: [Int!]
    "in the list"
    in: [Int!]
    "is"
    is: Int
    "less than"
    lt: Int
    "less or equal than"
    lteq: Int
}

"Select by number"
input IntegerSelector {
    "in range"
    between: [Int!]
    "greater than"
    gt: Int
    "greater or equal than"
    gteq: Int
    "in the list"
    in: [Int!]
    "is"
    is: Int
    "less than"
    lt: Int
    "less or equal than"
    lteq: Int
    "not"
    not: Int
    "not in the list"
    notIn: [Int!]
}

input LibraBlockFilter {
    date: DateSelector
    height: BlockSelector
    metadata: StringSelector
    proposer: [AddressSelector!]
    time: DateTimeSelector
    version: IntegerSelector
}

"""

Currency selector in Libra blockchain.
Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
Use name of currency for selection
"""
input LibraCurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

input LibraMintFilter {
    amount: [AmountSelector!]
    block: BlockSelector
    currency: [LibraCurrencySelector!]
    date: DateSelector
    minter: AddressSelector
    time: DateTimeSelector
    version: IntegerSelector
}

input LibraTransactionFilter {
    date: DateSelector
    gasCurrency: [LibraCurrencySelector!]
    height: BlockSelector
    scriptHash: StringSelector
    scriptType: ScriptTypeSelectorSelector
    success: Boolean
    time: DateTimeSelector
    txSender: AddressSelector
    version: IntegerSelector
}

input LibraTransferFilter {
    amount: [AmountSelector!]
    currency: [LibraCurrencySelector!]
    date: DateSelector
    gasCurrency: [LibraCurrencySelector!]
    height: BlockSelector
    receiver: AddressSelector
    scriptHash: StringSelector
    scriptType: ScriptTypeSelectorSelector
    sender: AddressSelector
    time: DateTimeSelector
    txSender: AddressSelector
    version: IntegerSelector
}

"Limit by definition"
input LimitByOption {
    "Take limit for each combination of the field"
    each: String!
    "Limit number of results"
    limit: Int
    "Offset of results, starting from 0"
    offset: Int
}

"Smart contract method. In selector you can use the name, signature or hex hash"
input MethodSelector {
    "Method signature in the list"
    in: [String!]
    "Method signature is"
    is: String
    "Method signature not"
    not: String
    "Method signature not in the list"
    notIn: [String!]
}

"Select order by ID"
input OrderIdSelector {
    "Order ID in the list"
    in: [String!]
    "Order ID is"
    is: String
    "Order ID not"
    not: String
    "Order ID not in the list"
    notIn: [String!]
}

"Select by order side"
input OrderSideSelector {
    "Order Side in the list"
    in: [BinanceOrderSide!]
    "Order Side is"
    is: BinanceOrderSide
    "Order Side not"
    not: BinanceOrderSide
    "Order Side not in the list"
    notIn: [BinanceOrderSide!]
}

"Select by order status"
input OrderStatusSelector {
    "Order Status in the list"
    in: [BinanceOrderStatus!]
    "Order Status is"
    is: BinanceOrderStatus
    "Order Status not"
    not: BinanceOrderStatus
    "Order Status not in the list"
    notIn: [BinanceOrderStatus!]
}

"Select by order time in force"
input OrderTimeInForceSelector {
    "Order TimeInForce in the list"
    in: [BinanceOrderTimeInForce!]
    "Order TimeInForce is"
    is: BinanceOrderTimeInForce
    "Order TimeInForce not"
    not: BinanceOrderTimeInForce
    "Order TimeInForce not in the list"
    notIn: [BinanceOrderTimeInForce!]
}

"Select by order type"
input OrderTypeSelector {
    "Order Type in the list"
    in: [BinanceOrderType!]
    "Order Type is"
    is: BinanceOrderType
    "Order Type not"
    not: BinanceOrderType
    "Order Type not in the list"
    notIn: [BinanceOrderType!]
}

"Select by output index ( o based )"
input OutputIndexSelector {
    "Output index in range"
    between: [Int!]
    "Output index greater than"
    gt: Int
    "Output index greater or equal than"
    gteq: Int
    "Output index in the list"
    in: [Int!]
    "Output index is"
    is: Int
    "Output index less than"
    lt: Int
    "Output index less or equal than"
    lteq: Int
    "Output index not"
    not: Int
    "Output index not in the list"
    notIn: [Int!]
}

"Limits, Ordering, Constraints"
input QueryOptions {
    "Ordering field(s) for ascending"
    asc: [String!]
    "Ordering field(s) for descending"
    desc: [String!]
    "Limit number of results"
    limit: Int
    "Limit number of results by specific field"
    limitBy: LimitByOption
    "Offset of results, starting from 0"
    offset: Int
}

"Select by reward type"
input RewardTypeSelector {
    "Type in the list"
    in: [SolanaRewardType!]
    "Type is"
    is: SolanaRewardType
    "Type not"
    not: SolanaRewardType
    "Type not in the list"
    notIn: [SolanaRewardType!]
}

"Selector of smart contract type"
input SmartContractTypeSelector {
    "Smart Contract type in the list"
    in: [SmartContractType!]
    "Smart Contract type is"
    is: SmartContractType
    "Smart Contract type not"
    not: SmartContractType
    "Smart Contract type not in the list"
    notIn: [SmartContractType!]
}

input SolanaBlockRewardsFilter {
    blockHash: HashSelector
    date: DateSelector
    height: BlockSelector
    parentSlot: IntegerSelector
    previousBlockHash: HashSelector
    reward: AmountSelector
}

input SolanaBlocksFilter {
    blockHash: HashSelector
    date: DateSelector
    height: BlockSelector
    parentSlot: IntegerSelector
    previousBlockHash: HashSelector
    rewards: AmountSelector
    transactionCount: IntegerSelector
}

"Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol"
input SolanaCurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

input SolanaInstructionsFilter {
    blockHash: HashSelector
    callPath: StringSelector
    date: DateSelector
    external: IntegerSelector
    externalParsedActionName: StringSelector
    externalParsedProgramName: StringSelector
    externalProgramId: StringSelector
    fee: IntegerSelector
    feePayer: HashSelector
    height: BlockSelector
    parsedActionName: StringSelector
    parsedProgramName: StringSelector
    parsedType: StringSelector
    previousBlockHash: HashSelector
    programId: StringSelector
    signature: StringSelector
    success: BooleanSelector
    time: DateTimeSelector
    transactionIndex: IntegerSelector
}

input SolanaTransactionsFilter {
    blockHash: HashSelector
    date: DateSelector
    fee: IntegerSelector
    feePayer: HashSelector
    height: BlockSelector
    parentSlot: BlockSelector
    previousBlockHash: HashSelector
    recentBlockHash: HashSelector
    signature: HashSelector
    signer: HashSelector
    success: BooleanSelector
    transactionFee: AmountSelector
    transactionIndex: IntegerSelector
}

"Select by transfer type"
input SolanaTransferTypeSelector {
    "Type in the list"
    in: [SolanaTransferType!]
    "Type is"
    is: SolanaTransferType
    "Type not"
    not: SolanaTransferType
    "Type not in the list"
    notIn: [SolanaTransferType!]
}

input SolanaTransfersFilter {
    blockHash: HashSelector
    callPath: StringSelector
    currency: [SolanaCurrencySelector!]
    date: DateSelector
    external: StringSelector
    externalParsedActionName: StringSelector
    externalParsedProgramName: StringSelector
    externalProgramId: StringSelector
    feePayer: HashSelector
    height: BlockSelector
    parsedActionName: StringSelector
    parsedProgramName: StringSelector
    parsedType: StringSelector
    previousBlockHash: HashSelector
    programId: StringSelector
    receiverAddress: StringSelector
    receiverType: StringSelector
    recentBlockHash: HashSelector
    senderAddress: StringSelector
    senderType: StringSelector
    signature: HashSelector
    success: BooleanSelector
    time: DateTimeSelector
    transactionIndex: IntegerSelector
    transferType: SolanaTransferTypeSelector
}

"Select by ID"
input StringIdSelector {
    "ID in the list"
    in: [String!]
    "ID is"
    is: String
    "ID not"
    not: String
    "ID not in the list"
    notIn: [String!]
}

"Select by string"
input StringSelector {
    "String in the list"
    in: [String!]
    "String is"
    is: String
    "String not"
    not: String
    "String not in the list"
    notIn: [String!]
}

"Select trade by ID"
input TradeIdSelector {
    "Trade ID in the list"
    in: [String!]
    "Trade ID is"
    is: String
    "Trade ID not"
    not: String
    "Trade ID not in the list"
    notIn: [String!]
}

"Select by transfer reason"
input TransferReasonSelector {
    "Reason in the list"
    in: [TransferReasonEnum!]
    "Reason is"
    is: TransferReasonEnum
    "Reason not"
    not: TransferReasonEnum
    "Reason not in the list"
    notIn: [TransferReasonEnum!]
}

"Select by type of transfer"
input TransferTypeSelector {
    "Transfer Type in the list"
    in: [FilecoinTransferType!]
    "Transfer Type is"
    is: FilecoinTransferType
    "Transfer Type not"
    not: FilecoinTransferType
    "Transfer Type not in the list"
    notIn: [FilecoinTransferType!]
}

input TronBlockFilter {
    blockHash: HashSelector
    date: DateSelector
    height: BlockSelector
    parentBlockHash: [HashSelector!]
    time: DateTimeSelector
    version: IntegerSelector
    witness: AddressSelector
}

input TronContractFilter {
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    date: DateSelector
    height: BlockSelector
    success: Boolean
    time: DateTimeSelector
    txHash: HashSelector
    txOwner: AddressSelector
}

"Select contract type(s)"
input TronContractTypeSelector {
    "Contract type in the list"
    in: [TronContractType!]
    "Contract type is"
    is: TronContractType
    "Contract type not"
    not: TronContractType
    "Contract type not in the list"
    notIn: [TronContractType!]
}

"""

Currency selector in Tron blockchain.
Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
"""
input TronCurrencySelector {
    "Currency in the list"
    in: [String!]
    "Currency is"
    is: String
    "Currency not"
    not: String
    "Currency not in the list"
    notIn: [String!]
}

input TronDexTradeFilter {
    baseCurrency: [TronCurrencySelector!]
    buyAmount: [AmountSelector!]
    buyCurrency: [TronCurrencySelector!]
    date: DateSelector
    exchangeAddress: [AddressSelector!]
    exchangeName: [StringSelector!]
    height: BlockSelector
    maker: [AddressSelector!]
    makerOrTaker: [AddressSelector!]
    price: [AmountSelector!]
    priceAsymmetry: [FloatSelector!]
    protocol: [StringSelector!]
    quoteCurrency: [TronCurrencySelector!]
    sellAmount: [AmountSelector!]
    sellCurrency: [TronCurrencySelector!]
    smartContractAddress: [AddressSelector!]
    taker: [AddressSelector!]
    time: DateTimeSelector
    tradeAmountUsd: [FloatSelector!]
    tradeIndex: [StringSelector!]
    txHash: HashSelector
}

input TronSmartContractCallFilter {
    date: DateSelector
    external: Boolean
    height: BlockSelector
    smartContractAddress: AddressSelector
    smartContractMethod: MethodSelector
    success: Boolean
    time: DateTimeSelector
    txFrom: AddressSelector
    txHash: HashSelector
    txTo: AddressSelector
}

input TronSmartContractEventFilter {
    date: DateSelector
    height: BlockSelector
    smartContractAddress: AddressSelector
    smartContractEvent: EventSelector
    time: DateTimeSelector
    txFrom: AddressSelector
    txHash: HashSelector
    txTo: AddressSelector
}

input TronTradeFilter {
    amountBuy: [AmountSelector!]
    amountSell: [AmountSelector!]
    buyCurrency: TronCurrencySelector
    buyer: AddressSelector
    contractType: TronContractTypeSelector
    date: DateSelector
    exchangeId: IntIdSelector
    height: BlockSelector
    sellCurrency: TronCurrencySelector
    seller: AddressSelector
    success: Boolean
    time: DateTimeSelector
    txHash: HashSelector
}

input TronTransactionFilter {
    contractAddress: AddressSelector
    date: DateSelector
    height: BlockSelector
    refBlockHash: [HashSelector!]
    success: Boolean
    time: DateTimeSelector
    txHash: HashSelector
    txIndex: TxIndexSelector
}

input TronTransferFilter {
    amount: [AmountSelector!]
    contractType: TronContractTypeSelector
    currency: TronCurrencySelector
    date: DateSelector
    entityId: EntitySelector
    external: Boolean
    height: BlockSelector
    receiver: AddressSelector
    sender: AddressSelector
    success: Boolean
    time: DateTimeSelector
    txFrom: AddressSelector
    txHash: HashSelector
    txTo: AddressSelector
}

"Selector of index of transaction in block"
input TxIndexSelector {
    "Tx index in the list"
    in: [Int!]
    "Tx index is"
    is: Int
    "Tx index not"
    not: Int
    "Tx index not in the list"
    notIn: [Int!]
}

"Select transactions by subtype"
input TxSubtypeSelector {
    "Transaction SubType in the list"
    in: [AlgorandTxSubType!]
    "Transaction SubType is"
    is: AlgorandTxSubType
    "Transaction SubType not"
    not: AlgorandTxSubType
    "Transaction SubType not in the list"
    notIn: [AlgorandTxSubType!]
}

"Select transactions by type"
input TxTypeSelector {
    "Transaction Type in the list"
    in: [AlgorandTxType!]
    "Transaction Type is"
    is: AlgorandTxType
    "Transaction Type not"
    not: AlgorandTxType
    "Transaction Type not in the list"
    notIn: [AlgorandTxType!]
}
